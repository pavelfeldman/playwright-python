<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>playwright.sync_api API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>playwright.sync_api</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) Microsoft Corporation.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import pathlib
import sys
import typing

if sys.version_info &gt;= (3, 8):  # pragma: no cover
    from typing import Literal
else:  # pragma: no cover
    from typing_extensions import Literal

from playwright.accessibility import Accessibility as AccessibilityImpl
from playwright.browser import Browser as BrowserImpl
from playwright.browser_context import BrowserContext as BrowserContextImpl
from playwright.browser_type import BrowserType as BrowserTypeImpl
from playwright.cdp_session import CDPSession as CDPSessionImpl
from playwright.chromium_browser_context import (
    ChromiumBrowserContext as ChromiumBrowserContextImpl,
)
from playwright.console_message import ConsoleMessage as ConsoleMessageImpl
from playwright.dialog import Dialog as DialogImpl
from playwright.download import Download as DownloadImpl
from playwright.element_handle import ElementHandle as ElementHandleImpl
from playwright.file_chooser import FileChooser as FileChooserImpl
from playwright.frame import Frame as FrameImpl
from playwright.helper import (
    ConsoleMessageLocation,
    Credentials,
    DeviceDescriptor,
    Error,
    FilePayload,
    FloatRect,
    Geolocation,
    IntSize,
    MousePosition,
    PdfMargins,
    ProxyServer,
    RecordHarOptions,
    RecordVideoOptions,
    RequestFailure,
    ResourceTiming,
    SelectOption,
    SetStorageState,
    StorageState,
    Viewport,
)
from playwright.input import Keyboard as KeyboardImpl
from playwright.input import Mouse as MouseImpl
from playwright.input import Touchscreen as TouchscreenImpl
from playwright.js_handle import JSHandle as JSHandleImpl
from playwright.network import Request as RequestImpl
from playwright.network import Response as ResponseImpl
from playwright.network import Route as RouteImpl
from playwright.network import WebSocket as WebSocketImpl
from playwright.page import BindingCall as BindingCallImpl
from playwright.page import Page as PageImpl
from playwright.page import Worker as WorkerImpl
from playwright.playwright import Playwright as PlaywrightImpl
from playwright.selectors import Selectors as SelectorsImpl
from playwright.sync_base import EventContextManager, SyncBase, mapping
from playwright.video import Video as VideoImpl

NoneType = type(None)


class Request(SyncBase):
    def __init__(self, obj: RequestImpl):
        super().__init__(obj)

    @property
    def url(self) -&gt; str:
        &#34;&#34;&#34;Request.url

        Returns
        -------
        str
            URL of the request.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.url)

    @property
    def resourceType(self) -&gt; str:
        &#34;&#34;&#34;Request.resourceType

        Contains the request&#39;s resource type as it was perceived by the rendering engine.
        ResourceType will be one of the following: `document`, `stylesheet`, `image`, `media`, `font`, `script`, `texttrack`, `xhr`, `fetch`, `eventsource`, `websocket`, `manifest`, `other`.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.resourceType)

    @property
    def method(self) -&gt; str:
        &#34;&#34;&#34;Request.method

        Returns
        -------
        str
            Request&#39;s method (GET, POST, etc.)
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.method)

    @property
    def postData(self) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;Request.postData

        Returns
        -------
        Optional[str]
            Request&#39;s post body, if any.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.postData)

    @property
    def postDataJSON(self) -&gt; typing.Union[typing.Dict, NoneType]:
        &#34;&#34;&#34;Request.postDataJSON

        When the response is `application/x-www-form-urlencoded` then a key/value object of the values will be returned. Otherwise it will be parsed as JSON.

        Returns
        -------
        Optional[Dict]
            Parsed request&#39;s body for `form-urlencoded` and JSON as a fallback if any.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.postDataJSON)

    @property
    def postDataBuffer(self) -&gt; typing.Union[bytes, NoneType]:
        &#34;&#34;&#34;Request.postDataBuffer

        Returns
        -------
        Optional[bytes]
            Request&#39;s post body in a binary form, if any.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.postDataBuffer)

    @property
    def headers(self) -&gt; typing.Dict[str, str]:
        &#34;&#34;&#34;Request.headers

        Returns
        -------
        Dict[str, str]
            An object with HTTP headers associated with the request. All header names are lower-case.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.headers)

    @property
    def frame(self) -&gt; &#34;Frame&#34;:
        &#34;&#34;&#34;Request.frame

        Returns
        -------
        Frame
            A Frame that initiated this request.
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.frame)

    @property
    def redirectedFrom(self) -&gt; typing.Union[&#34;Request&#34;, NoneType]:
        &#34;&#34;&#34;Request.redirectedFrom

        When the server responds with a redirect, Playwright creates a new Request object. The two requests are connected by `redirectedFrom()` and `redirectedTo()` methods. When multiple server redirects has happened, it is possible to construct the whole redirect chain by repeatedly calling `redirectedFrom()`.
        For example, if the website `http://example.com` redirects to `https://example.com`:
        If the website `https://google.com` has no redirects:

        Returns
        -------
        Optional[Request]
            Request that was redirected by the server to this one, if any.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._impl_obj.redirectedFrom)

    @property
    def redirectedTo(self) -&gt; typing.Union[&#34;Request&#34;, NoneType]:
        &#34;&#34;&#34;Request.redirectedTo

        This method is the opposite of request.redirectedFrom():

        Returns
        -------
        Optional[Request]
            New request issued by the browser if the server responded with redirect.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._impl_obj.redirectedTo)

    @property
    def failure(self) -&gt; typing.Union[RequestFailure, NoneType]:
        &#34;&#34;&#34;Request.failure

        The method returns `null` unless this request has failed, as reported by
        `requestfailed` event.
        Example of logging of all the failed requests:

        Returns
        -------
        Optional[{&#34;errorText&#34;: str}]
            Object describing request failure, if any
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.failure)

    @property
    def timing(self) -&gt; ResourceTiming:
        &#34;&#34;&#34;Request.timing

        Returns resource timing information for given request. Most of the timing values become available upon the response, `responseEnd` becomes available when request finishes. Find more information at Resource Timing API.

        Returns
        -------
        {&#34;startTime&#34;: float, &#34;domainLookupStart&#34;: float, &#34;domainLookupEnd&#34;: float, &#34;connectStart&#34;: float, &#34;secureConnectionStart&#34;: float, &#34;connectEnd&#34;: float, &#34;requestStart&#34;: float, &#34;responseStart&#34;: float, &#34;responseEnd&#34;: float}
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.timing)

    def response(self) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
        &#34;&#34;&#34;Request.response

        Returns
        -------
        Optional[Response]
            A matching Response object, or `null` if the response was not received due to error.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._sync(self._impl_obj.response()))

    def isNavigationRequest(self) -&gt; bool:
        &#34;&#34;&#34;Request.isNavigationRequest

        Whether this request is driving frame&#39;s navigation.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.isNavigationRequest())


mapping.register(RequestImpl, Request)


class Response(SyncBase):
    def __init__(self, obj: ResponseImpl):
        super().__init__(obj)

    @property
    def url(self) -&gt; str:
        &#34;&#34;&#34;Response.url

        Contains the URL of the response.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.url)

    @property
    def ok(self) -&gt; bool:
        &#34;&#34;&#34;Response.ok

        Contains a boolean stating whether the response was successful (status in the range 200-299) or not.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.ok)

    @property
    def status(self) -&gt; int:
        &#34;&#34;&#34;Response.status

        Contains the status code of the response (e.g., 200 for a success).

        Returns
        -------
        int
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.status)

    @property
    def statusText(self) -&gt; str:
        &#34;&#34;&#34;Response.statusText

        Contains the status text of the response (e.g. usually an &#34;OK&#34; for a success).

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.statusText)

    @property
    def headers(self) -&gt; typing.Dict[str, str]:
        &#34;&#34;&#34;Response.headers

        Returns
        -------
        Dict[str, str]
            An object with HTTP headers associated with the response. All header names are lower-case.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.headers)

    @property
    def request(self) -&gt; &#34;Request&#34;:
        &#34;&#34;&#34;Response.request

        Returns
        -------
        Request
            A matching Request object.
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.request)

    @property
    def frame(self) -&gt; &#34;Frame&#34;:
        &#34;&#34;&#34;Response.frame

        Returns
        -------
        Frame
            A Frame that initiated this response.
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.frame)

    def finished(self) -&gt; typing.Union[Error, NoneType]:
        &#34;&#34;&#34;Response.finished

        Returns
        -------
        Optional[Error]
            Waits for this response to finish, returns failure error if request failed.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.finished()))

    def body(self) -&gt; bytes:
        &#34;&#34;&#34;Response.body

        Returns
        -------
        bytes
            Promise which resolves to a buffer with response body.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.body()))

    def text(self) -&gt; str:
        &#34;&#34;&#34;Response.text

        Returns
        -------
        str
            Promise which resolves to a text representation of response body.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.text()))

    def json(self) -&gt; typing.Union[typing.Dict, typing.List]:
        &#34;&#34;&#34;Response.json

        This method will throw if the response body is not parsable via `JSON.parse`.

        Returns
        -------
        Union[Dict, List]
            Promise which resolves to a JSON representation of response body.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.json()))


mapping.register(ResponseImpl, Response)


class Route(SyncBase):
    def __init__(self, obj: RouteImpl):
        super().__init__(obj)

    @property
    def request(self) -&gt; &#34;Request&#34;:
        &#34;&#34;&#34;Route.request

        Returns
        -------
        Request
            A request to be routed.
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.request)

    def abort(self, errorCode: str = None) -&gt; NoneType:
        &#34;&#34;&#34;Route.abort

        Aborts the route&#39;s request.

        Parameters
        ----------
        errorCode : Optional[str]
            Optional error code. Defaults to `failed`, could be
            one of the following:
             - `&#39;aborted&#39;` - An operation was aborted (due to user action)
             - `&#39;accessdenied&#39;` - Permission to access a resource, other than the network, was denied
             - `&#39;addressunreachable&#39;` - The IP address is unreachable. This usually means
             - that there is no route to the specified host or network.
             - `&#39;blockedbyclient&#39;` - The client chose to block the request.
             - `&#39;blockedbyresponse&#39;` - The request failed because the response was delivered along with requirements which are not met (&#39;X-Frame-Options&#39; and &#39;Content-Security-Policy&#39; ancestor checks, for instance).
             - `&#39;connectionaborted&#39;` - A connection timed out as a result of not receiving an ACK for data sent.
             - `&#39;connectionclosed&#39;` - A connection was closed (corresponding to a TCP FIN).
             - `&#39;connectionfailed&#39;` - A connection attempt failed.
             - `&#39;connectionrefused&#39;` - A connection attempt was refused.
             - `&#39;connectionreset&#39;` - A connection was reset (corresponding to a TCP RST).
             - `&#39;internetdisconnected&#39;` - The Internet connection has been lost.
             - `&#39;namenotresolved&#39;` - The host name could not be resolved.
             - `&#39;timedout&#39;` - An operation timed out.
             - `&#39;failed&#39;` - A generic failure occurred.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.abort(errorCode=errorCode))
        )

    def fulfill(
        self,
        status: int = None,
        headers: typing.Union[typing.Dict[str, str]] = None,
        body: typing.Union[str, bytes] = None,
        path: typing.Union[str, pathlib.Path] = None,
        contentType: str = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Route.fulfill

        Fulfills route&#39;s request with given response.
        An example of fulfilling all requests with 404 responses:
        An example of serving static file:

        Parameters
        ----------
        status : Optional[int]
            Response status code, defaults to `200`.
        headers : Optional[Dict[str, str]]
            Optional response headers. Header values will be converted to a string.
        body : Union[str, bytes, NoneType]
            Optional response body.
        path : Union[str, pathlib.Path, NoneType]
            Optional file path to respond with. The content type will be inferred from file extension. If `path` is a relative path, then it is resolved relative to current working directory.
        contentType : Optional[str]
            If set, equals to setting `Content-Type` response header.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.fulfill(
                    status=status,
                    headers=mapping.to_impl(headers),
                    body=body,
                    path=path,
                    contentType=contentType,
                )
            )
        )

    def continue_(
        self,
        url: str = None,
        method: str = None,
        headers: typing.Union[typing.Dict[str, str]] = None,
        postData: typing.Union[str, bytes] = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Route.continue_

        Continues route&#39;s request with optional overrides.

        Parameters
        ----------
        url : Optional[str]
            If set changes the request URL. New URL must have same protocol as original one.
        method : Optional[str]
            If set changes the request method (e.g. GET or POST)
        headers : Optional[Dict[str, str]]
            If set changes the request HTTP headers. Header values will be converted to a string.
        postData : Union[str, bytes, NoneType]
            If set changes the post data of request
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.continue_(
                    url=url,
                    method=method,
                    headers=mapping.to_impl(headers),
                    postData=postData,
                )
            )
        )


mapping.register(RouteImpl, Route)


class WebSocket(SyncBase):
    def __init__(self, obj: WebSocketImpl):
        super().__init__(obj)

    @property
    def url(self) -&gt; str:
        &#34;&#34;&#34;WebSocket.url

        Contains the URL of the WebSocket.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.url)

    def waitForEvent(
        self,
        event: str,
        predicate: typing.Union[typing.Callable[[typing.Any], bool]] = None,
        timeout: int = None,
    ) -&gt; typing.Any:
        &#34;&#34;&#34;WebSocket.waitForEvent

        Waits for event to fire and passes its value into the predicate function. Resolves when the predicate returns truthy value. Will throw an error if the webSocket is closed before the event
        is fired.

        Parameters
        ----------
        event : str
            Event name, same one would pass into `webSocket.on(event)`.

        Returns
        -------
        Any
            Promise which resolves to the event data value.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.waitForEvent(
                    event=event,
                    predicate=self._wrap_handler(predicate),
                    timeout=timeout,
                )
            )
        )

    def expect_event(
        self,
        event: str,
        predicate: typing.Union[typing.Callable[[typing.Any], bool]] = None,
        timeout: int = None,
    ) -&gt; EventContextManager:
        return EventContextManager(
            self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
        )

    def isClosed(self) -&gt; bool:
        &#34;&#34;&#34;WebSocket.isClosed

        Indicates that the web socket has been closed.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.isClosed())


mapping.register(WebSocketImpl, WebSocket)


class Keyboard(SyncBase):
    def __init__(self, obj: KeyboardImpl):
        super().__init__(obj)

    def down(self, key: str) -&gt; NoneType:
        &#34;&#34;&#34;Keyboard.down

        Dispatches a `keydown` event.
        `key` can specify the intended keyboardEvent.key value or a single character to generate the text for. A superset of the `key` values can be found here. Examples of the keys are:
        `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`, `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.
        Following modification shortcuts are also suported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`.
        Holding down `Shift` will type the text that corresponds to the `key` in the upper case.
        If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective texts.
        If `key` is a modifier key, `Shift`, `Meta`, `Control`, or `Alt`, subsequent key presses will be sent with that modifier active. To release the modifier key, use `keyboard.up`.
        After the key is pressed once, subsequent calls to `keyboard.down` will have repeat set to true. To release the key, use `keyboard.up`.

        **NOTE** Modifier keys DO influence `keyboard.down`. Holding down `Shift` will type the text in upper case.

        Parameters
        ----------
        key : str
            Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.down(key=key)))

    def up(self, key: str) -&gt; NoneType:
        &#34;&#34;&#34;Keyboard.up

        Dispatches a `keyup` event.

        Parameters
        ----------
        key : str
            Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.up(key=key)))

    def insertText(self, text: str) -&gt; NoneType:
        &#34;&#34;&#34;Keyboard.insertText

        Dispatches only `input` event, does not emit the `keydown`, `keyup` or `keypress` events.

        **NOTE** Modifier keys DO NOT effect `keyboard.insertText`. Holding down `Shift` will not type the text in upper case.

        Parameters
        ----------
        text : str
            Sets input to the specified text value.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.insertText(text=text)))

    def type(self, text: str, delay: int = None) -&gt; NoneType:
        &#34;&#34;&#34;Keyboard.type

        Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text.
        To press a special key, like `Control` or `ArrowDown`, use `keyboard.press`.

        **NOTE** Modifier keys DO NOT effect `keyboard.type`. Holding down `Shift` will not type the text in upper case.

        Parameters
        ----------
        text : str
            A text to type into a focused element.
        delay : Optional[int]
            Time to wait between key presses in milliseconds. Defaults to 0.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.type(text=text, delay=delay))
        )

    def press(self, key: str, delay: int = None) -&gt; NoneType:
        &#34;&#34;&#34;Keyboard.press

        `key` can specify the intended keyboardEvent.key value or a single character to generate the text for. A superset of the `key` values can be found here. Examples of the keys are:
        `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`, `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.
        Following modification shortcuts are also suported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`.
        Holding down `Shift` will type the text that corresponds to the `key` in the upper case.
        If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective texts.
        Shortcuts such as `key: &#34;Control+o&#34;` or `key: &#34;Control+Shift+T&#34;` are supported as well. When speficied with the modifier, modifier is pressed and being held while the subsequent key is being pressed.
        Shortcut for `keyboard.down` and `keyboard.up`.

        Parameters
        ----------
        key : str
            Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
        delay : Optional[int]
            Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.press(key=key, delay=delay))
        )


mapping.register(KeyboardImpl, Keyboard)


class Mouse(SyncBase):
    def __init__(self, obj: MouseImpl):
        super().__init__(obj)

    def move(self, x: float, y: float, steps: int = None) -&gt; NoneType:
        &#34;&#34;&#34;Mouse.move

        Dispatches a `mousemove` event.

        Parameters
        ----------
        x : float
        y : float
        steps : Optional[int]
            defaults to 1. Sends intermediate `mousemove` events.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.move(x=x, y=y, steps=steps))
        )

    def down(
        self, button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None, clickCount: int = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;Mouse.down

        Dispatches a `mousedown` event.

        Parameters
        ----------
        button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
            Defaults to `left`.
        clickCount : Optional[int]
            defaults to 1. See UIEvent.detail.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.down(button=button, clickCount=clickCount))
        )

    def up(
        self, button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None, clickCount: int = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;Mouse.up

        Dispatches a `mouseup` event.

        Parameters
        ----------
        button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
            Defaults to `left`.
        clickCount : Optional[int]
            defaults to 1. See UIEvent.detail.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.up(button=button, clickCount=clickCount))
        )

    def click(
        self,
        x: float,
        y: float,
        delay: int = None,
        button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
        clickCount: int = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Mouse.click

        Shortcut for `mouse.move`, `mouse.down` and `mouse.up`.

        Parameters
        ----------
        x : float
        y : float
        delay : Optional[int]
            Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
        button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
            Defaults to `left`.
        clickCount : Optional[int]
            defaults to 1. See UIEvent.detail.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.click(
                    x=x, y=y, delay=delay, button=button, clickCount=clickCount
                )
            )
        )

    def dblclick(
        self,
        x: float,
        y: float,
        delay: int = None,
        button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Mouse.dblclick

        Shortcut for `mouse.move`, `mouse.down`, `mouse.up`, `mouse.down` and `mouse.up`.

        Parameters
        ----------
        x : float
        y : float
        delay : Optional[int]
            Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
        button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
            Defaults to `left`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.dblclick(x=x, y=y, delay=delay, button=button))
        )


mapping.register(MouseImpl, Mouse)


class Touchscreen(SyncBase):
    def __init__(self, obj: TouchscreenImpl):
        super().__init__(obj)

    def tap(self, x: float, y: float) -&gt; NoneType:
        &#34;&#34;&#34;Touchscreen.tap

        Dispatches a `touchstart` and `touchend` event with a single touch at the position (`x`,`y`).

        Parameters
        ----------
        x : float
        y : float
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.tap(x=x, y=y)))


mapping.register(TouchscreenImpl, Touchscreen)


class JSHandle(SyncBase):
    def __init__(self, obj: JSHandleImpl):
        super().__init__(obj)

    def evaluate(
        self, expression: str, arg: typing.Any = None, force_expr: bool = None
    ) -&gt; typing.Any:
        &#34;&#34;&#34;JSHandle.evaluate

        This method passes this handle as the first argument to `pageFunction`.
        If `pageFunction` returns a Promise, then `handle.evaluate` would wait for the promise to resolve and return its value.
        Examples:

        Parameters
        ----------
        expression : str
            Function to be evaluated in browser context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        Any
            Promise which resolves to the return value of `pageFunction`
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.evaluate(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )

    def evaluateHandle(
        self, expression: str, arg: typing.Any = None, force_expr: bool = None
    ) -&gt; &#34;JSHandle&#34;:
        &#34;&#34;&#34;JSHandle.evaluateHandle

        This method passes this handle as the first argument to `pageFunction`.
        The only difference between `jsHandle.evaluate` and `jsHandle.evaluateHandle` is that `jsHandle.evaluateHandle` returns in-page object (JSHandle).
        If the function passed to the `jsHandle.evaluateHandle` returns a Promise, then `jsHandle.evaluateHandle` would wait for the promise to resolve and return its value.
        See page.evaluateHandle() for more details.

        Parameters
        ----------
        expression : str
            Function to be evaluated
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        JSHandle
            Promise which resolves to the return value of `pageFunction` as in-page object (JSHandle)
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.evaluateHandle(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )

    def getProperty(self, propertyName: str) -&gt; &#34;JSHandle&#34;:
        &#34;&#34;&#34;JSHandle.getProperty

        Fetches a single property from the referenced object.

        Parameters
        ----------
        propertyName : str
            property to get

        Returns
        -------
        JSHandle
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(self._impl_obj.getProperty(propertyName=propertyName))
        )

    def getProperties(self) -&gt; typing.Dict[str, &#34;JSHandle&#34;]:
        &#34;&#34;&#34;JSHandle.getProperties

        The method returns a map with **own property names** as keys and JSHandle instances for the property values.

        Returns
        -------
        Dict[str, JSHandle]
        &#34;&#34;&#34;
        return mapping.from_impl_dict(self._sync(self._impl_obj.getProperties()))

    def asElement(self) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
        &#34;&#34;&#34;JSHandle.asElement

        Returns either `null` or the object handle itself, if the object handle is an instance of ElementHandle.

        Returns
        -------
        Optional[ElementHandle]
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._impl_obj.asElement())

    def dispose(self) -&gt; NoneType:
        &#34;&#34;&#34;JSHandle.dispose

        The `jsHandle.dispose` method stops referencing the element handle.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.dispose()))

    def jsonValue(self) -&gt; typing.Any:
        &#34;&#34;&#34;JSHandle.jsonValue

        Returns a JSON representation of the object. If the object has a
        `toJSON`
        function, it **will not be called**.

        **NOTE** The method will return an empty JSON object if the referenced object is not stringifiable. It will throw an error if the object has circular references.

        Returns
        -------
        Any
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.jsonValue()))


mapping.register(JSHandleImpl, JSHandle)


class ElementHandle(JSHandle):
    def __init__(self, obj: ElementHandleImpl):
        super().__init__(obj)

    def toString(self) -&gt; str:
        &#34;&#34;&#34;ElementHandle.toString

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.toString())

    def asElement(self) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
        &#34;&#34;&#34;ElementHandle.asElement

        Returns either `null` or the object handle itself, if the object handle is an instance of ElementHandle.

        Returns
        -------
        Optional[ElementHandle]
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._impl_obj.asElement())

    def ownerFrame(self) -&gt; typing.Union[&#34;Frame&#34;, NoneType]:
        &#34;&#34;&#34;ElementHandle.ownerFrame

        Returns
        -------
        Optional[Frame]
            Returns the frame containing the given element.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._sync(self._impl_obj.ownerFrame()))

    def contentFrame(self) -&gt; typing.Union[&#34;Frame&#34;, NoneType]:
        &#34;&#34;&#34;ElementHandle.contentFrame

        Returns
        -------
        Optional[Frame]
            Resolves to the content frame for element handles referencing iframe nodes, or `null` otherwise
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._sync(self._impl_obj.contentFrame()))

    def getAttribute(self, name: str) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;ElementHandle.getAttribute

        Returns element attribute value.

        Parameters
        ----------
        name : str
            Attribute name to get the value for.

        Returns
        -------
        Optional[str]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.getAttribute(name=name))
        )

    def textContent(self) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;ElementHandle.textContent

        Returns
        -------
        Optional[str]
            Resolves to the `node.textContent`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.textContent()))

    def innerText(self) -&gt; str:
        &#34;&#34;&#34;ElementHandle.innerText

        Returns
        -------
        str
            Resolves to the `element.innerText`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.innerText()))

    def innerHTML(self) -&gt; str:
        &#34;&#34;&#34;ElementHandle.innerHTML

        Returns
        -------
        str
            Resolves to the `element.innerHTML`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.innerHTML()))

    def dispatchEvent(self, type: str, eventInit: typing.Dict = None) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.dispatchEvent

        The snippet below dispatches the `click` event on the element. Regardless of the visibility state of the elment, `click` is dispatched. This is equivalend to calling `element.click()`.
        Under the hood, it creates an instance of an event based on the given `type`, initializes it with `eventInit` properties and dispatches it on the element. Events are `composed`, `cancelable` and bubble by default.
        Since `eventInit` is event-specific, please refer to the events documentation for the lists of initial properties:

        DragEvent
        FocusEvent
        KeyboardEvent
        MouseEvent
        PointerEvent
        TouchEvent
        Event

        You can also specify `JSHandle` as the property value if you want live objects to be passed into the event:

        Parameters
        ----------
        type : str
            DOM event type: `&#34;click&#34;`, `&#34;dragstart&#34;`, etc.
        eventInit : Optional[Dict]
            event-specific initialization properties.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.dispatchEvent(
                    type=type, eventInit=mapping.to_impl(eventInit)
                )
            )
        )

    def scrollIntoViewIfNeeded(self, timeout: int = None) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.scrollIntoViewIfNeeded

        This method waits for actionability checks, then tries to scroll element into view, unless it is completely visible as defined by IntersectionObserver&#39;s `ratio`.
        Throws when `elementHandle` does not point to an element connected to a Document or a ShadowRoot.

        Parameters
        ----------
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.scrollIntoViewIfNeeded(timeout=timeout))
        )

    def hover(
        self,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: MousePosition = None,
        timeout: int = None,
        force: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.hover

        This method hovers over the element by performing the following steps:

        Wait for actionability checks on the element, unless `force` option is set.
        Scroll the element into view if needed.
        Use page.mouse to hover over the center of the element, or the specified `position`.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

        If the element is detached from the DOM at any moment during the action, this method rejects.
        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        Parameters
        ----------
        modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
            Modifier keys to press. Ensures that only these modifiers are pressed during the hover, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
        position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
            A point to hover relative to the top-left corner of element padding box. If not specified, hovers over some visible point of the element.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.hover(
                    modifiers=modifiers, position=position, timeout=timeout, force=force
                )
            )
        )

    def click(
        self,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: MousePosition = None,
        delay: int = None,
        button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
        clickCount: int = None,
        timeout: int = None,
        force: bool = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.click

        This method clicks the element by performing the following steps:

        Wait for actionability checks on the element, unless `force` option is set.
        Scroll the element into view if needed.
        Use page.mouse to click in the center of the element, or the specified `position`.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

        If the element is detached from the DOM at any moment during the action, this method rejects.
        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        Parameters
        ----------
        modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
            Modifier keys to press. Ensures that only these modifiers are pressed during the click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
        position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
            A point to click relative to the top-left corner of element padding box. If not specified, clicks to some visible point of the element.
        delay : Optional[int]
            Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
        button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
            Defaults to `left`.
        clickCount : Optional[int]
            defaults to 1. See UIEvent.detail.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.click(
                    modifiers=modifiers,
                    position=position,
                    delay=delay,
                    button=button,
                    clickCount=clickCount,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def dblclick(
        self,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: MousePosition = None,
        delay: int = None,
        button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
        timeout: int = None,
        force: bool = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.dblclick

        This method double clicks the element by performing the following steps:

        Wait for actionability checks on the element, unless `force` option is set.
        Scroll the element into view if needed.
        Use page.mouse to double click in the center of the element, or the specified `position`.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set. Note that if the first click of the `dblclick()` triggers a navigation event, this method will reject.

        If the element is detached from the DOM at any moment during the action, this method rejects.
        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        **NOTE** `elementHandle.dblclick()` dispatches two `click` events and a single `dblclick` event.

        Parameters
        ----------
        modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
            Modifier keys to press. Ensures that only these modifiers are pressed during the double click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
        position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
            A point to double click relative to the top-left corner of element padding box. If not specified, double clicks to some visible point of the element.
        delay : Optional[int]
            Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
        button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
            Defaults to `left`.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.dblclick(
                    modifiers=modifiers,
                    position=position,
                    delay=delay,
                    button=button,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def selectOption(
        self,
        values: typing.Union[
            str,
            &#34;ElementHandle&#34;,
            SelectOption,
            typing.List[str],
            typing.List[&#34;ElementHandle&#34;],
            typing.List[SelectOption],
        ] = None,
        timeout: int = None,
        noWaitAfter: bool = None,
    ) -&gt; typing.List[str]:
        &#34;&#34;&#34;ElementHandle.selectOption

        Triggers a `change` and `input` event once all the provided options have been selected.
        If element is not a `&lt;select&gt;` element, the method throws an error.

        Parameters
        ----------
        values : Union[str, ElementHandle, {&#34;value&#34;: Optional[str], &#34;label&#34;: Optional[str], &#34;index&#34;: Optional[str]}, List[str], List[ElementHandle], List[{&#34;value&#34;: Optional[str], &#34;label&#34;: Optional[str], &#34;index&#34;: Optional[str]}], NoneType]
            Options to select. If the `&lt;select&gt;` has the `multiple` attribute, all matching options are selected, otherwise only the first option matching one of the passed options is selected. String values are equivalent to `{value:&#39;string&#39;}`. Option is considered matching if all specified properties match.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.

        Returns
        -------
        List[str]
            An array of option values that have been successfully selected.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.selectOption(
                    values=mapping.to_impl(values),
                    timeout=timeout,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def tap(
        self,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: MousePosition = None,
        timeout: int = None,
        force: bool = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.tap

        This method taps the element by performing the following steps:

        Wait for actionability checks on the element, unless `force` option is set.
        Scroll the element into view if needed.
        Use page.touchscreen to tap in the center of the element, or the specified `position`.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

        If the element is detached from the DOM at any moment during the action, this method rejects.
        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        **NOTE** `elementHandle.tap()` requires that the `hasTouch` option of the browser context be set to true.

        Parameters
        ----------
        modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
            Modifier keys to press. Ensures that only these modifiers are pressed during the tap, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
        position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
            A point to tap relative to the top-left corner of element padding box. If not specified, taps some visible point of the element.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.tap(
                    modifiers=modifiers,
                    position=position,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def fill(
        self, value: str, timeout: int = None, noWaitAfter: bool = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.fill

        This method waits for actionability checks, focuses the element, fills it and triggers an `input` event after filling.
        If the element is not an `&lt;input&gt;`, `&lt;textarea&gt;` or `[contenteditable]` element, this method throws an error.
        Note that you can pass an empty string to clear the input field.

        Parameters
        ----------
        value : str
            Value to set for the `&lt;input&gt;`, `&lt;textarea&gt;` or `[contenteditable]` element.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.fill(
                    value=value, timeout=timeout, noWaitAfter=noWaitAfter
                )
            )
        )

    def selectText(self, timeout: int = None) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.selectText

        This method waits for actionability checks, then focuses the element and selects all its text content.

        Parameters
        ----------
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.selectText(timeout=timeout))
        )

    def setInputFiles(
        self,
        files: typing.Union[
            str,
            pathlib.Path,
            FilePayload,
            typing.List[str],
            typing.List[pathlib.Path],
            typing.List[FilePayload],
        ],
        timeout: int = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.setInputFiles

        This method expects `elementHandle` to point to an input element.
        Sets the value of the file input to these file paths or files. If some of the `filePaths` are relative paths, then they are resolved relative to the current working directory. For empty array, clears the selected files.

        Parameters
        ----------
        files : Union[str, pathlib.Path, {&#34;name&#34;: str, &#34;mimeType&#34;: str, &#34;buffer&#34;: bytes}, List[str], List[pathlib.Path], List[{&#34;name&#34;: str, &#34;mimeType&#34;: str, &#34;buffer&#34;: bytes}]]
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.setInputFiles(
                    files=files, timeout=timeout, noWaitAfter=noWaitAfter
                )
            )
        )

    def focus(self) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.focus

        Calls focus on the element.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.focus()))

    def type(
        self,
        text: str,
        delay: int = None,
        timeout: int = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.type

        Focuses the element, and then sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text.
        To press a special key, like `Control` or `ArrowDown`, use `elementHandle.press`.
        An example of typing into a text field and then submitting the form:

        Parameters
        ----------
        text : str
            A text to type into a focused element.
        delay : Optional[int]
            Time to wait between key presses in milliseconds. Defaults to 0.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.type(
                    text=text, delay=delay, timeout=timeout, noWaitAfter=noWaitAfter
                )
            )
        )

    def press(
        self, key: str, delay: int = None, timeout: int = None, noWaitAfter: bool = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.press

        Focuses the element, and then uses `keyboard.down` and `keyboard.up`.
        `key` can specify the intended keyboardEvent.key value or a single character to generate the text for. A superset of the `key` values can be found here. Examples of the keys are:
        `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`, `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.
        Following modification shortcuts are also suported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`.
        Holding down `Shift` will type the text that corresponds to the `key` in the upper case.
        If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective texts.
        Shortcuts such as `key: &#34;Control+o&#34;` or `key: &#34;Control+Shift+T&#34;` are supported as well. When speficied with the modifier, modifier is pressed and being held while the subsequent key is being pressed.

        Parameters
        ----------
        key : str
            Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
        delay : Optional[int]
            Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.press(
                    key=key, delay=delay, timeout=timeout, noWaitAfter=noWaitAfter
                )
            )
        )

    def check(
        self, timeout: int = None, force: bool = None, noWaitAfter: bool = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.check

        This method checks the element by performing the following steps:

        Ensure that element is a checkbox or a radio input. If not, this method rejects. If the element is already checked, this method returns immediately.
        Wait for actionability checks on the element, unless `force` option is set.
        Scroll the element into view if needed.
        Use page.mouse to click in the center of the element.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
        Ensure that the element is now checked. If not, this method rejects.

        If the element is detached from the DOM at any moment during the action, this method rejects.
        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        Parameters
        ----------
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.check(
                    timeout=timeout, force=force, noWaitAfter=noWaitAfter
                )
            )
        )

    def uncheck(
        self, timeout: int = None, force: bool = None, noWaitAfter: bool = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.uncheck

        This method checks the element by performing the following steps:

        Ensure that element is a checkbox or a radio input. If not, this method rejects. If the element is already unchecked, this method returns immediately.
        Wait for actionability checks on the element, unless `force` option is set.
        Scroll the element into view if needed.
        Use page.mouse to click in the center of the element.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
        Ensure that the element is now unchecked. If not, this method rejects.

        If the element is detached from the DOM at any moment during the action, this method rejects.
        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        Parameters
        ----------
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.uncheck(
                    timeout=timeout, force=force, noWaitAfter=noWaitAfter
                )
            )
        )

    def boundingBox(self) -&gt; typing.Union[FloatRect, NoneType]:
        &#34;&#34;&#34;ElementHandle.boundingBox

        This method returns the bounding box of the element (relative to the main frame), or `null` if the element is not visible.

        Returns
        -------
        Optional[{&#34;x&#34;: float, &#34;y&#34;: float, &#34;width&#34;: float, &#34;height&#34;: float}]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.boundingBox()))

    def screenshot(
        self,
        timeout: int = None,
        type: Literal[&#34;jpeg&#34;, &#34;png&#34;] = None,
        path: typing.Union[str, pathlib.Path] = None,
        quality: int = None,
        omitBackground: bool = None,
    ) -&gt; bytes:
        &#34;&#34;&#34;ElementHandle.screenshot

        This method waits for the actionability checks, then scrolls element into view before taking a screenshot. If the element is detached from DOM, the method throws an error.

        Parameters
        ----------
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        type : Optional[Literal[&#39;jpeg&#39;, &#39;png&#39;]]
            Specify screenshot type, defaults to `png`.
        path : Union[str, pathlib.Path, NoneType]
            The file path to save the image to. The screenshot type will be inferred from file extension. If `path` is a relative path, then it is resolved relative to current working directory. If no path is provided, the image won&#39;t be saved to the disk.
        quality : Optional[int]
            The quality of the image, between 0-100. Not applicable to `png` images.
        omitBackground : Optional[bool]
            Hides default white background and allows capturing screenshots with transparency. Not applicable to `jpeg` images. Defaults to `false`.

        Returns
        -------
        bytes
            Promise which resolves to buffer with the captured screenshot.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.screenshot(
                    timeout=timeout,
                    type=type,
                    path=path,
                    quality=quality,
                    omitBackground=omitBackground,
                )
            )
        )

    def querySelector(self, selector: str) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
        &#34;&#34;&#34;ElementHandle.querySelector

        The method finds an element matching the specified selector in the `ElementHandle`&#39;s subtree. See Working with selectors for more details. If no elements match the selector, the return value resolves to `null`.

        Parameters
        ----------
        selector : str
            A selector to query element for. See working with selectors for more details.

        Returns
        -------
        Optional[ElementHandle]
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._sync(self._impl_obj.querySelector(selector=selector))
        )

    def querySelectorAll(self, selector: str) -&gt; typing.List[&#34;ElementHandle&#34;]:
        &#34;&#34;&#34;ElementHandle.querySelectorAll

        The method finds all elements matching the specified selector in the `ElementHandle`s subtree. See Working with selectors for more details. If no elements match the selector, the return value resolves to `[]`.

        Parameters
        ----------
        selector : str
            A selector to query element for. See working with selectors for more details.

        Returns
        -------
        List[ElementHandle]
        &#34;&#34;&#34;
        return mapping.from_impl_list(
            self._sync(self._impl_obj.querySelectorAll(selector=selector))
        )

    def evalOnSelector(
        self,
        selector: str,
        expression: str,
        arg: typing.Any = None,
        force_expr: bool = None,
    ) -&gt; typing.Any:
        &#34;&#34;&#34;ElementHandle.evalOnSelector

        The method finds an element matching the specified selector in the `ElementHandle`s subtree and passes it as a first argument to `pageFunction`. See Working with selectors for more details. If no elements match the selector, the method throws an error.
        If `pageFunction` returns a Promise, then `frame.$eval` would wait for the promise to resolve and return its value.
        Examples:

        Parameters
        ----------
        selector : str
            A selector to query element for. See working with selectors for more details.
        expression : str
            Function to be evaluated in browser context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        Any
            Promise which resolves to the return value of `pageFunction`
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.evalOnSelector(
                    selector=selector,
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )

    def evalOnSelectorAll(
        self,
        selector: str,
        expression: str,
        arg: typing.Any = None,
        force_expr: bool = None,
    ) -&gt; typing.Any:
        &#34;&#34;&#34;ElementHandle.evalOnSelectorAll

        The method finds all elements matching the specified selector in the `ElementHandle`&#39;s subtree and passes an array of matched elements as a first argument to `pageFunction`. See Working with selectors for more details.
        If `pageFunction` returns a Promise, then `frame.$$eval` would wait for the promise to resolve and return its value.
        Examples:
        ```html
        &lt;div class=&#34;feed&#34;&gt;
          &lt;div class=&#34;tweet&#34;&gt;Hello!&lt;/div&gt;
          &lt;div class=&#34;tweet&#34;&gt;Hi!&lt;/div&gt;
        &lt;/div&gt;
        ```

        Parameters
        ----------
        selector : str
            A selector to query element for. See working with selectors for more details.
        expression : str
            Function to be evaluated in browser context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        Any
            Promise which resolves to the return value of `pageFunction`
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.evalOnSelectorAll(
                    selector=selector,
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )

    def waitForElementState(
        self,
        state: Literal[&#34;disabled&#34;, &#34;enabled&#34;, &#34;hidden&#34;, &#34;stable&#34;, &#34;visible&#34;],
        timeout: int = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.waitForElementState

        Depending on the `state` parameter, this method waits for one of the actionability checks to pass. This method throws when the element is detached while waiting, unless waiting for the `&#34;hidden&#34;` state.

        `&#34;visible&#34;` Wait until the element is visible.
        `&#34;hidden&#34;` Wait until the element is not visible or not attached. Note that waiting for hidden does not throw when the element detaches.
        `&#34;stable&#34;` Wait until the element is both visible and stable.
        `&#34;enabled&#34;` Wait until the element is enabled.
        `&#34;disabled&#34;` Wait until the element is not enabled.

        If the element does not satisfy the condition for the `timeout` milliseconds, this method will throw.

        Parameters
        ----------
        state : Literal[&#39;disabled&#39;, &#39;enabled&#39;, &#39;hidden&#39;, &#39;stable&#39;, &#39;visible&#39;]
            A state to wait for, see below for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.waitForElementState(state=state, timeout=timeout))
        )

    def waitForSelector(
        self,
        selector: str,
        state: Literal[&#34;attached&#34;, &#34;detached&#34;, &#34;hidden&#34;, &#34;visible&#34;] = None,
        timeout: int = None,
    ) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
        &#34;&#34;&#34;ElementHandle.waitForSelector

        Wait for the `selector` relative to the element handle to satisfy `state` option (either appear/disappear from dom, or become visible/hidden). If at the moment of calling the method `selector` already satisfies the condition, the method will return immediately. If the selector doesn&#39;t satisfy the condition for the `timeout` milliseconds, the function will throw.

        **NOTE** This method does not work across navigations, use page.waitForSelector(selector[, options]) instead.

        Parameters
        ----------
        selector : str
            A selector of an element to wait for, relative to the element handle. See working with selectors for more details.
        state : Optional[Literal[&#39;attached&#39;, &#39;detached&#39;, &#39;hidden&#39;, &#39;visible&#39;]]
            Defaults to `&#39;visible&#39;`. Can be either:
             - `&#39;attached&#39;` - wait for element to be present in DOM.
             - `&#39;detached&#39;` - wait for element to not be present in DOM.
             - `&#39;visible&#39;` - wait for element to have non-empty bounding box and no `visibility:hidden`. Note that element without any content or with `display:none` has an empty bounding box and is not considered visible.
             - `&#39;hidden&#39;` - wait for element to be either detached from DOM, or have an empty bounding box or `visibility:hidden`. This is opposite to the `&#39;visible&#39;` option.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

        Returns
        -------
        Optional[ElementHandle]
            Promise that resolves when element specified by selector satisfies `state` option. Resolves to `null` if waiting for `hidden` or `detached`.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._sync(
                self._impl_obj.waitForSelector(
                    selector=selector, state=state, timeout=timeout
                )
            )
        )


mapping.register(ElementHandleImpl, ElementHandle)


class Accessibility(SyncBase):
    def __init__(self, obj: AccessibilityImpl):
        super().__init__(obj)

    def snapshot(
        self, interestingOnly: bool = None, root: &#34;ElementHandle&#34; = None
    ) -&gt; typing.Union[typing.Dict, NoneType]:
        &#34;&#34;&#34;Accessibility.snapshot

        Captures the current state of the accessibility tree. The returned object represents the root accessible node of the page.

        **NOTE** The Chromium accessibility tree contains nodes that go unused on most platforms and by
        most screen readers. Playwright will discard them as well for an easier to process tree,
        unless `interestingOnly` is set to `false`.

        An example of dumping the entire accessibility tree:
        An example of logging the focused node&#39;s name:

        Parameters
        ----------
        interestingOnly : Optional[bool]
            Prune uninteresting nodes from the tree. Defaults to `true`.
        root : Optional[ElementHandle]
            The root DOM element for the snapshot. Defaults to the whole page.

        Returns
        -------
        Optional[Dict]
            An AXNode object with the following properties:
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.snapshot(
                    interestingOnly=interestingOnly, root=mapping.to_impl(root)
                )
            )
        )


mapping.register(AccessibilityImpl, Accessibility)


class FileChooser(SyncBase):
    def __init__(self, obj: FileChooserImpl):
        super().__init__(obj)

    @property
    def page(self) -&gt; &#34;Page&#34;:
        &#34;&#34;&#34;FileChooser.page

        Returns page this file chooser belongs to.

        Returns
        -------
        Page
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.page)

    @property
    def element(self) -&gt; &#34;ElementHandle&#34;:
        &#34;&#34;&#34;FileChooser.element

        Returns input element associated with this file chooser.

        Returns
        -------
        ElementHandle
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.element)

    @property
    def isMultiple(self) -&gt; bool:
        &#34;&#34;&#34;FileChooser.isMultiple

        Returns whether this file chooser accepts multiple files.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.isMultiple)

    def setFiles(
        self,
        files: typing.Union[
            str, FilePayload, typing.List[str], typing.List[FilePayload]
        ],
        timeout: int = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;FileChooser.setFiles

        Sets the value of the file input this chooser is associated with. If some of the `filePaths` are relative paths, then they are resolved relative to the current working directory. For empty array, clears the selected files.

        Parameters
        ----------
        files : Union[str, {&#34;name&#34;: str, &#34;mimeType&#34;: str, &#34;buffer&#34;: bytes}, List[str], List[{&#34;name&#34;: str, &#34;mimeType&#34;: str, &#34;buffer&#34;: bytes}]]
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.setFiles(
                    files=files, timeout=timeout, noWaitAfter=noWaitAfter
                )
            )
        )


mapping.register(FileChooserImpl, FileChooser)


class Frame(SyncBase):
    def __init__(self, obj: FrameImpl):
        super().__init__(obj)

    @property
    def page(self) -&gt; &#34;Page&#34;:
        &#34;&#34;&#34;Frame.page

        Returns the page containing this frame.

        Returns
        -------
        Page
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.page)

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Frame.name

        Returns frame&#39;s name attribute as specified in the tag.
        If the name is empty, returns the id attribute instead.

        **NOTE** This value is calculated once when the frame is created, and will not update if the attribute is changed later.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.name)

    @property
    def url(self) -&gt; str:
        &#34;&#34;&#34;Frame.url

        Returns frame&#39;s url.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.url)

    @property
    def parentFrame(self) -&gt; typing.Union[&#34;Frame&#34;, NoneType]:
        &#34;&#34;&#34;Frame.parentFrame

        Returns
        -------
        Optional[Frame]
            Parent frame, if any. Detached frames and main frames return `null`.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._impl_obj.parentFrame)

    @property
    def childFrames(self) -&gt; typing.List[&#34;Frame&#34;]:
        &#34;&#34;&#34;Frame.childFrames

        Returns
        -------
        List[Frame]
        &#34;&#34;&#34;
        return mapping.from_impl_list(self._impl_obj.childFrames)

    def goto(
        self,
        url: str,
        timeout: int = None,
        waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        referer: str = None,
    ) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
        &#34;&#34;&#34;Frame.goto

        `frame.goto` will throw an error if:

        there&#39;s an SSL error (e.g. in case of self-signed certificates).
        target URL is invalid.
        the `timeout` is exceeded during navigation.
        the remote server does not respond or is unreachable.
        the main resource failed to load.

        `frame.goto` will not throw an error when any valid HTTP status code is returned by the remote server, including 404 &#34;Not Found&#34; and 500 &#34;Internal Server Error&#34;.  The status code for such responses can be retrieved by calling response.status().

        **NOTE** `frame.goto` either throws an error or returns a main resource response. The only exceptions are navigation to `about:blank` or navigation to the same URL with a different hash, which would succeed and return `null`.

        **NOTE** Headless mode doesn&#39;t support navigation to a PDF document. See the upstream issue.

        Parameters
        ----------
        url : str
            URL to navigate frame to. The url should include scheme, e.g. `https://`.
        timeout : Optional[int]
            Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        waitUntil : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
            When to consider navigation succeeded, defaults to `load`. Events can be either:
             - `&#39;domcontentloaded&#39;` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
             - `&#39;load&#39;` - consider navigation to be finished when the `load` event is fired.
             - `&#39;networkidle&#39;` - consider navigation to be finished when there are no network connections for at least `500` ms.
        referer : Optional[str]
            Referer header value. If provided it will take preference over the referer header value set by page.setExtraHTTPHeaders().

        Returns
        -------
        Optional[Response]
            Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._sync(
                self._impl_obj.goto(
                    url=url, timeout=timeout, waitUntil=waitUntil, referer=referer
                )
            )
        )

    def waitForNavigation(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
        waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        timeout: int = None,
    ) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
        &#34;&#34;&#34;Frame.waitForNavigation

        This resolves when the frame navigates to a new URL. It is useful for when you run code
        which will indirectly cause the frame to navigate. Consider this example:
        **NOTE** Usage of the History API to change the URL is considered a navigation.

        Parameters
        ----------
        url : Union[str, Pattern, typing.Callable[[str], bool], NoneType]
            URL string, URL regex pattern or predicate receiving URL to match while waiting for the navigation.
        waitUntil : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
            When to consider navigation succeeded, defaults to `load`. Events can be either:
             - `&#39;domcontentloaded&#39;` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
             - `&#39;load&#39;` - consider navigation to be finished when the `load` event is fired.
             - `&#39;networkidle&#39;` - consider navigation to be finished when there are no network connections for at least `500` ms.
        timeout : Optional[int]
            Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

        Returns
        -------
        Optional[Response]
            Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect. In case of navigation to a different anchor or navigation due to History API usage, the navigation will resolve with `null`.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._sync(
                self._impl_obj.waitForNavigation(
                    url=self._wrap_handler(url), waitUntil=waitUntil, timeout=timeout
                )
            )
        )

    def waitForLoadState(
        self,
        state: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        timeout: int = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.waitForLoadState

        This resolves when the frame reaches a required load state, `load` by default. The navigation must have been committed when this method is called. If current document has already reached the required state, resolves immediately.

        Parameters
        ----------
        state : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
            Load state to wait for, defaults to `load`. If the state has been already reached while loading current document, the method resolves immediately.
             - `&#39;load&#39;` - wait for the `load` event to be fired.
             - `&#39;domcontentloaded&#39;` - wait for the `DOMContentLoaded` event to be fired.
             - `&#39;networkidle&#39;` - wait until there are no network connections for at least `500` ms.
        timeout : Optional[int]
            Maximum waiting time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.waitForLoadState(state=state, timeout=timeout))
        )

    def frameElement(self) -&gt; &#34;ElementHandle&#34;:
        &#34;&#34;&#34;Frame.frameElement

        This is an inverse of elementHandle.contentFrame(). Note that returned handle actually belongs to the parent frame.
        This method throws an error if the frame has been detached before `frameElement()` returns.

        Returns
        -------
        ElementHandle
            Promise that resolves with a `frame` or `iframe` element handle which corresponds to this frame.
        &#34;&#34;&#34;
        return mapping.from_impl(self._sync(self._impl_obj.frameElement()))

    def evaluate(
        self, expression: str, arg: typing.Any = None, force_expr: bool = None
    ) -&gt; typing.Any:
        &#34;&#34;&#34;Frame.evaluate

        If the function passed to the `frame.evaluate` returns a Promise, then `frame.evaluate` would wait for the promise to resolve and return its value.
        If the function passed to the `frame.evaluate` returns a non-Serializable value, then `frame.evaluate` resolves to `undefined`. DevTools Protocol also supports transferring some additional values that are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and bigint literals.
        A string can also be passed in instead of a function.
        ElementHandle instances can be passed as an argument to the `frame.evaluate`:

        Parameters
        ----------
        expression : str
            Function to be evaluated in browser context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        Any
            Promise which resolves to the return value of `pageFunction`
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.evaluate(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )

    def evaluateHandle(
        self, expression: str, arg: typing.Any = None, force_expr: bool = None
    ) -&gt; &#34;JSHandle&#34;:
        &#34;&#34;&#34;Frame.evaluateHandle

        The only difference between `frame.evaluate` and `frame.evaluateHandle` is that `frame.evaluateHandle` returns in-page object (JSHandle).
        If the function, passed to the `frame.evaluateHandle`, returns a Promise, then `frame.evaluateHandle` would wait for the promise to resolve and return its value.
        A string can also be passed in instead of a function.
        JSHandle instances can be passed as an argument to the `frame.evaluateHandle`:

        Parameters
        ----------
        expression : str
            Function to be evaluated in the page context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        JSHandle
            Promise which resolves to the return value of `pageFunction` as in-page object (JSHandle)
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.evaluateHandle(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )

    def querySelector(self, selector: str) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
        &#34;&#34;&#34;Frame.querySelector

        The method finds an element matching the specified selector within the frame. See Working with selectors for more details. If no elements match the selector, the return value resolves to `null`.

        Parameters
        ----------
        selector : str
            A selector to query frame for. See working with selectors for more details.

        Returns
        -------
        Optional[ElementHandle]
            Promise which resolves to ElementHandle pointing to the frame element.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._sync(self._impl_obj.querySelector(selector=selector))
        )

    def querySelectorAll(self, selector: str) -&gt; typing.List[&#34;ElementHandle&#34;]:
        &#34;&#34;&#34;Frame.querySelectorAll

        The method finds all elements matching the specified selector within the frame. See Working with selectors for more details. If no elements match the selector, the return value resolves to `[]`.

        Parameters
        ----------
        selector : str
            A selector to query frame for. See working with selectors for more details.

        Returns
        -------
        List[ElementHandle]
            Promise which resolves to ElementHandles pointing to the frame elements.
        &#34;&#34;&#34;
        return mapping.from_impl_list(
            self._sync(self._impl_obj.querySelectorAll(selector=selector))
        )

    def waitForSelector(
        self,
        selector: str,
        timeout: int = None,
        state: Literal[&#34;attached&#34;, &#34;detached&#34;, &#34;hidden&#34;, &#34;visible&#34;] = None,
    ) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
        &#34;&#34;&#34;Frame.waitForSelector

        Wait for the `selector` to satisfy `state` option (either appear/disappear from dom, or become visible/hidden). If at the moment of calling the method `selector` already satisfies the condition, the method will return immediately. If the selector doesn&#39;t satisfy the condition for the `timeout` milliseconds, the function will throw.
        This method works across navigations:

        Parameters
        ----------
        selector : str
            A selector of an element to wait for. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        state : Optional[Literal[&#39;attached&#39;, &#39;detached&#39;, &#39;hidden&#39;, &#39;visible&#39;]]
            Defaults to `&#39;visible&#39;`. Can be either:
             - `&#39;attached&#39;` - wait for element to be present in DOM.
             - `&#39;detached&#39;` - wait for element to not be present in DOM.
             - `&#39;visible&#39;` - wait for element to have non-empty bounding box and no `visibility:hidden`. Note that element without any content or with `display:none` has an empty bounding box and is not considered visible.
             - `&#39;hidden&#39;` - wait for element to be either detached from DOM, or have an empty bounding box or `visibility:hidden`. This is opposite to the `&#39;visible&#39;` option.

        Returns
        -------
        Optional[ElementHandle]
            Promise which resolves when element specified by selector satisfies `state` option. Resolves to `null` if waiting for `hidden` or `detached`.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._sync(
                self._impl_obj.waitForSelector(
                    selector=selector, timeout=timeout, state=state
                )
            )
        )

    def dispatchEvent(
        self,
        selector: str,
        type: str,
        eventInit: typing.Dict = None,
        timeout: int = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.dispatchEvent

        The snippet below dispatches the `click` event on the element. Regardless of the visibility state of the elment, `click` is dispatched. This is equivalend to calling `element.click()`.
        Under the hood, it creates an instance of an event based on the given `type`, initializes it with `eventInit` properties and dispatches it on the element. Events are `composed`, `cancelable` and bubble by default.
        Since `eventInit` is event-specific, please refer to the events documentation for the lists of initial properties:

        DragEvent
        FocusEvent
        KeyboardEvent
        MouseEvent
        PointerEvent
        TouchEvent
        Event

        You can also specify `JSHandle` as the property value if you want live objects to be passed into the event:

        Parameters
        ----------
        selector : str
            A selector to search for element to use. If there are multiple elements satisfying the selector, the first will be double clicked. See working with selectors for more details.
        type : str
            DOM event type: `&#34;click&#34;`, `&#34;dragstart&#34;`, etc.
        eventInit : Optional[Dict]
            event-specific initialization properties.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.dispatchEvent(
                    selector=selector,
                    type=type,
                    eventInit=mapping.to_impl(eventInit),
                    timeout=timeout,
                )
            )
        )

    def evalOnSelector(
        self,
        selector: str,
        expression: str,
        arg: typing.Any = None,
        force_expr: bool = None,
    ) -&gt; typing.Any:
        &#34;&#34;&#34;Frame.evalOnSelector

        The method finds an element matching the specified selector within the frame and passes it as a first argument to `pageFunction`. See Working with selectors for more details. If no elements match the selector, the method throws an error.
        If `pageFunction` returns a Promise, then `frame.$eval` would wait for the promise to resolve and return its value.
        Examples:

        Parameters
        ----------
        selector : str
            A selector to query frame for. See working with selectors for more details.
        expression : str
            Function to be evaluated in browser context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        Any
            Promise which resolves to the return value of `pageFunction`
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.evalOnSelector(
                    selector=selector,
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )

    def evalOnSelectorAll(
        self,
        selector: str,
        expression: str,
        arg: typing.Any = None,
        force_expr: bool = None,
    ) -&gt; typing.Any:
        &#34;&#34;&#34;Frame.evalOnSelectorAll

        The method finds all elements matching the specified selector within the frame and passes an array of matched elements as a first argument to `pageFunction`. See Working with selectors for more details.
        If `pageFunction` returns a Promise, then `frame.$$eval` would wait for the promise to resolve and return its value.
        Examples:

        Parameters
        ----------
        selector : str
            A selector to query frame for. See working with selectors for more details.
        expression : str
            Function to be evaluated in browser context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        Any
            Promise which resolves to the return value of `pageFunction`
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.evalOnSelectorAll(
                    selector=selector,
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )

    def content(self) -&gt; str:
        &#34;&#34;&#34;Frame.content

        Gets the full HTML contents of the frame, including the doctype.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.content()))

    def setContent(
        self,
        html: str,
        timeout: int = None,
        waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.setContent

        Parameters
        ----------
        html : str
            HTML markup to assign to the page.
        timeout : Optional[int]
            Maximum time in milliseconds for resources to load, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        waitUntil : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
            When to consider navigation succeeded, defaults to `load`. Events can be either:
             - `&#39;domcontentloaded&#39;` - consider setting content to be finished when the `DOMContentLoaded` event is fired.
             - `&#39;load&#39;` - consider setting content to be finished when the `load` event is fired.
             - `&#39;networkidle&#39;` - consider setting content to be finished when there are no network connections for at least `500` ms.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.setContent(
                    html=html, timeout=timeout, waitUntil=waitUntil
                )
            )
        )

    def isDetached(self) -&gt; bool:
        &#34;&#34;&#34;Frame.isDetached

        Returns `true` if the frame has been detached, or `false` otherwise.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.isDetached())

    def addScriptTag(
        self,
        url: str = None,
        path: typing.Union[str, pathlib.Path] = None,
        content: str = None,
        type: str = None,
    ) -&gt; &#34;ElementHandle&#34;:
        &#34;&#34;&#34;Frame.addScriptTag

        Adds a `&lt;script&gt;` tag into the page with the desired url or content.

        Parameters
        ----------
        url : Optional[str]
            URL of a script to be added.
        path : Union[str, pathlib.Path, NoneType]
            Path to the JavaScript file to be injected into frame. If `path` is a relative path, then it is resolved relative to current working directory.
        content : Optional[str]
            Raw JavaScript content to be injected into frame.
        type : Optional[str]
            Script type. Use &#39;module&#39; in order to load a Javascript ES6 module. See script for more details.

        Returns
        -------
        ElementHandle
            which resolves to the added tag when the script&#39;s onload fires or when the script content was injected into frame.
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.addScriptTag(
                    url=url, path=path, content=content, type=type
                )
            )
        )

    def addStyleTag(
        self,
        url: str = None,
        path: typing.Union[str, pathlib.Path] = None,
        content: str = None,
    ) -&gt; &#34;ElementHandle&#34;:
        &#34;&#34;&#34;Frame.addStyleTag

        Adds a `&lt;link rel=&#34;stylesheet&#34;&gt;` tag into the page with the desired url or a `&lt;style type=&#34;text/css&#34;&gt;` tag with the content.

        Parameters
        ----------
        url : Optional[str]
            URL of the `&lt;link&gt;` tag.
        path : Union[str, pathlib.Path, NoneType]
            Path to the CSS file to be injected into frame. If `path` is a relative path, then it is resolved relative to current working directory.
        content : Optional[str]
            Raw CSS content to be injected into frame.

        Returns
        -------
        ElementHandle
            which resolves to the added tag when the stylesheet&#39;s onload fires or when the CSS content was injected into frame.
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(self._impl_obj.addStyleTag(url=url, path=path, content=content))
        )

    def click(
        self,
        selector: str,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: MousePosition = None,
        delay: int = None,
        button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
        clickCount: int = None,
        timeout: int = None,
        force: bool = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.click

        This method clicks an element matching `selector` by performing the following steps:

        Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
        Scroll the element into view if needed.
        Use page.mouse to click in the center of the element, or the specified `position`.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        Parameters
        ----------
        selector : str
            A selector to search for element to click. If there are multiple elements satisfying the selector, the first will be clicked. See working with selectors for more details.
        modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
            Modifier keys to press. Ensures that only these modifiers are pressed during the click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
        position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
            A point to click relative to the top-left corner of element padding box. If not specified, clicks to some visible point of the element.
        delay : Optional[int]
            Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
        button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
            Defaults to `left`.
        clickCount : Optional[int]
            defaults to 1. See UIEvent.detail.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.click(
                    selector=selector,
                    modifiers=modifiers,
                    position=position,
                    delay=delay,
                    button=button,
                    clickCount=clickCount,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def dblclick(
        self,
        selector: str,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: MousePosition = None,
        delay: int = None,
        button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
        timeout: int = None,
        force: bool = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.dblclick

        This method double clicks an element matching `selector` by performing the following steps:

        Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
        Scroll the element into view if needed.
        Use page.mouse to double click in the center of the element, or the specified `position`.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set. Note that if the first click of the `dblclick()` triggers a navigation event, this method will reject.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        **NOTE** `frame.dblclick()` dispatches two `click` events and a single `dblclick` event.

        Parameters
        ----------
        selector : str
            A selector to search for element to double click. If there are multiple elements satisfying the selector, the first will be double clicked. See working with selectors for more details.
        modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
            Modifier keys to press. Ensures that only these modifiers are pressed during the double click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
        position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
            A point to double click relative to the top-left corner of element padding box. If not specified, double clicks to some visible point of the element.
        delay : Optional[int]
            Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
        button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
            Defaults to `left`.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.dblclick(
                    selector=selector,
                    modifiers=modifiers,
                    position=position,
                    delay=delay,
                    button=button,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def tap(
        self,
        selector: str,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: MousePosition = None,
        timeout: int = None,
        force: bool = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.tap

        This method taps an element matching `selector` by performing the following steps:

        Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
        Scroll the element into view if needed.
        Use page.touchscreen to tap the center of the element, or the specified `position`.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        **NOTE** `frame.tap()` requires that the `hasTouch` option of the browser context be set to true.

        Parameters
        ----------
        selector : str
            A selector to search for element to tap. If there are multiple elements satisfying the selector, the first will be tapped. See working with selectors for more details.
        modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
            Modifier keys to press. Ensures that only these modifiers are pressed during the tap, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
        position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
            A point to tap relative to the top-left corner of element padding box. If not specified, taps some visible point of the element.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.tap(
                    selector=selector,
                    modifiers=modifiers,
                    position=position,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def fill(
        self, selector: str, value: str, timeout: int = None, noWaitAfter: bool = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.fill

        This method waits for an element matching `selector`, waits for actionability checks, focuses the element, fills it and triggers an `input` event after filling.
        If the element matching `selector` is not an `&lt;input&gt;`, `&lt;textarea&gt;` or `[contenteditable]` element, this method throws an error.
        Note that you can pass an empty string to clear the input field.
        To send fine-grained keyboard events, use `frame.type`.

        Parameters
        ----------
        selector : str
            A selector to query page for. See working with selectors for more details.
        value : str
            Value to fill for the `&lt;input&gt;`, `&lt;textarea&gt;` or `[contenteditable]` element.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.fill(
                    selector=selector,
                    value=value,
                    timeout=timeout,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def focus(self, selector: str, timeout: int = None) -&gt; NoneType:
        &#34;&#34;&#34;Frame.focus

        This method fetches an element with `selector` and focuses it.
        If there&#39;s no element matching `selector`, the method waits until a matching element appears in the DOM.

        Parameters
        ----------
        selector : str
            A selector of an element to focus. If there are multiple elements satisfying the selector, the first will be focused. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.focus(selector=selector, timeout=timeout))
        )

    def textContent(
        self, selector: str, timeout: int = None
    ) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;Frame.textContent

        Resolves to the `element.textContent`.

        Parameters
        ----------
        selector : str
            A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

        Returns
        -------
        Optional[str]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.textContent(selector=selector, timeout=timeout))
        )

    def innerText(self, selector: str, timeout: int = None) -&gt; str:
        &#34;&#34;&#34;Frame.innerText

        Resolves to the `element.innerText`.

        Parameters
        ----------
        selector : str
            A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.innerText(selector=selector, timeout=timeout))
        )

    def innerHTML(self, selector: str, timeout: int = None) -&gt; str:
        &#34;&#34;&#34;Frame.innerHTML

        Resolves to the `element.innerHTML`.

        Parameters
        ----------
        selector : str
            A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.innerHTML(selector=selector, timeout=timeout))
        )

    def getAttribute(
        self, selector: str, name: str, timeout: int = None
    ) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;Frame.getAttribute

        Returns element attribute value.

        Parameters
        ----------
        selector : str
            A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.
        name : str
            Attribute name to get the value for.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

        Returns
        -------
        Optional[str]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.getAttribute(
                    selector=selector, name=name, timeout=timeout
                )
            )
        )

    def hover(
        self,
        selector: str,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: MousePosition = None,
        timeout: int = None,
        force: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.hover

        This method hovers over an element matching `selector` by performing the following steps:

        Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
        Scroll the element into view if needed.
        Use page.mouse to hover over the center of the element, or the specified `position`.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        Parameters
        ----------
        selector : str
            A selector to search for element to hover. If there are multiple elements satisfying the selector, the first will be hovered. See working with selectors for more details.
        modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
            Modifier keys to press. Ensures that only these modifiers are pressed during the hover, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
        position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
            A point to hover relative to the top-left corner of element padding box. If not specified, hovers over some visible point of the element.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.hover(
                    selector=selector,
                    modifiers=modifiers,
                    position=position,
                    timeout=timeout,
                    force=force,
                )
            )
        )

    def selectOption(
        self,
        selector: str,
        values: typing.Union[
            str,
            &#34;ElementHandle&#34;,
            SelectOption,
            typing.List[str],
            typing.List[&#34;ElementHandle&#34;],
            typing.List[SelectOption],
        ] = None,
        timeout: int = None,
        noWaitAfter: bool = None,
    ) -&gt; typing.List[str]:
        &#34;&#34;&#34;Frame.selectOption

        Triggers a `change` and `input` event once all the provided options have been selected.
        If there&#39;s no `&lt;select&gt;` element matching `selector`, the method throws an error.

        Parameters
        ----------
        selector : str
            A selector to query frame for. See working with selectors for more details.
        values : Union[str, ElementHandle, {&#34;value&#34;: Optional[str], &#34;label&#34;: Optional[str], &#34;index&#34;: Optional[str]}, List[str], List[ElementHandle], List[{&#34;value&#34;: Optional[str], &#34;label&#34;: Optional[str], &#34;index&#34;: Optional[str]}], NoneType]
            Options to select. If the `&lt;select&gt;` has the `multiple` attribute, all matching options are selected, otherwise only the first option matching one of the passed options is selected. String values are equivalent to `{value:&#39;string&#39;}`. Option is considered matching if all specified properties match.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.

        Returns
        -------
        List[str]
            An array of option values that have been successfully selected.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.selectOption(
                    selector=selector,
                    values=mapping.to_impl(values),
                    timeout=timeout,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def setInputFiles(
        self,
        selector: str,
        files: typing.Union[
            str,
            pathlib.Path,
            FilePayload,
            typing.List[str],
            typing.List[pathlib.Path],
            typing.List[FilePayload],
        ],
        timeout: int = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.setInputFiles

        This method expects `selector` to point to an input element.
        Sets the value of the file input to these file paths or files. If some of the `filePaths` are relative paths, then they are resolved relative to the current working directory. For empty array, clears the selected files.

        Parameters
        ----------
        selector : str
            A selector to search for element to click. If there are multiple elements satisfying the selector, the first will be clicked. See working with selectors for more details.
        files : Union[str, pathlib.Path, {&#34;name&#34;: str, &#34;mimeType&#34;: str, &#34;buffer&#34;: bytes}, List[str], List[pathlib.Path], List[{&#34;name&#34;: str, &#34;mimeType&#34;: str, &#34;buffer&#34;: bytes}]]
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.setInputFiles(
                    selector=selector,
                    files=files,
                    timeout=timeout,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def type(
        self,
        selector: str,
        text: str,
        delay: int = None,
        timeout: int = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.type

        Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text. `frame.type` can be used to send fine-grained keyboard events. To fill values in form fields, use `frame.fill`.
        To press a special key, like `Control` or `ArrowDown`, use `keyboard.press`.

        Parameters
        ----------
        selector : str
            A selector of an element to type into. If there are multiple elements satisfying the selector, the first will be used. See working with selectors for more details.
        text : str
            A text to type into a focused element.
        delay : Optional[int]
            Time to wait between key presses in milliseconds. Defaults to 0.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.type(
                    selector=selector,
                    text=text,
                    delay=delay,
                    timeout=timeout,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def press(
        self,
        selector: str,
        key: str,
        delay: int = None,
        timeout: int = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.press

        `key` can specify the intended keyboardEvent.key value or a single character to generate the text for. A superset of the `key` values can be found here. Examples of the keys are:
        `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`, `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.
        Following modification shortcuts are also suported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`.
        Holding down `Shift` will type the text that corresponds to the `key` in the upper case.
        If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective texts.
        Shortcuts such as `key: &#34;Control+o&#34;` or `key: &#34;Control+Shift+T&#34;` are supported as well. When speficied with the modifier, modifier is pressed and being held while the subsequent key is being pressed.

        Parameters
        ----------
        selector : str
            A selector of an element to type into. If there are multiple elements satisfying the selector, the first will be used. See working with selectors for more details.
        key : str
            Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
        delay : Optional[int]
            Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.press(
                    selector=selector,
                    key=key,
                    delay=delay,
                    timeout=timeout,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def check(
        self,
        selector: str,
        timeout: int = None,
        force: bool = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.check

        This method checks an element matching `selector` by performing the following steps:

        Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already checked, this method returns immediately.
        Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
        Scroll the element into view if needed.
        Use page.mouse to click in the center of the element.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
        Ensure that the element is now checked. If not, this method rejects.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        Parameters
        ----------
        selector : str
            A selector to search for checkbox to check. If there are multiple elements satisfying the selector, the first will be checked. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.check(
                    selector=selector,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def uncheck(
        self,
        selector: str,
        timeout: int = None,
        force: bool = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.uncheck

        This method checks an element matching `selector` by performing the following steps:

        Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already unchecked, this method returns immediately.
        Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
        Scroll the element into view if needed.
        Use page.mouse to click in the center of the element.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
        Ensure that the element is now unchecked. If not, this method rejects.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        Parameters
        ----------
        selector : str
            A selector to search for uncheckbox to check. If there are multiple elements satisfying the selector, the first will be checked. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.uncheck(
                    selector=selector,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def waitForTimeout(self, timeout: int) -&gt; NoneType:
        &#34;&#34;&#34;Frame.waitForTimeout

        Returns a promise that resolves after the timeout.
        Note that `frame.waitForTimeout()` should only be used for debugging. Tests using the timer in production are going to be flaky. Use signals such as network events, selectors becoming visible and others instead.

        Parameters
        ----------
        timeout : int
            A timeout to wait for
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.waitForTimeout(timeout=timeout))
        )

    def waitForFunction(
        self,
        expression: str,
        arg: typing.Any = None,
        force_expr: bool = None,
        timeout: int = None,
        polling: typing.Union[int, Literal[&#34;raf&#34;]] = None,
    ) -&gt; &#34;JSHandle&#34;:
        &#34;&#34;&#34;Frame.waitForFunction

        The `waitForFunction` can be used to observe viewport size change:

        To pass an argument from Node.js to the predicate of `frame.waitForFunction` function:

        Parameters
        ----------
        expression : str
            Function to be evaluated in browser context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`
        timeout : Optional[int]
            maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        polling : Union[int, &#39;raf&#39;, NoneType]
            If `polling` is `&#39;raf&#39;`, then `pageFunction` is constantly executed in `requestAnimationFrame` callback. If `polling` is a number, then it is treated as an interval in milliseconds at which the function would be executed. Defaults to `raf`.

        Returns
        -------
        JSHandle
            Promise which resolves when the `pageFunction` returns a truthy value. It resolves to a JSHandle of the truthy value.
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.waitForFunction(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                    timeout=timeout,
                    polling=polling,
                )
            )
        )

    def title(self) -&gt; str:
        &#34;&#34;&#34;Frame.title

        Returns
        -------
        str
            The page&#39;s title.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.title()))

    def expect_load_state(
        self,
        state: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        timeout: int = None,
    ) -&gt; EventContextManager[typing.Union[&#34;Response&#34;, NoneType]]:
        return EventContextManager(
            self._loop, self._impl_obj.waitForLoadState(state, timeout)
        )

    def expect_navigation(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
        waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        timeout: int = None,
    ) -&gt; EventContextManager[typing.Union[&#34;Response&#34;, NoneType]]:
        return EventContextManager(
            self._loop, self._impl_obj.waitForNavigation(url, waitUntil, timeout)
        )


mapping.register(FrameImpl, Frame)


class Worker(SyncBase):
    def __init__(self, obj: WorkerImpl):
        super().__init__(obj)

    @property
    def url(self) -&gt; str:
        &#34;&#34;&#34;Worker.url

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.url)

    def evaluate(
        self, expression: str, arg: typing.Any = None, force_expr: bool = None
    ) -&gt; typing.Any:
        &#34;&#34;&#34;Worker.evaluate

        If the function passed to the `worker.evaluate` returns a Promise, then `worker.evaluate` would wait for the promise to resolve and return its value.
        If the function passed to the `worker.evaluate` returns a non-Serializable value, then `worker.evaluate` resolves to `undefined`. DevTools Protocol also supports transferring some additional values that are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and bigint literals.

        Parameters
        ----------
        expression : str
            Function to be evaluated in the worker context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        Any
            Promise which resolves to the return value of `pageFunction`
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.evaluate(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )

    def evaluateHandle(
        self, expression: str, arg: typing.Any = None, force_expr: bool = None
    ) -&gt; &#34;JSHandle&#34;:
        &#34;&#34;&#34;Worker.evaluateHandle

        The only difference between `worker.evaluate` and `worker.evaluateHandle` is that `worker.evaluateHandle` returns in-page object (JSHandle).
        If the function passed to the `worker.evaluateHandle` returns a Promise, then `worker.evaluateHandle` would wait for the promise to resolve and return its value.

        Parameters
        ----------
        expression : str
            Function to be evaluated in the page context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        JSHandle
            Promise which resolves to the return value of `pageFunction` as in-page object (JSHandle)
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.evaluateHandle(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )


mapping.register(WorkerImpl, Worker)


class Selectors(SyncBase):
    def __init__(self, obj: SelectorsImpl):
        super().__init__(obj)

    def register(
        self,
        name: str,
        source: str = None,
        path: typing.Union[str, pathlib.Path] = None,
        contentScript: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Selectors.register

        An example of registering selector engine that queries elements based on a tag name:

        Parameters
        ----------
        name : str
            Name that is used in selectors as a prefix, e.g. `{name: &#39;foo&#39;}` enables `foo=myselectorbody` selectors. May only contain `[a-zA-Z0-9_]` characters.
        source : Optional[str]
            Script that evaluates to a selector engine instance.
        contentScript : Optional[bool]
            Whether to run this selector engine in isolated JavaScript environment. This environment has access to the same DOM, but not any JavaScript objects from the frame&#39;s scripts. Defaults to `false`. Note that running as a content script is not guaranteed when this engine is used together with other registered engines.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.register(
                    name=name, source=source, path=path, contentScript=contentScript
                )
            )
        )


mapping.register(SelectorsImpl, Selectors)


class ConsoleMessage(SyncBase):
    def __init__(self, obj: ConsoleMessageImpl):
        super().__init__(obj)

    @property
    def type(self) -&gt; str:
        &#34;&#34;&#34;ConsoleMessage.type

        One of the following values: `&#39;log&#39;`, `&#39;debug&#39;`, `&#39;info&#39;`, `&#39;error&#39;`, `&#39;warning&#39;`, `&#39;dir&#39;`, `&#39;dirxml&#39;`, `&#39;table&#39;`, `&#39;trace&#39;`, `&#39;clear&#39;`, `&#39;startGroup&#39;`, `&#39;startGroupCollapsed&#39;`, `&#39;endGroup&#39;`, `&#39;assert&#39;`, `&#39;profile&#39;`, `&#39;profileEnd&#39;`, `&#39;count&#39;`, `&#39;timeEnd&#39;`.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.type)

    @property
    def text(self) -&gt; str:
        &#34;&#34;&#34;ConsoleMessage.text

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.text)

    @property
    def args(self) -&gt; typing.List[&#34;JSHandle&#34;]:
        &#34;&#34;&#34;ConsoleMessage.args

        Returns
        -------
        List[JSHandle]
        &#34;&#34;&#34;
        return mapping.from_impl_list(self._impl_obj.args)

    @property
    def location(self) -&gt; ConsoleMessageLocation:
        &#34;&#34;&#34;ConsoleMessage.location

        Returns
        -------
        {&#34;url&#34;: str, &#34;lineNumber&#34;: int, &#34;columnNumber&#34;: int}
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.location)


mapping.register(ConsoleMessageImpl, ConsoleMessage)


class Dialog(SyncBase):
    def __init__(self, obj: DialogImpl):
        super().__init__(obj)

    @property
    def type(self) -&gt; str:
        &#34;&#34;&#34;Dialog.type

        Returns
        -------
        str
            Dialog&#39;s type, can be one of `alert`, `beforeunload`, `confirm` or `prompt`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.type)

    @property
    def message(self) -&gt; str:
        &#34;&#34;&#34;Dialog.message

        Returns
        -------
        str
            A message displayed in the dialog.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.message)

    @property
    def defaultValue(self) -&gt; str:
        &#34;&#34;&#34;Dialog.defaultValue

        Returns
        -------
        str
            If dialog is prompt, returns default prompt value. Otherwise, returns empty string.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.defaultValue)

    def accept(self, promptText: str = None) -&gt; NoneType:
        &#34;&#34;&#34;Dialog.accept

        Parameters
        ----------
        promptText : Optional[str]
            A text to enter in prompt. Does not cause any effects if the dialog&#39;s `type` is not prompt.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.accept(promptText=promptText))
        )

    def dismiss(self) -&gt; NoneType:
        &#34;&#34;&#34;Dialog.dismiss&#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.dismiss()))


mapping.register(DialogImpl, Dialog)


class Download(SyncBase):
    def __init__(self, obj: DownloadImpl):
        super().__init__(obj)

    @property
    def url(self) -&gt; str:
        &#34;&#34;&#34;Download.url

        Returns downloaded url.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.url)

    @property
    def suggestedFilename(self) -&gt; str:
        &#34;&#34;&#34;Download.suggestedFilename

        Returns suggested filename for this download. It is typically computed by the browser from the `Content-Disposition` response header or the `download` attribute. See the spec on whatwg. Different browsers can use different logic for computing it.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.suggestedFilename)

    def delete(self) -&gt; NoneType:
        &#34;&#34;&#34;Download.delete

        Deletes the downloaded file.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.delete()))

    def failure(self) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;Download.failure

        Returns download error if any.

        Returns
        -------
        Optional[str]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.failure()))

    def path(self) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;Download.path

        Returns path to the downloaded file in case of successful download.

        Returns
        -------
        Optional[str]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.path()))

    def saveAs(self, path: typing.Union[str, pathlib.Path]) -&gt; NoneType:
        &#34;&#34;&#34;Download.saveAs

        Saves the download to a user-specified path.

        Parameters
        ----------
        path : Union[str, pathlib.Path]
            Path where the download should be saved.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.saveAs(path=path)))


mapping.register(DownloadImpl, Download)


class Video(SyncBase):
    def __init__(self, obj: VideoImpl):
        super().__init__(obj)

    def path(self) -&gt; str:
        &#34;&#34;&#34;Video.path

        Returns the file system path this video will be recorded to. The video is guaranteed to be written to the filesystem upon closing the browser context.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.path()))


mapping.register(VideoImpl, Video)


class BindingCall(SyncBase):
    def __init__(self, obj: BindingCallImpl):
        super().__init__(obj)

    def call(self, func: typing.Callable) -&gt; NoneType:
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.call(func=self._wrap_handler(func)))
        )


mapping.register(BindingCallImpl, BindingCall)


class Page(SyncBase):
    def __init__(self, obj: PageImpl):
        super().__init__(obj)

    @property
    def accessibility(self) -&gt; &#34;Accessibility&#34;:
        &#34;&#34;&#34;Page.accessibility

        Returns
        -------
        Accessibility
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.accessibility)

    @property
    def keyboard(self) -&gt; &#34;Keyboard&#34;:
        &#34;&#34;&#34;Page.keyboard

        Returns
        -------
        Keyboard
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.keyboard)

    @property
    def mouse(self) -&gt; &#34;Mouse&#34;:
        &#34;&#34;&#34;Page.mouse

        Returns
        -------
        Mouse
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.mouse)

    @property
    def touchscreen(self) -&gt; &#34;Touchscreen&#34;:
        &#34;&#34;&#34;Page.touchscreen

        Returns
        -------
        Touchscreen
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.touchscreen)

    @property
    def context(self) -&gt; &#34;BrowserContext&#34;:
        &#34;&#34;&#34;Page.context

        Get the browser context that the page belongs to.

        Returns
        -------
        BrowserContext
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.context)

    @property
    def mainFrame(self) -&gt; &#34;Frame&#34;:
        &#34;&#34;&#34;Page.mainFrame

        Page is guaranteed to have a main frame which persists during navigations.

        Returns
        -------
        Frame
            The page&#39;s main frame.
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.mainFrame)

    @property
    def frames(self) -&gt; typing.List[&#34;Frame&#34;]:
        &#34;&#34;&#34;Page.frames

        Returns
        -------
        List[Frame]
            An array of all frames attached to the page.
        &#34;&#34;&#34;
        return mapping.from_impl_list(self._impl_obj.frames)

    @property
    def url(self) -&gt; str:
        &#34;&#34;&#34;Page.url

        This is a shortcut for page.mainFrame().url()

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.url)

    @property
    def workers(self) -&gt; typing.List[&#34;Worker&#34;]:
        &#34;&#34;&#34;Page.workers

        **NOTE** This does not contain ServiceWorkers

        Returns
        -------
        List[Worker]
            This method returns all of the dedicated WebWorkers associated with the page.
        &#34;&#34;&#34;
        return mapping.from_impl_list(self._impl_obj.workers)

    @property
    def video(self) -&gt; typing.Union[&#34;Video&#34;, NoneType]:
        &#34;&#34;&#34;Page.video

        Video object associated with this page.

        Returns
        -------
        Optional[Video]
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._impl_obj.video)

    def opener(self) -&gt; typing.Union[&#34;Page&#34;, NoneType]:
        &#34;&#34;&#34;Page.opener

        Returns
        -------
        Optional[Page]
            Promise which resolves to the opener for popup pages and `null` for others. If the opener has been closed already the promise may resolve to `null`.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._sync(self._impl_obj.opener()))

    def frame(
        self,
        name: str = None,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
    ) -&gt; typing.Union[&#34;Frame&#34;, NoneType]:
        &#34;&#34;&#34;Page.frame

        Returns frame matching the specified criteria. Either `name` or `url` must be specified.

        Parameters
        ----------
        name : Optional[str]
            frame name specified in the `iframe`&#39;s `name` attribute
        url : Union[str, Pattern, typing.Callable[[str], bool], NoneType]
            A glob pattern, regex pattern or predicate receiving frame&#39;s `url` as a URL object.

        Returns
        -------
        Optional[Frame]
            frame matching the criteria. Returns `null` if no frame matches.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._impl_obj.frame(name=name, url=self._wrap_handler(url))
        )

    def setDefaultNavigationTimeout(self, timeout: int) -&gt; NoneType:
        &#34;&#34;&#34;Page.setDefaultNavigationTimeout

        This setting will change the default maximum navigation time for the following methods and related shortcuts:

        page.goBack([options])
        page.goForward([options])
        page.goto(url[, options])
        page.reload([options])
        page.setContent(html[, options])
        page.waitForNavigation([options])

        **NOTE** `page.setDefaultNavigationTimeout` takes priority over `page.setDefaultTimeout`, `browserContext.setDefaultTimeout` and `browserContext.setDefaultNavigationTimeout`.

        Parameters
        ----------
        timeout : int
            Maximum navigation time in milliseconds
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._impl_obj.setDefaultNavigationTimeout(timeout=timeout)
        )

    def setDefaultTimeout(self, timeout: int) -&gt; NoneType:
        &#34;&#34;&#34;Page.setDefaultTimeout

        This setting will change the default maximum time for all the methods accepting `timeout` option.

        **NOTE** `page.setDefaultNavigationTimeout` takes priority over `page.setDefaultTimeout`.

        Parameters
        ----------
        timeout : int
            Maximum time in milliseconds
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._impl_obj.setDefaultTimeout(timeout=timeout)
        )

    def querySelector(self, selector: str) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
        &#34;&#34;&#34;Page.querySelector

        The method finds an element matching the specified selector within the page. If no elements match the selector, the return value resolves to `null`.
        Shortcut for page.mainFrame().$(selector).

        Parameters
        ----------
        selector : str
            A selector to query page for. See working with selectors for more details.

        Returns
        -------
        Optional[ElementHandle]
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._sync(self._impl_obj.querySelector(selector=selector))
        )

    def querySelectorAll(self, selector: str) -&gt; typing.List[&#34;ElementHandle&#34;]:
        &#34;&#34;&#34;Page.querySelectorAll

        The method finds all elements matching the specified selector within the page. If no elements match the selector, the return value resolves to `[]`.
        Shortcut for page.mainFrame().$$(selector).

        Parameters
        ----------
        selector : str
            A selector to query page for. See working with selectors for more details.

        Returns
        -------
        List[ElementHandle]
        &#34;&#34;&#34;
        return mapping.from_impl_list(
            self._sync(self._impl_obj.querySelectorAll(selector=selector))
        )

    def waitForSelector(
        self,
        selector: str,
        timeout: int = None,
        state: Literal[&#34;attached&#34;, &#34;detached&#34;, &#34;hidden&#34;, &#34;visible&#34;] = None,
    ) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
        &#34;&#34;&#34;Page.waitForSelector

        Wait for the `selector` to satisfy `state` option (either appear/disappear from dom, or become visible/hidden). If at the moment of calling the method `selector` already satisfies the condition, the method will return immediately. If the selector doesn&#39;t satisfy the condition for the `timeout` milliseconds, the function will throw.
        This method works across navigations:

        Shortcut for page.mainFrame().waitForSelector(selector[, options]).

        Parameters
        ----------
        selector : str
            A selector of an element to wait for. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        state : Optional[Literal[&#39;attached&#39;, &#39;detached&#39;, &#39;hidden&#39;, &#39;visible&#39;]]
            Defaults to `&#39;visible&#39;`. Can be either:
             - `&#39;attached&#39;` - wait for element to be present in DOM.
             - `&#39;detached&#39;` - wait for element to not be present in DOM.
             - `&#39;visible&#39;` - wait for element to have non-empty bounding box and no `visibility:hidden`. Note that element without any content or with `display:none` has an empty bounding box and is not considered visible.
             - `&#39;hidden&#39;` - wait for element to be either detached from DOM, or have an empty bounding box or `visibility:hidden`. This is opposite to the `&#39;visible&#39;` option.

        Returns
        -------
        Optional[ElementHandle]
            Promise which resolves when element specified by selector satisfies `state` option. Resolves to `null` if waiting for `hidden` or `detached`.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._sync(
                self._impl_obj.waitForSelector(
                    selector=selector, timeout=timeout, state=state
                )
            )
        )

    def dispatchEvent(
        self,
        selector: str,
        type: str,
        eventInit: typing.Dict = None,
        timeout: int = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.dispatchEvent

        The snippet below dispatches the `click` event on the element. Regardless of the visibility state of the elment, `click` is dispatched. This is equivalend to calling `element.click()`.
        Under the hood, it creates an instance of an event based on the given `type`, initializes it with `eventInit` properties and dispatches it on the element. Events are `composed`, `cancelable` and bubble by default.
        Since `eventInit` is event-specific, please refer to the events documentation for the lists of initial properties:

        DragEvent
        FocusEvent
        KeyboardEvent
        MouseEvent
        PointerEvent
        TouchEvent
        Event

        You can also specify `JSHandle` as the property value if you want live objects to be passed into the event:

        Parameters
        ----------
        selector : str
            A selector to search for element to use. If there are multiple elements satisfying the selector, the first will be used. See working with selectors for more details.
        type : str
            DOM event type: `&#34;click&#34;`, `&#34;dragstart&#34;`, etc.
        eventInit : Optional[Dict]
            event-specific initialization properties.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.dispatchEvent(
                    selector=selector,
                    type=type,
                    eventInit=mapping.to_impl(eventInit),
                    timeout=timeout,
                )
            )
        )

    def evaluate(
        self, expression: str, arg: typing.Any = None, force_expr: bool = None
    ) -&gt; typing.Any:
        &#34;&#34;&#34;Page.evaluate

        If the function passed to the `page.evaluate` returns a Promise, then `page.evaluate` would wait for the promise to resolve and return its value.
        If the function passed to the `page.evaluate` returns a non-Serializable value, then `page.evaluate` resolves to `undefined`. DevTools Protocol also supports transferring some additional values that are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and bigint literals.
        Passing argument to `pageFunction`:
        A string can also be passed in instead of a function:
        ElementHandle instances can be passed as an argument to the `page.evaluate`:
        Shortcut for page.mainFrame().evaluate(pageFunction[, arg]).

        Parameters
        ----------
        expression : str
            Function to be evaluated in the page context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        Any
            Promise which resolves to the return value of `pageFunction`
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.evaluate(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )

    def evaluateHandle(
        self, expression: str, arg: typing.Any = None, force_expr: bool = None
    ) -&gt; &#34;JSHandle&#34;:
        &#34;&#34;&#34;Page.evaluateHandle

        The only difference between `page.evaluate` and `page.evaluateHandle` is that `page.evaluateHandle` returns in-page object (JSHandle).
        If the function passed to the `page.evaluateHandle` returns a Promise, then `page.evaluateHandle` would wait for the promise to resolve and return its value.
        A string can also be passed in instead of a function:
        JSHandle instances can be passed as an argument to the `page.evaluateHandle`:

        Parameters
        ----------
        expression : str
            Function to be evaluated in the page context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        JSHandle
            Promise which resolves to the return value of `pageFunction` as in-page object (JSHandle)
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.evaluateHandle(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )

    def evalOnSelector(
        self,
        selector: str,
        expression: str,
        arg: typing.Any = None,
        force_expr: bool = None,
    ) -&gt; typing.Any:
        &#34;&#34;&#34;Page.evalOnSelector

        The method finds an element matching the specified selector within the page and passes it as a first argument to `pageFunction`. If no elements match the selector, the method throws an error.
        If `pageFunction` returns a Promise, then `page.$eval` would wait for the promise to resolve and return its value.
        Examples:
        Shortcut for page.mainFrame().$eval(selector, pageFunction).

        Parameters
        ----------
        selector : str
            A selector to query page for. See working with selectors for more details.
        expression : str
            Function to be evaluated in browser context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        Any
            Promise which resolves to the return value of `pageFunction`
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.evalOnSelector(
                    selector=selector,
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )

    def evalOnSelectorAll(
        self,
        selector: str,
        expression: str,
        arg: typing.Any = None,
        force_expr: bool = None,
    ) -&gt; typing.Any:
        &#34;&#34;&#34;Page.evalOnSelectorAll

        The method finds all elements matching the specified selector within the page and passes an array of matched elements as a first argument to `pageFunction`.
        If `pageFunction` returns a Promise, then `page.$$eval` would wait for the promise to resolve and return its value.
        Examples:

        Parameters
        ----------
        selector : str
            A selector to query page for. See working with selectors for more details.
        expression : str
            Function to be evaluated in browser context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        Any
            Promise which resolves to the return value of `pageFunction`
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.evalOnSelectorAll(
                    selector=selector,
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )

    def addScriptTag(
        self,
        url: str = None,
        path: typing.Union[str, pathlib.Path] = None,
        content: str = None,
        type: str = None,
    ) -&gt; &#34;ElementHandle&#34;:
        &#34;&#34;&#34;Page.addScriptTag

        Adds a `&lt;script&gt;` tag into the page with the desired url or content.
        Shortcut for page.mainFrame().addScriptTag(options).

        Parameters
        ----------
        url : Optional[str]
            URL of a script to be added.
        path : Union[str, pathlib.Path, NoneType]
            Path to the JavaScript file to be injected into frame. If `path` is a relative path, then it is resolved relative to current working directory.
        content : Optional[str]
            Raw JavaScript content to be injected into frame.
        type : Optional[str]
            Script type. Use &#39;module&#39; in order to load a Javascript ES6 module. See script for more details.

        Returns
        -------
        ElementHandle
            which resolves to the added tag when the script&#39;s onload fires or when the script content was injected into frame.
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.addScriptTag(
                    url=url, path=path, content=content, type=type
                )
            )
        )

    def addStyleTag(
        self,
        url: str = None,
        path: typing.Union[str, pathlib.Path] = None,
        content: str = None,
    ) -&gt; &#34;ElementHandle&#34;:
        &#34;&#34;&#34;Page.addStyleTag

        Adds a `&lt;link rel=&#34;stylesheet&#34;&gt;` tag into the page with the desired url or a `&lt;style type=&#34;text/css&#34;&gt;` tag with the content.
        Shortcut for page.mainFrame().addStyleTag(options).

        Parameters
        ----------
        url : Optional[str]
            URL of the `&lt;link&gt;` tag.
        path : Union[str, pathlib.Path, NoneType]
            Path to the CSS file to be injected into frame. If `path` is a relative path, then it is resolved relative to current working directory.
        content : Optional[str]
            Raw CSS content to be injected into frame.

        Returns
        -------
        ElementHandle
            which resolves to the added tag when the stylesheet&#39;s onload fires or when the CSS content was injected into frame.
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(self._impl_obj.addStyleTag(url=url, path=path, content=content))
        )

    def exposeFunction(self, name: str, binding: typing.Callable) -&gt; NoneType:
        &#34;&#34;&#34;Page.exposeFunction

        The method adds a function called `name` on the `window` object of every frame in the page.
        When called, the function executes `playwrightFunction` in Node.js and returns a Promise which resolves to the return value of `playwrightFunction`.
        If the `playwrightFunction` returns a Promise, it will be awaited.
        See browserContext.exposeFunction(name, playwrightFunction) for context-wide exposed function.

        **NOTE** Functions installed via `page.exposeFunction` survive navigations.

        An example of adding an `md5` function to the page:

        An example of adding a `window.readfile` function to the page:

        Parameters
        ----------
        name : str
            Name of the function on the window object
        binding : Callable
            Callback function which will be called in Playwright&#39;s context.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.exposeFunction(
                    name=name, binding=self._wrap_handler(binding)
                )
            )
        )

    def exposeBinding(
        self, name: str, binding: typing.Callable, handle: bool = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.exposeBinding

        The method adds a function called `name` on the `window` object of every frame in this page.
        When called, the function executes `playwrightBinding` in Node.js and returns a Promise which resolves to the return value of `playwrightBinding`.
        If the `playwrightBinding` returns a Promise, it will be awaited.
        The first argument of the `playwrightBinding` function contains information about the caller:
        `{ browserContext: BrowserContext, page: Page, frame: Frame }`.
        See browserContext.exposeBinding(name, playwrightBinding) for the context-wide version.

        **NOTE** Functions installed via `page.exposeBinding` survive navigations.

        An example of exposing page URL to all frames in a page:

        An example of passing an element handle:

        Parameters
        ----------
        name : str
            Name of the function on the window object.
        binding : Callable
            Callback function that will be called in the Playwright&#39;s context.
        handle : Optional[bool]
            Whether to pass the argument as a handle, instead of passing by value. When passing a handle, only one argument is supported. When passing by value, multiple arguments are supported.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.exposeBinding(
                    name=name, binding=self._wrap_handler(binding), handle=handle
                )
            )
        )

    def setExtraHTTPHeaders(self, headers: typing.Dict[str, str]) -&gt; NoneType:
        &#34;&#34;&#34;Page.setExtraHTTPHeaders

        The extra HTTP headers will be sent with every request the page initiates.

        **NOTE** page.setExtraHTTPHeaders does not guarantee the order of headers in the outgoing requests.

        Parameters
        ----------
        headers : Dict[str, str]
            An object containing additional HTTP headers to be sent with every request. All header values must be strings.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.setExtraHTTPHeaders(headers=mapping.to_impl(headers))
            )
        )

    def content(self) -&gt; str:
        &#34;&#34;&#34;Page.content

        Gets the full HTML contents of the page, including the doctype.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.content()))

    def setContent(
        self,
        html: str,
        timeout: int = None,
        waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.setContent

        Parameters
        ----------
        html : str
            HTML markup to assign to the page.
        timeout : Optional[int]
            Maximum time in milliseconds for resources to load, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        waitUntil : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
            When to consider setting markup succeeded, defaults to `load`. Given an array of event strings, setting content is considered to be successful after all events have been fired. Events can be either:
             - `&#39;load&#39;` - consider setting content to be finished when the `load` event is fired.
             - `&#39;domcontentloaded&#39;` - consider setting content to be finished when the `DOMContentLoaded` event is fired.
             - `&#39;networkidle&#39;` - consider setting content to be finished when there are no network connections for at least `500` ms.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.setContent(
                    html=html, timeout=timeout, waitUntil=waitUntil
                )
            )
        )

    def goto(
        self,
        url: str,
        timeout: int = None,
        waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        referer: str = None,
    ) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
        &#34;&#34;&#34;Page.goto

        `page.goto` will throw an error if:

        there&#39;s an SSL error (e.g. in case of self-signed certificates).
        target URL is invalid.
        the `timeout` is exceeded during navigation.
        the remote server does not respond or is unreachable.
        the main resource failed to load.

        `page.goto` will not throw an error when any valid HTTP status code is returned by the remote server, including 404 &#34;Not Found&#34; and 500 &#34;Internal Server Error&#34;.  The status code for such responses can be retrieved by calling response.status().

        **NOTE** `page.goto` either throws an error or returns a main resource response. The only exceptions are navigation to `about:blank` or navigation to the same URL with a different hash, which would succeed and return `null`.

        **NOTE** Headless mode doesn&#39;t support navigation to a PDF document. See the upstream issue.

        Shortcut for page.mainFrame().goto(url[, options])

        Parameters
        ----------
        url : str
            URL to navigate page to. The url should include scheme, e.g. `https://`.
        timeout : Optional[int]
            Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        waitUntil : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
            When to consider navigation succeeded, defaults to `load`. Events can be either:
             - `&#39;domcontentloaded&#39;` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
             - `&#39;load&#39;` - consider navigation to be finished when the `load` event is fired.
             - `&#39;networkidle&#39;` - consider navigation to be finished when there are no network connections for at least `500` ms.
        referer : Optional[str]
            Referer header value. If provided it will take preference over the referer header value set by page.setExtraHTTPHeaders().

        Returns
        -------
        Optional[Response]
            Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._sync(
                self._impl_obj.goto(
                    url=url, timeout=timeout, waitUntil=waitUntil, referer=referer
                )
            )
        )

    def reload(
        self,
        timeout: int = None,
        waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    ) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
        &#34;&#34;&#34;Page.reload

        Parameters
        ----------
        timeout : Optional[int]
            Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        waitUntil : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
            When to consider navigation succeeded, defaults to `load`. Events can be either:
             - `&#39;domcontentloaded&#39;` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
             - `&#39;load&#39;` - consider navigation to be finished when the `load` event is fired.
             - `&#39;networkidle&#39;` - consider navigation to be finished when there are no network connections for at least `500` ms.

        Returns
        -------
        Optional[Response]
            Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._sync(self._impl_obj.reload(timeout=timeout, waitUntil=waitUntil))
        )

    def waitForLoadState(
        self,
        state: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        timeout: int = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.waitForLoadState

        This resolves when the page reaches a required load state, `load` by default. The navigation must have been committed when this method is called. If current document has already reached the required state, resolves immediately.
        Shortcut for page.mainFrame().waitForLoadState([options]).

        Parameters
        ----------
        state : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
            Load state to wait for, defaults to `load`. If the state has been already reached while loading current document, the method resolves immediately.
             - `&#39;load&#39;` - wait for the `load` event to be fired.
             - `&#39;domcontentloaded&#39;` - wait for the `DOMContentLoaded` event to be fired.
             - `&#39;networkidle&#39;` - wait until there are no network connections for at least `500` ms.
        timeout : Optional[int]
            Maximum waiting time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.waitForLoadState(state=state, timeout=timeout))
        )

    def waitForNavigation(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
        waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        timeout: int = None,
    ) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
        &#34;&#34;&#34;Page.waitForNavigation

        This resolves when the page navigates to a new URL or reloads. It is useful for when you run code
        which will indirectly cause the page to navigate. e.g. The click target has an `onclick` handler that triggers navigation from a `setTimeout`. Consider this example:
        **NOTE** Usage of the History API to change the URL is considered a navigation.
        Shortcut for page.mainFrame().waitForNavigation(options).

        Parameters
        ----------
        url : Union[str, Pattern, typing.Callable[[str], bool], NoneType]
            A glob pattern, regex pattern or predicate receiving URL to match while waiting for the navigation.
        waitUntil : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
            When to consider navigation succeeded, defaults to `load`. Events can be either:
             - `&#39;domcontentloaded&#39;` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
             - `&#39;load&#39;` - consider navigation to be finished when the `load` event is fired.
             - `&#39;networkidle&#39;` - consider navigation to be finished when there are no network connections for at least `500` ms.
        timeout : Optional[int]
            Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

        Returns
        -------
        Optional[Response]
            Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect. In case of navigation to a different anchor or navigation due to History API usage, the navigation will resolve with `null`.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._sync(
                self._impl_obj.waitForNavigation(
                    url=self._wrap_handler(url), waitUntil=waitUntil, timeout=timeout
                )
            )
        )

    def waitForRequest(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
        predicate: typing.Union[typing.Callable[[&#34;Request&#34;], bool]] = None,
        timeout: int = None,
    ) -&gt; &#34;Request&#34;:
        &#34;&#34;&#34;Page.waitForRequest


        Parameters
        ----------
        url : Union[str, Pattern, typing.Callable[[str], bool], NoneType]
            Request URL string, regex or predicate receiving Request object.
        timeout : Optional[int]
            Maximum wait time in milliseconds, defaults to 30 seconds, pass `0` to disable the timeout. The default value can be changed by using the page.setDefaultTimeout(timeout) method.

        Returns
        -------
        Request
            Promise which resolves to the matched request.
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.waitForRequest(
                    url=self._wrap_handler(url),
                    predicate=self._wrap_handler(predicate),
                    timeout=timeout,
                )
            )
        )

    def waitForResponse(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
        predicate: typing.Union[typing.Callable[[&#34;Response&#34;], bool]] = None,
        timeout: int = None,
    ) -&gt; &#34;Response&#34;:
        &#34;&#34;&#34;Page.waitForResponse


        Parameters
        ----------
        url : Union[str, Pattern, typing.Callable[[str], bool], NoneType]
            Request URL string, regex or predicate receiving Response object.
        timeout : Optional[int]
            Maximum wait time in milliseconds, defaults to 30 seconds, pass `0` to disable the timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

        Returns
        -------
        Response
            Promise which resolves to the matched response.
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.waitForResponse(
                    url=self._wrap_handler(url),
                    predicate=self._wrap_handler(predicate),
                    timeout=timeout,
                )
            )
        )

    def waitForEvent(
        self,
        event: str,
        predicate: typing.Union[typing.Callable[[typing.Any], bool]] = None,
        timeout: int = None,
    ) -&gt; typing.Any:
        &#34;&#34;&#34;Page.waitForEvent

        Waits for event to fire and passes its value into the predicate function. Resolves when the predicate returns truthy value. Will throw an error if the page is closed before the event
        is fired.

        Parameters
        ----------
        event : str
            Event name, same one would pass into `page.on(event)`.

        Returns
        -------
        Any
            Promise which resolves to the event data value.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.waitForEvent(
                    event=event,
                    predicate=self._wrap_handler(predicate),
                    timeout=timeout,
                )
            )
        )

    def goBack(
        self,
        timeout: int = None,
        waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    ) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
        &#34;&#34;&#34;Page.goBack

        Navigate to the previous page in history.

        Parameters
        ----------
        timeout : Optional[int]
            Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        waitUntil : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
            When to consider navigation succeeded, defaults to `load`. Events can be either:
             - `&#39;domcontentloaded&#39;` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
             - `&#39;load&#39;` - consider navigation to be finished when the `load` event is fired.
             - `&#39;networkidle&#39;` - consider navigation to be finished when there are no network connections for at least `500` ms.

        Returns
        -------
        Optional[Response]
            Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect. If
              can not go back, resolves to `null`.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._sync(self._impl_obj.goBack(timeout=timeout, waitUntil=waitUntil))
        )

    def goForward(
        self,
        timeout: int = None,
        waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    ) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
        &#34;&#34;&#34;Page.goForward

        Navigate to the next page in history.

        Parameters
        ----------
        timeout : Optional[int]
            Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        waitUntil : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
            When to consider navigation succeeded, defaults to `load`. Events can be either:
             - `&#39;domcontentloaded&#39;` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
             - `&#39;load&#39;` - consider navigation to be finished when the `load` event is fired.
             - `&#39;networkidle&#39;` - consider navigation to be finished when there are no network connections for at least `500` ms.

        Returns
        -------
        Optional[Response]
            Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect. If
              can not go forward, resolves to `null`.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._sync(self._impl_obj.goForward(timeout=timeout, waitUntil=waitUntil))
        )

    def emulateMedia(
        self,
        media: Literal[&#34;print&#34;, &#34;screen&#34;] = None,
        colorScheme: Literal[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;] = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.emulateMedia


        Parameters
        ----------
        media : Optional[Literal[&#39;print&#39;, &#39;screen&#39;]]
            Changes the CSS media type of the page. The only allowed values are `&#39;screen&#39;`, `&#39;print&#39;` and `null`. Passing `null` disables CSS media emulation. Omitting `media` or passing `undefined` does not change the emulated value.
        colorScheme : Optional[Literal[&#39;dark&#39;, &#39;light&#39;, &#39;no-preference&#39;]]
            Emulates `&#39;prefers-colors-scheme&#39;` media feature, supported values are `&#39;light&#39;`, `&#39;dark&#39;`, `&#39;no-preference&#39;`. Passing `null` disables color scheme emulation. Omitting `colorScheme` or passing `undefined` does not change the emulated value.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.emulateMedia(media=media, colorScheme=colorScheme)
            )
        )

    def setViewportSize(self, width: int, height: int) -&gt; NoneType:
        &#34;&#34;&#34;Page.setViewportSize

        In the case of multiple pages in a single browser, each page can have its own viewport size. However, browser.newContext([options]) allows to set viewport size (and more) for all pages in the context at once.
        `page.setViewportSize` will resize the page. A lot of websites don&#39;t expect phones to change size, so you should set the viewport size before navigating to the page.

        Parameters
        ----------
        width : int
            page width in pixels. **required**
        height : int
            page height in pixels. **required**
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.setViewportSize(width=width, height=height))
        )

    def viewportSize(self) -&gt; typing.Union[Viewport, NoneType]:
        &#34;&#34;&#34;Page.viewportSize

        Returns
        -------
        Optional[{&#34;width&#34;: int, &#34;height&#34;: int}]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.viewportSize())

    def bringToFront(self) -&gt; NoneType:
        &#34;&#34;&#34;Page.bringToFront

        Brings page to front (activates tab).
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.bringToFront()))

    def addInitScript(
        self, source: str = None, path: typing.Union[str, pathlib.Path] = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.addInitScript

        Adds a script which would be evaluated in one of the following scenarios:

        Whenever the page is navigated.
        Whenever the child frame is attached or navigated. In this case, the script is evaluated in the context of the newly attached frame.

        The script is evaluated after the document was created but before any of its scripts were run. This is useful to amend  the JavaScript environment, e.g. to seed `Math.random`.
        An example of overriding `Math.random` before the page loads:

        **NOTE** The order of evaluation of multiple scripts installed via browserContext.addInitScript(script[, arg]) and page.addInitScript(script[, arg]) is not defined.

        Parameters
        ----------
        source : Optional[str]
            Script to be evaluated in the page.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.addInitScript(source=source, path=path))
        )

    def route(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]],
        handler: typing.Callable[[&#34;Route&#34;, &#34;Request&#34;], typing.Any],
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.route

        Routing provides the capability to modify network requests that are made by a page.
        Once routing is enabled, every request matching the url pattern will stall unless it&#39;s continued, fulfilled or aborted.

        **NOTE** The handler will only be called for the first url if the response is a redirect.

        An example of a naïve handler that aborts all image requests:
        or the same snippet using a regex pattern instead:
        Page routes take precedence over browser context routes (set up with browserContext.route(url, handler)) when request matches both handlers.

        **NOTE** Enabling routing disables http cache.

        Parameters
        ----------
        url : Union[str, Pattern, typing.Callable[[str], bool]]
            A glob pattern, regex pattern or predicate receiving URL to match while routing.
        handler : typing.Callable[[playwright.network.Route, playwright.network.Request], typing.Any]
            handler function to route the request.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.route(
                    url=self._wrap_handler(url), handler=self._wrap_handler(handler)
                )
            )
        )

    def unroute(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]],
        handler: typing.Union[typing.Callable[[&#34;Route&#34;, &#34;Request&#34;], typing.Any]] = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.unroute

        Removes a route created with page.route(url, handler). When `handler` is not specified, removes all routes for the `url`.

        Parameters
        ----------
        url : Union[str, Pattern, typing.Callable[[str], bool]]
            A glob pattern, regex pattern or predicate receiving URL to match while routing.
        handler : Optional[typing.Callable[[playwright.network.Route, playwright.network.Request], typing.Any]]
            Handler function to route the request.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.unroute(
                    url=self._wrap_handler(url), handler=self._wrap_handler(handler)
                )
            )
        )

    def screenshot(
        self,
        timeout: int = None,
        type: Literal[&#34;jpeg&#34;, &#34;png&#34;] = None,
        path: typing.Union[str, pathlib.Path] = None,
        quality: int = None,
        omitBackground: bool = None,
        fullPage: bool = None,
        clip: FloatRect = None,
    ) -&gt; bytes:
        &#34;&#34;&#34;Page.screenshot

        **NOTE** Screenshots take at least 1/6 second on Chromium OS X and Chromium Windows. See https://crbug.com/741689 for discussion.

        Parameters
        ----------
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        type : Optional[Literal[&#39;jpeg&#39;, &#39;png&#39;]]
            Specify screenshot type, defaults to `png`.
        path : Union[str, pathlib.Path, NoneType]
            The file path to save the image to. The screenshot type will be inferred from file extension. If `path` is a relative path, then it is resolved relative to current working directory. If no path is provided, the image won&#39;t be saved to the disk.
        quality : Optional[int]
            The quality of the image, between 0-100. Not applicable to `png` images.
        omitBackground : Optional[bool]
            Hides default white background and allows capturing screenshots with transparency. Not applicable to `jpeg` images. Defaults to `false`.
        fullPage : Optional[bool]
            When true, takes a screenshot of the full scrollable page, instead of the currently visible viewport. Defaults to `false`.
        clip : Optional[{&#34;x&#34;: float, &#34;y&#34;: float, &#34;width&#34;: float, &#34;height&#34;: float}]
            An object which specifies clipping of the resulting image. Should have the following fields:

        Returns
        -------
        bytes
            Promise which resolves to buffer with the captured screenshot.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.screenshot(
                    timeout=timeout,
                    type=type,
                    path=path,
                    quality=quality,
                    omitBackground=omitBackground,
                    fullPage=fullPage,
                    clip=clip,
                )
            )
        )

    def title(self) -&gt; str:
        &#34;&#34;&#34;Page.title

        Shortcut for page.mainFrame().title().

        Returns
        -------
        str
            The page&#39;s title.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.title()))

    def close(self, runBeforeUnload: bool = None) -&gt; NoneType:
        &#34;&#34;&#34;Page.close

        If `runBeforeUnload` is `false` the result will resolve only after the page has been closed.
        If `runBeforeUnload` is `true` the method will **not** wait for the page to close.
        By default, `page.close()` **does not** run beforeunload handlers.

        **NOTE** if `runBeforeUnload` is passed as true, a `beforeunload` dialog might be summoned
        and should be handled manually via page&#39;s &#39;dialog&#39; event.

        Parameters
        ----------
        runBeforeUnload : Optional[bool]
            Defaults to `false`. Whether to run the
            before unload
            page handlers.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.close(runBeforeUnload=runBeforeUnload))
        )

    def isClosed(self) -&gt; bool:
        &#34;&#34;&#34;Page.isClosed

        Indicates that the page has been closed.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.isClosed())

    def click(
        self,
        selector: str,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: MousePosition = None,
        delay: int = None,
        button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
        clickCount: int = None,
        timeout: int = None,
        force: bool = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.click

        This method clicks an element matching `selector` by performing the following steps:

        Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
        Scroll the element into view if needed.
        Use page.mouse to click in the center of the element, or the specified `position`.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.
        Shortcut for page.mainFrame().click(selector[, options]).

        Parameters
        ----------
        selector : str
            A selector to search for element to click. If there are multiple elements satisfying the selector, the first will be clicked. See working with selectors for more details.
        modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
            Modifier keys to press. Ensures that only these modifiers are pressed during the click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
        position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
            A point to click relative to the top-left corner of element padding box. If not specified, clicks to some visible point of the element.
        delay : Optional[int]
            Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
        button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
            Defaults to `left`.
        clickCount : Optional[int]
            defaults to 1. See UIEvent.detail.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.click(
                    selector=selector,
                    modifiers=modifiers,
                    position=position,
                    delay=delay,
                    button=button,
                    clickCount=clickCount,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def dblclick(
        self,
        selector: str,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: MousePosition = None,
        delay: int = None,
        button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
        timeout: int = None,
        force: bool = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.dblclick

        This method double clicks an element matching `selector` by performing the following steps:

        Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
        Scroll the element into view if needed.
        Use page.mouse to double click in the center of the element, or the specified `position`.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set. Note that if the first click of the `dblclick()` triggers a navigation event, this method will reject.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        **NOTE** `page.dblclick()` dispatches two `click` events and a single `dblclick` event.

        Shortcut for page.mainFrame().dblclick(selector[, options]).

        Parameters
        ----------
        selector : str
            A selector to search for element to double click. If there are multiple elements satisfying the selector, the first will be double clicked. See working with selectors for more details.
        modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
            Modifier keys to press. Ensures that only these modifiers are pressed during the double click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
        position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
            A point to double click relative to the top-left corner of element padding box. If not specified, double clicks to some visible point of the element.
        delay : Optional[int]
            Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
        button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
            Defaults to `left`.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.dblclick(
                    selector=selector,
                    modifiers=modifiers,
                    position=position,
                    delay=delay,
                    button=button,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def tap(
        self,
        selector: str,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: MousePosition = None,
        timeout: int = None,
        force: bool = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.tap

        This method taps an element matching `selector` by performing the following steps:

        Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
        Scroll the element into view if needed.
        Use page.touchscreen to tap the center of the element, or the specified `position`.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        **NOTE** `page.tap()` requires that the `hasTouch` option of the browser context be set to true.

        Shortcut for page.mainFrame().tap().

        Parameters
        ----------
        selector : str
            A selector to search for element to tap. If there are multiple elements satisfying the selector, the first will be tapped. See working with selectors for more details.
        modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
            Modifier keys to press. Ensures that only these modifiers are pressed during the tap, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
        position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
            A point to tap relative to the top-left corner of element padding box. If not specified, taps some visible point of the element.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.tap(
                    selector=selector,
                    modifiers=modifiers,
                    position=position,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def fill(
        self, selector: str, value: str, timeout: int = None, noWaitAfter: bool = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.fill

        This method waits for an element matching `selector`, waits for actionability checks, focuses the element, fills it and triggers an `input` event after filling.
        If the element matching `selector` is not an `&lt;input&gt;`, `&lt;textarea&gt;` or `[contenteditable]` element, this method throws an error.
        Note that you can pass an empty string to clear the input field.
        To send fine-grained keyboard events, use `page.type`.
        Shortcut for page.mainFrame().fill()

        Parameters
        ----------
        selector : str
            A selector to query page for. See working with selectors for more details.
        value : str
            Value to fill for the `&lt;input&gt;`, `&lt;textarea&gt;` or `[contenteditable]` element.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.fill(
                    selector=selector,
                    value=value,
                    timeout=timeout,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def focus(self, selector: str, timeout: int = None) -&gt; NoneType:
        &#34;&#34;&#34;Page.focus

        This method fetches an element with `selector` and focuses it.
        If there&#39;s no element matching `selector`, the method waits until a matching element appears in the DOM.
        Shortcut for page.mainFrame().focus(selector).

        Parameters
        ----------
        selector : str
            A selector of an element to focus. If there are multiple elements satisfying the selector, the first will be focused. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.focus(selector=selector, timeout=timeout))
        )

    def textContent(
        self, selector: str, timeout: int = None
    ) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;Page.textContent

        Resolves to the `element.textContent`.

        Parameters
        ----------
        selector : str
            A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

        Returns
        -------
        Optional[str]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.textContent(selector=selector, timeout=timeout))
        )

    def innerText(self, selector: str, timeout: int = None) -&gt; str:
        &#34;&#34;&#34;Page.innerText

        Resolves to the `element.innerText`.

        Parameters
        ----------
        selector : str
            A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.innerText(selector=selector, timeout=timeout))
        )

    def innerHTML(self, selector: str, timeout: int = None) -&gt; str:
        &#34;&#34;&#34;Page.innerHTML

        Resolves to the `element.innerHTML`.

        Parameters
        ----------
        selector : str
            A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.innerHTML(selector=selector, timeout=timeout))
        )

    def getAttribute(
        self, selector: str, name: str, timeout: int = None
    ) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;Page.getAttribute

        Returns element attribute value.

        Parameters
        ----------
        selector : str
            A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.
        name : str
            Attribute name to get the value for.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

        Returns
        -------
        Optional[str]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.getAttribute(
                    selector=selector, name=name, timeout=timeout
                )
            )
        )

    def hover(
        self,
        selector: str,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: MousePosition = None,
        timeout: int = None,
        force: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.hover

        This method hovers over an element matching `selector` by performing the following steps:

        Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
        Scroll the element into view if needed.
        Use page.mouse to hover over the center of the element, or the specified `position`.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.
        Shortcut for page.mainFrame().hover(selector[, options]).

        Parameters
        ----------
        selector : str
            A selector to search for element to hover. If there are multiple elements satisfying the selector, the first will be hovered. See working with selectors for more details.
        modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
            Modifier keys to press. Ensures that only these modifiers are pressed during the hover, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
        position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
            A point to hover relative to the top-left corner of element padding box. If not specified, hovers over some visible point of the element.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.hover(
                    selector=selector,
                    modifiers=modifiers,
                    position=position,
                    timeout=timeout,
                    force=force,
                )
            )
        )

    def selectOption(
        self,
        selector: str,
        values: typing.Union[
            str,
            &#34;ElementHandle&#34;,
            SelectOption,
            typing.List[str],
            typing.List[&#34;ElementHandle&#34;],
            typing.List[SelectOption],
        ] = None,
        timeout: int = None,
        noWaitAfter: bool = None,
    ) -&gt; typing.List[str]:
        &#34;&#34;&#34;Page.selectOption

        Triggers a `change` and `input` event once all the provided options have been selected.
        If there&#39;s no `&lt;select&gt;` element matching `selector`, the method throws an error.

        Shortcut for page.mainFrame().selectOption()

        Parameters
        ----------
        selector : str
            A selector to query page for. See working with selectors for more details.
        values : Union[str, ElementHandle, {&#34;value&#34;: Optional[str], &#34;label&#34;: Optional[str], &#34;index&#34;: Optional[str]}, List[str], List[ElementHandle], List[{&#34;value&#34;: Optional[str], &#34;label&#34;: Optional[str], &#34;index&#34;: Optional[str]}], NoneType]
            Options to select. If the `&lt;select&gt;` has the `multiple` attribute, all matching options are selected, otherwise only the first option matching one of the passed options is selected. String values are equivalent to `{value:&#39;string&#39;}`. Option is considered matching if all specified properties match.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.

        Returns
        -------
        List[str]
            An array of option values that have been successfully selected.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.selectOption(
                    selector=selector,
                    values=mapping.to_impl(values),
                    timeout=timeout,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def setInputFiles(
        self,
        selector: str,
        files: typing.Union[
            str, FilePayload, typing.List[str], typing.List[FilePayload]
        ],
        timeout: int = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.setInputFiles

        This method expects `selector` to point to an input element.
        Sets the value of the file input to these file paths or files. If some of the `filePaths` are relative paths, then they are resolved relative to the current working directory. For empty array, clears the selected files.

        Parameters
        ----------
        selector : str
            A selector to search for element to click. If there are multiple elements satisfying the selector, the first will be clicked. See working with selectors for more details.
        files : Union[str, {&#34;name&#34;: str, &#34;mimeType&#34;: str, &#34;buffer&#34;: bytes}, List[str], List[{&#34;name&#34;: str, &#34;mimeType&#34;: str, &#34;buffer&#34;: bytes}]]
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.setInputFiles(
                    selector=selector,
                    files=files,
                    timeout=timeout,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def type(
        self,
        selector: str,
        text: str,
        delay: int = None,
        timeout: int = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.type

        Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text. `page.type` can be used to send fine-grained keyboard events. To fill values in form fields, use `page.fill`.
        To press a special key, like `Control` or `ArrowDown`, use `keyboard.press`.
        Shortcut for page.mainFrame().type(selector, text[, options]).

        Parameters
        ----------
        selector : str
            A selector of an element to type into. If there are multiple elements satisfying the selector, the first will be used. See working with selectors for more details.
        text : str
            A text to type into a focused element.
        delay : Optional[int]
            Time to wait between key presses in milliseconds. Defaults to 0.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.type(
                    selector=selector,
                    text=text,
                    delay=delay,
                    timeout=timeout,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def press(
        self,
        selector: str,
        key: str,
        delay: int = None,
        timeout: int = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.press

        Focuses the element, and then uses `keyboard.down` and `keyboard.up`.
        `key` can specify the intended keyboardEvent.key value or a single character to generate the text for. A superset of the `key` values can be found here. Examples of the keys are:
        `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`, `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.
        Following modification shortcuts are also suported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`.
        Holding down `Shift` will type the text that corresponds to the `key` in the upper case.
        If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective texts.
        Shortcuts such as `key: &#34;Control+o&#34;` or `key: &#34;Control+Shift+T&#34;` are supported as well. When speficied with the modifier, modifier is pressed and being held while the subsequent key is being pressed.

        Parameters
        ----------
        selector : str
            A selector of an element to type into. If there are multiple elements satisfying the selector, the first will be used. See working with selectors for more details.
        key : str
            Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
        delay : Optional[int]
            Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.press(
                    selector=selector,
                    key=key,
                    delay=delay,
                    timeout=timeout,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def check(
        self,
        selector: str,
        timeout: int = None,
        force: bool = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.check

        This method checks an element matching `selector` by performing the following steps:

        Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already checked, this method returns immediately.
        Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
        Scroll the element into view if needed.
        Use page.mouse to click in the center of the element.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
        Ensure that the element is now checked. If not, this method rejects.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.
        Shortcut for page.mainFrame().check(selector[, options]).

        Parameters
        ----------
        selector : str
            A selector to search for checkbox or radio button to check. If there are multiple elements satisfying the selector, the first will be checked. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.check(
                    selector=selector,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def uncheck(
        self,
        selector: str,
        timeout: int = None,
        force: bool = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.uncheck

        This method unchecks an element matching `selector` by performing the following steps:

        Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already unchecked, this method returns immediately.
        Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
        Scroll the element into view if needed.
        Use page.mouse to click in the center of the element.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
        Ensure that the element is now unchecked. If not, this method rejects.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.
        Shortcut for page.mainFrame().uncheck(selector[, options]).

        Parameters
        ----------
        selector : str
            A selector to search for uncheckbox to check. If there are multiple elements satisfying the selector, the first will be checked. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.uncheck(
                    selector=selector,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def waitForTimeout(self, timeout: int) -&gt; NoneType:
        &#34;&#34;&#34;Page.waitForTimeout

        Returns a promise that resolves after the timeout.
        Note that `page.waitForTimeout()` should only be used for debugging. Tests using the timer in production are going to be flaky. Use signals such as network events, selectors becoming visible and others instead.
        Shortcut for page.mainFrame().waitForTimeout(timeout).

        Parameters
        ----------
        timeout : int
            A timeout to wait for
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.waitForTimeout(timeout=timeout))
        )

    def waitForFunction(
        self,
        expression: str,
        arg: typing.Any = None,
        force_expr: bool = None,
        timeout: int = None,
        polling: typing.Union[int, Literal[&#34;raf&#34;]] = None,
    ) -&gt; &#34;JSHandle&#34;:
        &#34;&#34;&#34;Page.waitForFunction

        The `waitForFunction` can be used to observe viewport size change:

        To pass an argument from Node.js to the predicate of `page.waitForFunction` function:
        Shortcut for page.mainFrame().waitForFunction(pageFunction[, arg, options]).

        Parameters
        ----------
        expression : str
            Function to be evaluated in browser context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`
        timeout : Optional[int]
            maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can be changed by using the page.setDefaultTimeout(timeout) method.
        polling : Union[int, &#39;raf&#39;, NoneType]
            If `polling` is `&#39;raf&#39;`, then `pageFunction` is constantly executed in `requestAnimationFrame` callback. If `polling` is a number, then it is treated as an interval in milliseconds at which the function would be executed. Defaults to `raf`.

        Returns
        -------
        JSHandle
            Promise which resolves when the `pageFunction` returns a truthy value. It resolves to a JSHandle of the truthy value.
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.waitForFunction(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                    timeout=timeout,
                    polling=polling,
                )
            )
        )

    def pdf(
        self,
        scale: int = None,
        displayHeaderFooter: bool = None,
        headerTemplate: str = None,
        footerTemplate: str = None,
        printBackground: bool = None,
        landscape: bool = None,
        pageRanges: str = None,
        format: str = None,
        width: typing.Union[str, float] = None,
        height: typing.Union[str, float] = None,
        preferCSSPageSize: bool = None,
        margin: PdfMargins = None,
        path: typing.Union[str, pathlib.Path] = None,
    ) -&gt; bytes:
        &#34;&#34;&#34;Page.pdf

        **NOTE** Generating a pdf is currently only supported in Chromium headless.

        `page.pdf()` generates a pdf of the page with `print` css media. To generate a pdf with `screen` media, call page.emulateMedia({ media: &#39;screen&#39; }) before calling `page.pdf()`:

        **NOTE** By default, `page.pdf()` generates a pdf with modified colors for printing. Use the `-webkit-print-color-adjust` property to force rendering of exact colors.

        The `width`, `height`, and `margin` options accept values labeled with units. Unlabeled values are treated as pixels.
        A few examples:

        `page.pdf({width: 100})` - prints with width set to 100 pixels
        `page.pdf({width: &#39;100px&#39;})` - prints with width set to 100 pixels
        `page.pdf({width: &#39;10cm&#39;})` - prints with width set to 10 centimeters.

        All possible units are:

        `px` - pixel
        `in` - inch
        `cm` - centimeter
        `mm` - millimeter

        The `format` options are:

        `Letter`: 8.5in x 11in
        `Legal`: 8.5in x 14in
        `Tabloid`: 11in x 17in
        `Ledger`: 17in x 11in
        `A0`: 33.1in x 46.8in
        `A1`: 23.4in x 33.1in
        `A2`: 16.54in x 23.4in
        `A3`: 11.7in x 16.54in
        `A4`: 8.27in x 11.7in
        `A5`: 5.83in x 8.27in
        `A6`: 4.13in x 5.83in

        **NOTE** `headerTemplate` and `footerTemplate` markup have the following limitations:

        Script tags inside templates are not evaluated.
        Page styles are not visible inside templates.

        Parameters
        ----------
        scale : Optional[int]
            Scale of the webpage rendering. Defaults to `1`. Scale amount must be between 0.1 and 2.
        displayHeaderFooter : Optional[bool]
            Display header and footer. Defaults to `false`.
        headerTemplate : Optional[str]
            HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them:
             - `&#39;date&#39;` formatted print date
             - `&#39;title&#39;` document title
             - `&#39;url&#39;` document location
             - `&#39;pageNumber&#39;` current page number
             - `&#39;totalPages&#39;` total pages in the document
        footerTemplate : Optional[str]
            HTML template for the print footer. Should use the same format as the `headerTemplate`.
        printBackground : Optional[bool]
            Print background graphics. Defaults to `false`.
        landscape : Optional[bool]
            Paper orientation. Defaults to `false`.
        pageRanges : Optional[str]
            Paper ranges to print, e.g., &#39;1-5, 8, 11-13&#39;. Defaults to the empty string, which means print all pages.
        format : Optional[str]
            Paper format. If set, takes priority over `width` or `height` options. Defaults to &#39;Letter&#39;.
        width : Union[str, float, NoneType]
            Paper width, accepts values labeled with units.
        height : Union[str, float, NoneType]
            Paper height, accepts values labeled with units.
        preferCSSPageSize : Optional[bool]
            Give any CSS `@page` size declared in the page priority over what is declared in `width` and `height` or `format` options. Defaults to `false`, which will scale the content to fit the paper size.
        margin : Optional[{&#34;top&#34;: Union[str, int, NoneType], &#34;right&#34;: Union[str, int, NoneType], &#34;bottom&#34;: Union[str, int, NoneType], &#34;left&#34;: Union[str, int, NoneType]}]
            Paper margins, defaults to none.
        path : Union[str, pathlib.Path, NoneType]
            The file path to save the PDF to. If `path` is a relative path, then it is resolved relative to current working directory. If no path is provided, the PDF won&#39;t be saved to the disk.

        Returns
        -------
        bytes
            Promise which resolves with PDF buffer.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.pdf(
                    scale=scale,
                    displayHeaderFooter=displayHeaderFooter,
                    headerTemplate=headerTemplate,
                    footerTemplate=footerTemplate,
                    printBackground=printBackground,
                    landscape=landscape,
                    pageRanges=pageRanges,
                    format=format,
                    width=width,
                    height=height,
                    preferCSSPageSize=preferCSSPageSize,
                    margin=margin,
                    path=path,
                )
            )
        )

    def expect_event(
        self,
        event: str,
        predicate: typing.Union[typing.Callable[[typing.Any], bool]] = None,
        timeout: int = None,
    ) -&gt; EventContextManager:
        return EventContextManager(
            self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
        )

    def expect_console_message(
        self,
        predicate: typing.Union[typing.Callable[[&#34;ConsoleMessage&#34;], bool]] = None,
        timeout: int = None,
    ) -&gt; EventContextManager[&#34;ConsoleMessage&#34;]:
        event = &#34;console&#34;
        return EventContextManager(
            self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
        )

    def expect_dialog(
        self,
        predicate: typing.Union[typing.Callable[[&#34;Dialog&#34;], bool]] = None,
        timeout: int = None,
    ) -&gt; EventContextManager[&#34;Dialog&#34;]:
        event = &#34;dialog&#34;
        return EventContextManager(
            self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
        )

    def expect_download(
        self,
        predicate: typing.Union[typing.Callable[[&#34;Download&#34;], bool]] = None,
        timeout: int = None,
    ) -&gt; EventContextManager[&#34;Download&#34;]:
        event = &#34;download&#34;
        return EventContextManager(
            self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
        )

    def expect_file_chooser(
        self,
        predicate: typing.Union[typing.Callable[[&#34;FileChooser&#34;], bool]] = None,
        timeout: int = None,
    ) -&gt; EventContextManager[&#34;FileChooser&#34;]:
        event = &#34;filechooser&#34;
        return EventContextManager(
            self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
        )

    def expect_load_state(
        self,
        state: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        timeout: int = None,
    ) -&gt; EventContextManager[typing.Union[&#34;Response&#34;, NoneType]]:
        return EventContextManager(
            self._loop, self._impl_obj.waitForLoadState(state, timeout)
        )

    def expect_navigation(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
        waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        timeout: int = None,
    ) -&gt; EventContextManager[typing.Union[&#34;Response&#34;, NoneType]]:
        return EventContextManager(
            self._loop, self._impl_obj.waitForNavigation(url, waitUntil, timeout)
        )

    def expect_popup(
        self,
        predicate: typing.Union[typing.Callable[[&#34;Page&#34;], bool]] = None,
        timeout: int = None,
    ) -&gt; EventContextManager[&#34;Page&#34;]:
        event = &#34;popup&#34;
        return EventContextManager(
            self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
        )

    def expect_request(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
        predicate: typing.Union[typing.Callable[[&#34;Request&#34;], bool]] = None,
        timeout: int = None,
    ) -&gt; EventContextManager[&#34;Request&#34;]:
        return EventContextManager(
            self._loop, self._impl_obj.waitForRequest(url, predicate, timeout)
        )

    def expect_response(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
        predicate: typing.Union[typing.Callable[[&#34;Request&#34;], bool]] = None,
        timeout: int = None,
    ) -&gt; EventContextManager[&#34;Response&#34;]:
        return EventContextManager(
            self._loop, self._impl_obj.waitForResponse(url, predicate, timeout)
        )

    def expect_worker(
        self,
        predicate: typing.Union[typing.Callable[[&#34;Worker&#34;], bool]] = None,
        timeout: int = None,
    ) -&gt; EventContextManager[&#34;Worker&#34;]:
        event = &#34;worker&#34;
        return EventContextManager(
            self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
        )


mapping.register(PageImpl, Page)


class BrowserContext(SyncBase):
    def __init__(self, obj: BrowserContextImpl):
        super().__init__(obj)

    @property
    def pages(self) -&gt; typing.List[&#34;Page&#34;]:
        &#34;&#34;&#34;BrowserContext.pages

        Returns
        -------
        List[Page]
            All open pages in the context. Non visible pages, such as `&#34;background_page&#34;`, will not be listed here. You can find them using chromiumBrowserContext.backgroundPages().
        &#34;&#34;&#34;
        return mapping.from_impl_list(self._impl_obj.pages)

    @property
    def browser(self) -&gt; typing.Union[&#34;Browser&#34;, NoneType]:
        &#34;&#34;&#34;BrowserContext.browser

        Returns
        -------
        Optional[Browser]
            Returns the browser instance of the context. If it was launched as a persistent context null gets returned.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._impl_obj.browser)

    def setDefaultNavigationTimeout(self, timeout: int) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.setDefaultNavigationTimeout

        This setting will change the default maximum navigation time for the following methods and related shortcuts:

        page.goBack([options])
        page.goForward([options])
        page.goto(url[, options])
        page.reload([options])
        page.setContent(html[, options])
        page.waitForNavigation([options])

        **NOTE** `page.setDefaultNavigationTimeout` and `page.setDefaultTimeout` take priority over `browserContext.setDefaultNavigationTimeout`.

        Parameters
        ----------
        timeout : int
            Maximum navigation time in milliseconds
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._impl_obj.setDefaultNavigationTimeout(timeout=timeout)
        )

    def setDefaultTimeout(self, timeout: int) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.setDefaultTimeout

        This setting will change the default maximum time for all the methods accepting `timeout` option.

        **NOTE** `page.setDefaultNavigationTimeout`, `page.setDefaultTimeout` and `browserContext.setDefaultNavigationTimeout` take priority over `browserContext.setDefaultTimeout`.

        Parameters
        ----------
        timeout : int
            Maximum time in milliseconds
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._impl_obj.setDefaultTimeout(timeout=timeout)
        )

    def newPage(self) -&gt; &#34;Page&#34;:
        &#34;&#34;&#34;BrowserContext.newPage

        Creates a new page in the browser context.

        Returns
        -------
        Page
        &#34;&#34;&#34;
        return mapping.from_impl(self._sync(self._impl_obj.newPage()))

    def cookies(
        self, urls: typing.Union[str, typing.List[str]] = None
    ) -&gt; typing.List[typing.Dict]:
        &#34;&#34;&#34;BrowserContext.cookies

        If no URLs are specified, this method returns all cookies.
        If URLs are specified, only cookies that affect those URLs are returned.

        Parameters
        ----------
        urls : Union[str, List[str], NoneType]

        Returns
        -------
        List[Dict]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.cookies(urls=urls)))

    def addCookies(self, cookies: typing.List[typing.Dict]) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.addCookies


        Parameters
        ----------
        cookies : List[Dict]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.addCookies(cookies=mapping.to_impl(cookies)))
        )

    def clearCookies(self) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.clearCookies

        Clears context cookies.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.clearCookies()))

    def grantPermissions(
        self, permissions: typing.List[str], origin: str = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.grantPermissions

        Grants specified permissions to the browser context. Only grants corresponding permissions to the given origin if specified.

        Parameters
        ----------
        permissions : List[str]
            A permission or an array of permissions to grant. Permissions can be one of the following values:
             - `&#39;geolocation&#39;`
             - `&#39;midi&#39;`
             - `&#39;midi-sysex&#39;` (system-exclusive midi)
             - `&#39;notifications&#39;`
             - `&#39;push&#39;`
             - `&#39;camera&#39;`
             - `&#39;microphone&#39;`
             - `&#39;background-sync&#39;`
             - `&#39;ambient-light-sensor&#39;`
             - `&#39;accelerometer&#39;`
             - `&#39;gyroscope&#39;`
             - `&#39;magnetometer&#39;`
             - `&#39;accessibility-events&#39;`
             - `&#39;clipboard-read&#39;`
             - `&#39;clipboard-write&#39;`
             - `&#39;payment-handler&#39;`
        origin : Optional[str]
            The origin to grant permissions to, e.g. &#34;https://example.com&#34;.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.grantPermissions(permissions=permissions, origin=origin)
            )
        )

    def clearPermissions(self) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.clearPermissions

        Clears all permission overrides for the browser context.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.clearPermissions()))

    def setGeolocation(self, geolocation: Geolocation = None) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.setGeolocation

        Sets the context&#39;s geolocation. Passing `null` or `undefined` emulates position unavailable.

        **NOTE** Consider using browserContext.grantPermissions to grant permissions for the browser context pages to read its geolocation.

        Parameters
        ----------
        geolocation : Optional[{&#34;latitude&#34;: float, &#34;longitude&#34;: float, &#34;accuracy&#34;: Optional[float]}]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.setGeolocation(geolocation=geolocation))
        )

    def setExtraHTTPHeaders(self, headers: typing.Dict[str, str]) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.setExtraHTTPHeaders

        The extra HTTP headers will be sent with every request initiated by any page in the context. These headers are merged with page-specific extra HTTP headers set with page.setExtraHTTPHeaders(). If page overrides a particular header, page-specific header value will be used instead of the browser context header value.

        **NOTE** `browserContext.setExtraHTTPHeaders` does not guarantee the order of headers in the outgoing requests.

        Parameters
        ----------
        headers : Dict[str, str]
            An object containing additional HTTP headers to be sent with every request. All header values must be strings.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.setExtraHTTPHeaders(headers=mapping.to_impl(headers))
            )
        )

    def setOffline(self, offline: bool) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.setOffline

        Parameters
        ----------
        offline : bool
            Whether to emulate network being offline for the browser context.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.setOffline(offline=offline))
        )

    def addInitScript(
        self, source: str = None, path: typing.Union[str, pathlib.Path] = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.addInitScript

        Adds a script which would be evaluated in one of the following scenarios:

        Whenever a page is created in the browser context or is navigated.
        Whenever a child frame is attached or navigated in any page in the browser context. In this case, the script is evaluated in the context of the newly attached frame.

        The script is evaluated after the document was created but before any of its scripts were run. This is useful to amend  the JavaScript environment, e.g. to seed `Math.random`.
        An example of overriding `Math.random` before the page loads:

        **NOTE** The order of evaluation of multiple scripts installed via browserContext.addInitScript(script[, arg]) and page.addInitScript(script[, arg]) is not defined.

        Parameters
        ----------
        source : Optional[str]
            Script to be evaluated in all pages in the browser context.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.addInitScript(source=source, path=path))
        )

    def exposeBinding(
        self, name: str, binding: typing.Callable, handle: bool = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.exposeBinding

        The method adds a function called `name` on the `window` object of every frame in every page in the context.
        When called, the function executes `playwrightBinding` in Node.js and returns a Promise which resolves to the return value of `playwrightBinding`.
        If the `playwrightBinding` returns a Promise, it will be awaited.
        The first argument of the `playwrightBinding` function contains information about the caller:
        `{ browserContext: BrowserContext, page: Page, frame: Frame }`.
        See page.exposeBinding(name, playwrightBinding) for page-only version.
        An example of exposing page URL to all frames in all pages in the context:

        An example of passing an element handle:

        Parameters
        ----------
        name : str
            Name of the function on the window object.
        binding : Callable
            Callback function that will be called in the Playwright&#39;s context.
        handle : Optional[bool]
            Whether to pass the argument as a handle, instead of passing by value. When passing a handle, only one argument is supported. When passing by value, multiple arguments are supported.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.exposeBinding(
                    name=name, binding=self._wrap_handler(binding), handle=handle
                )
            )
        )

    def exposeFunction(self, name: str, binding: typing.Callable) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.exposeFunction

        The method adds a function called `name` on the `window` object of every frame in every page in the context.
        When called, the function executes `playwrightFunction` in Node.js and returns a Promise which resolves to the return value of `playwrightFunction`.
        If the `playwrightFunction` returns a Promise, it will be awaited.
        See page.exposeFunction(name, playwrightFunction) for page-only version.
        An example of adding an `md5` function to all pages in the context:

        Parameters
        ----------
        name : str
            Name of the function on the window object.
        binding : Callable
            Callback function that will be called in the Playwright&#39;s context.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.exposeFunction(
                    name=name, binding=self._wrap_handler(binding)
                )
            )
        )

    def route(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]],
        handler: typing.Callable[[&#34;Route&#34;, &#34;Request&#34;], typing.Any],
    ) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.route

        Routing provides the capability to modify network requests that are made by any page in the browser context.
        Once route is enabled, every request matching the url pattern will stall unless it&#39;s continued, fulfilled or aborted.
        An example of a naïve handler that aborts all image requests:
        or the same snippet using a regex pattern instead:
        Page routes (set up with page.route(url, handler)) take precedence over browser context routes when request matches both handlers.

        **NOTE** Enabling routing disables http cache.

        Parameters
        ----------
        url : Union[str, Pattern, typing.Callable[[str], bool]]
            A glob pattern, regex pattern or predicate receiving URL to match while routing.
        handler : typing.Callable[[playwright.network.Route, playwright.network.Request], typing.Any]
            handler function to route the request.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.route(
                    url=self._wrap_handler(url), handler=self._wrap_handler(handler)
                )
            )
        )

    def unroute(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]],
        handler: typing.Union[typing.Callable[[&#34;Route&#34;, &#34;Request&#34;], typing.Any]] = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.unroute

        Removes a route created with browserContext.route(url, handler). When `handler` is not specified, removes all routes for the `url`.

        Parameters
        ----------
        url : Union[str, Pattern, typing.Callable[[str], bool]]
            A glob pattern, regex pattern or predicate receiving URL used to register a routing with browserContext.route(url, handler).
        handler : Optional[typing.Callable[[playwright.network.Route, playwright.network.Request], typing.Any]]
            Handler function used to register a routing with browserContext.route(url, handler).
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.unroute(
                    url=self._wrap_handler(url), handler=self._wrap_handler(handler)
                )
            )
        )

    def waitForEvent(
        self,
        event: str,
        predicate: typing.Union[typing.Callable[[typing.Any], bool]] = None,
        timeout: int = None,
    ) -&gt; typing.Any:
        &#34;&#34;&#34;BrowserContext.waitForEvent

        Waits for event to fire and passes its value into the predicate function. Resolves when the predicate returns truthy value. Will throw an error if the context closes before the event
        is fired.

        Parameters
        ----------
        event : str
            Event name, same one would pass into `browserContext.on(event)`.

        Returns
        -------
        Any
            Promise which resolves to the event data value.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.waitForEvent(
                    event=event,
                    predicate=self._wrap_handler(predicate),
                    timeout=timeout,
                )
            )
        )

    def close(self) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.close

        Closes the browser context. All the pages that belong to the browser context
        will be closed.

        **NOTE** the default browser context cannot be closed.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.close()))

    def storageState(self) -&gt; StorageState:
        &#34;&#34;&#34;BrowserContext.storageState

        Returns storage state for this browser context, contains current cookies and local storage snapshot.

        Returns
        -------
        {&#34;cookies&#34;: List[Dict], &#34;origins&#34;: List[Dict]}
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.storageState()))

    def expect_event(
        self,
        event: str,
        predicate: typing.Union[typing.Callable[[typing.Any], bool]] = None,
        timeout: int = None,
    ) -&gt; EventContextManager:
        return EventContextManager(
            self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
        )

    def expect_page(
        self,
        predicate: typing.Union[typing.Callable[[&#34;Page&#34;], bool]] = None,
        timeout: int = None,
    ) -&gt; EventContextManager[&#34;Page&#34;]:
        event = &#34;page&#34;
        return EventContextManager(
            self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
        )


mapping.register(BrowserContextImpl, BrowserContext)


class CDPSession(SyncBase):
    def __init__(self, obj: CDPSessionImpl):
        super().__init__(obj)

    def send(self, method: str, params: typing.Dict = None) -&gt; typing.Dict:
        &#34;&#34;&#34;CDPSession.send

        Parameters
        ----------
        method : str
            protocol method name
        params : Optional[Dict]
            Optional method parameters

        Returns
        -------
        Dict
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.send(method=method, params=mapping.to_impl(params))
            )
        )

    def detach(self) -&gt; NoneType:
        &#34;&#34;&#34;CDPSession.detach

        Detaches the CDPSession from the target. Once detached, the CDPSession object won&#39;t emit any events and can&#39;t be used
        to send messages.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.detach()))


mapping.register(CDPSessionImpl, CDPSession)


class ChromiumBrowserContext(BrowserContext):
    def __init__(self, obj: ChromiumBrowserContextImpl):
        super().__init__(obj)

    def backgroundPages(self) -&gt; typing.List[&#34;Page&#34;]:
        &#34;&#34;&#34;ChromiumBrowserContext.backgroundPages

        Returns
        -------
        List[Page]
            All existing background pages in the context.
        &#34;&#34;&#34;
        return mapping.from_impl_list(self._impl_obj.backgroundPages())

    def serviceWorkers(self) -&gt; typing.List[&#34;Worker&#34;]:
        &#34;&#34;&#34;ChromiumBrowserContext.serviceWorkers

        Returns
        -------
        List[Worker]
            All existing service workers in the context.
        &#34;&#34;&#34;
        return mapping.from_impl_list(self._impl_obj.serviceWorkers())

    def newCDPSession(self, page: &#34;Page&#34;) -&gt; &#34;CDPSession&#34;:
        &#34;&#34;&#34;ChromiumBrowserContext.newCDPSession

        Parameters
        ----------
        page : Page
            Page to create new session for.

        Returns
        -------
        CDPSession
            Promise that resolves to the newly created session.
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(self._impl_obj.newCDPSession(page=page._impl_obj))
        )


mapping.register(ChromiumBrowserContextImpl, ChromiumBrowserContext)


class Browser(SyncBase):
    def __init__(self, obj: BrowserImpl):
        super().__init__(obj)

    @property
    def contexts(self) -&gt; typing.List[&#34;BrowserContext&#34;]:
        &#34;&#34;&#34;Browser.contexts

        Returns an array of all open browser contexts. In a newly created browser, this will return zero
        browser contexts.

        Returns
        -------
        List[BrowserContext]
        &#34;&#34;&#34;
        return mapping.from_impl_list(self._impl_obj.contexts)

    @property
    def version(self) -&gt; str:
        &#34;&#34;&#34;Browser.version

        Returns the browser version.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.version)

    def isConnected(self) -&gt; bool:
        &#34;&#34;&#34;Browser.isConnected

        Indicates that the browser is connected.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.isConnected())

    def newContext(
        self,
        viewport: typing.Union[IntSize, Literal[0]] = None,
        ignoreHTTPSErrors: bool = None,
        javaScriptEnabled: bool = None,
        bypassCSP: bool = None,
        userAgent: str = None,
        locale: str = None,
        timezoneId: str = None,
        geolocation: Geolocation = None,
        permissions: typing.List[str] = None,
        extraHTTPHeaders: typing.Union[typing.Dict[str, str]] = None,
        offline: bool = None,
        httpCredentials: Credentials = None,
        deviceScaleFactor: int = None,
        isMobile: bool = None,
        hasTouch: bool = None,
        colorScheme: Literal[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;] = None,
        acceptDownloads: bool = None,
        defaultBrowserType: str = None,
        proxy: ProxyServer = None,
        videosPath: str = None,
        videoSize: IntSize = None,
        recordHar: RecordHarOptions = None,
        recordVideo: RecordVideoOptions = None,
        storageState: SetStorageState = None,
    ) -&gt; &#34;BrowserContext&#34;:
        &#34;&#34;&#34;Browser.newContext

        Creates a new browser context. It won&#39;t share cookies/cache with other browser contexts.

        Parameters
        ----------
        viewport : Union[{&#34;width&#34;: int, &#34;height&#34;: int}, &#39;0&#39;, NoneType]
            Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. `null` disables the default viewport.
        ignoreHTTPSErrors : Optional[bool]
            Whether to ignore HTTPS errors during navigation. Defaults to `false`.
        javaScriptEnabled : Optional[bool]
            Whether or not to enable JavaScript in the context. Defaults to true.
        bypassCSP : Optional[bool]
            Toggles bypassing page&#39;s Content-Security-Policy.
        userAgent : Optional[str]
            Specific user agent to use in this context.
        locale : Optional[str]
            Specify user locale, for example `en-GB`, `de-DE`, etc. Locale will affect `navigator.language` value, `Accept-Language` request header value as well as number and date formatting rules.
        timezoneId : Optional[str]
            Changes the timezone of the context. See ICU’s `metaZones.txt` for a list of supported timezone IDs.
        geolocation : Optional[{&#34;latitude&#34;: float, &#34;longitude&#34;: float, &#34;accuracy&#34;: Optional[float]}]
        permissions : Optional[List[str]]
            A list of permissions to grant to all pages in this context. See browserContext.grantPermissions for more details.
        extraHTTPHeaders : Optional[Dict[str, str]]
            An object containing additional HTTP headers to be sent with every request. All header values must be strings.
        offline : Optional[bool]
            Whether to emulate network being offline. Defaults to `false`.
        httpCredentials : Optional[{&#34;username&#34;: str, &#34;password&#34;: str}]
            Credentials for HTTP authentication.
        deviceScaleFactor : Optional[int]
            Specify device scale factor (can be thought of as dpr). Defaults to `1`.
        isMobile : Optional[bool]
            Whether the `meta viewport` tag is taken into account and touch events are enabled. Defaults to `false`. Not supported in Firefox.
        hasTouch : Optional[bool]
            Specifies if viewport supports touch events. Defaults to false.
        colorScheme : Optional[Literal[&#39;dark&#39;, &#39;light&#39;, &#39;no-preference&#39;]]
            Emulates `&#39;prefers-colors-scheme&#39;` media feature, supported values are `&#39;light&#39;`, `&#39;dark&#39;`, `&#39;no-preference&#39;`. See page.emulateMedia(options) for more details. Defaults to &#39;`light`&#39;.
        acceptDownloads : Optional[bool]
            Whether to automatically download all the attachments. Defaults to `false` where all the downloads are canceled.
        proxy : Optional[{&#34;server&#34;: str, &#34;bypass&#34;: Optional[str], &#34;username&#34;: Optional[str], &#34;password&#34;: Optional[str]}]
            Network proxy settings to use with this context. Note that browser needs to be launched with the global proxy for this option to work. If all contexts override the proxy, global proxy will be never used and can be any string, for example `launch({ proxy: { server: &#39;per-context&#39; } })`.
        videosPath : Optional[str]
            **NOTE** Use `recordVideo` instead, it takes precedence over `videosPath`. Enables video recording for all pages to `videosPath` directory. If not specified, videos are not recorded. Make sure to await `browserContext.close` for videos to be saved.
        videoSize : Optional[{&#34;width&#34;: int, &#34;height&#34;: int}]
            **NOTE** Use `recordVideo` instead, it takes precedence over `videoSize`. Specifies dimensions of the automatically recorded video. Can only be used if `videosPath` is set. If not specified the size will be equal to `viewport`. If `viewport` is not configured explicitly the video size defaults to 1280x720. Actual picture of the page will be scaled down if necessary to fit specified size.
        recordHar : Optional[{&#34;omitContent&#34;: Optional[bool], &#34;path&#34;: str}]
            Enables HAR recording for all pages into `recordHar.path` file. If not specified, the HAR is not recorded. Make sure to await `browserContext.close` for the HAR to be saved.
        recordVideo : Optional[{&#34;dir&#34;: str, &#34;size&#34;: Optional[{&#34;width&#34;: int, &#34;height&#34;: int}]}]
            Enables video recording for all pages into `recordVideo.dir` directory. If not specified videos are not recorded. Make sure to await `browserContext.close` for videos to be saved.
        storageState : Optional[{&#34;cookies&#34;: Optional[List[Dict]], &#34;origins&#34;: Optional[List[Dict]]}]
            Populates context with given storage state. This method can be used to initialize context with logged-in information obtained via browserContext.storageState().

        Returns
        -------
        BrowserContext
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.newContext(
                    viewport=viewport,
                    ignoreHTTPSErrors=ignoreHTTPSErrors,
                    javaScriptEnabled=javaScriptEnabled,
                    bypassCSP=bypassCSP,
                    userAgent=userAgent,
                    locale=locale,
                    timezoneId=timezoneId,
                    geolocation=geolocation,
                    permissions=permissions,
                    extraHTTPHeaders=mapping.to_impl(extraHTTPHeaders),
                    offline=offline,
                    httpCredentials=httpCredentials,
                    deviceScaleFactor=deviceScaleFactor,
                    isMobile=isMobile,
                    hasTouch=hasTouch,
                    colorScheme=colorScheme,
                    acceptDownloads=acceptDownloads,
                    defaultBrowserType=defaultBrowserType,
                    proxy=proxy,
                    videosPath=videosPath,
                    videoSize=videoSize,
                    recordHar=recordHar,
                    recordVideo=recordVideo,
                    storageState=storageState,
                )
            )
        )

    def newPage(
        self,
        viewport: typing.Union[IntSize, Literal[0]] = None,
        ignoreHTTPSErrors: bool = None,
        javaScriptEnabled: bool = None,
        bypassCSP: bool = None,
        userAgent: str = None,
        locale: str = None,
        timezoneId: str = None,
        geolocation: Geolocation = None,
        permissions: typing.List[str] = None,
        extraHTTPHeaders: typing.Union[typing.Dict[str, str]] = None,
        offline: bool = None,
        httpCredentials: Credentials = None,
        deviceScaleFactor: int = None,
        isMobile: bool = None,
        hasTouch: bool = None,
        colorScheme: Literal[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;] = None,
        acceptDownloads: bool = None,
        defaultBrowserType: str = None,
        proxy: ProxyServer = None,
        videosPath: str = None,
        videoSize: IntSize = None,
        recordHar: RecordHarOptions = None,
        recordVideo: RecordVideoOptions = None,
        storageState: SetStorageState = None,
    ) -&gt; &#34;Page&#34;:
        &#34;&#34;&#34;Browser.newPage

        Creates a new page in a new browser context. Closing this page will close the context as well.
        This is a convenience API that should only be used for the single-page scenarios and short snippets. Production code and testing frameworks should explicitly create browser.newContext followed by the browserContext.newPage to control their exact life times.

        Parameters
        ----------
        viewport : Union[{&#34;width&#34;: int, &#34;height&#34;: int}, &#39;0&#39;, NoneType]
            Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. `null` disables the default viewport.
        ignoreHTTPSErrors : Optional[bool]
            Whether to ignore HTTPS errors during navigation. Defaults to `false`.
        javaScriptEnabled : Optional[bool]
            Whether or not to enable JavaScript in the context. Defaults to `true`.
        bypassCSP : Optional[bool]
            Toggles bypassing page&#39;s Content-Security-Policy.
        userAgent : Optional[str]
            Specific user agent to use in this context.
        locale : Optional[str]
            Specify user locale, for example `en-GB`, `de-DE`, etc. Locale will affect `navigator.language` value, `Accept-Language` request header value as well as number and date formatting rules.
        timezoneId : Optional[str]
            Changes the timezone of the context. See ICU’s `metaZones.txt` for a list of supported timezone IDs.
        geolocation : Optional[{&#34;latitude&#34;: float, &#34;longitude&#34;: float, &#34;accuracy&#34;: Optional[float]}]
        permissions : Optional[List[str]]
            A list of permissions to grant to all pages in this context. See browserContext.grantPermissions for more details.
        extraHTTPHeaders : Optional[Dict[str, str]]
            An object containing additional HTTP headers to be sent with every request. All header values must be strings.
        offline : Optional[bool]
            Whether to emulate network being offline. Defaults to `false`.
        httpCredentials : Optional[{&#34;username&#34;: str, &#34;password&#34;: str}]
            Credentials for HTTP authentication.
        deviceScaleFactor : Optional[int]
            Specify device scale factor (can be thought of as dpr). Defaults to `1`.
        isMobile : Optional[bool]
            Whether the `meta viewport` tag is taken into account and touch events are enabled. Defaults to `false`. Not supported in Firefox.
        hasTouch : Optional[bool]
            Specifies if viewport supports touch events. Defaults to false.
        colorScheme : Optional[Literal[&#39;dark&#39;, &#39;light&#39;, &#39;no-preference&#39;]]
            Emulates `&#39;prefers-colors-scheme&#39;` media feature, supported values are `&#39;light&#39;`, `&#39;dark&#39;`, `&#39;no-preference&#39;`. See page.emulateMedia(options) for more details. Defaults to &#39;`light`&#39;.
        acceptDownloads : Optional[bool]
            Whether to automatically download all the attachments. Defaults to `false` where all the downloads are canceled.
        proxy : Optional[{&#34;server&#34;: str, &#34;bypass&#34;: Optional[str], &#34;username&#34;: Optional[str], &#34;password&#34;: Optional[str]}]
            Network proxy settings to use with this context. Note that browser needs to be launched with the global proxy for this option to work. If all contexts override the proxy, global proxy will be never used and can be any string, for example `launch({ proxy: { server: &#39;per-context&#39; } })`.
        videosPath : Optional[str]
            **NOTE** Use `recordVideo` instead, it takes precedence over `videosPath`. Enables video recording for all pages to `videosPath` directory. If not specified, videos are not recorded. Make sure to await `page.close` for videos to be saved.
        videoSize : Optional[{&#34;width&#34;: int, &#34;height&#34;: int}]
            **NOTE** Use `recordVideo` instead, it takes precedence over `videoSize`. Specifies dimensions of the automatically recorded video. Can only be used if `videosPath` is set. If not specified the size will be equal to `viewport`. If `viewport` is not configured explicitly the video size defaults to 1280x720. Actual picture of the page will be scaled down if necessary to fit specified size.
        recordHar : Optional[{&#34;omitContent&#34;: Optional[bool], &#34;path&#34;: str}]
            Enables HAR recording for all pages into `recordHar.path` file. If not specified, the HAR is not recorded. Make sure to await `page.close` for the HAR to be saved.
        recordVideo : Optional[{&#34;dir&#34;: str, &#34;size&#34;: Optional[{&#34;width&#34;: int, &#34;height&#34;: int}]}]
            Enables video recording for all pages into `recordVideo.dir` directory. If not specified videos are not recorded. Make sure to await `page.close` for videos to be saved.
        storageState : Optional[{&#34;cookies&#34;: Optional[List[Dict]], &#34;origins&#34;: Optional[List[Dict]]}]
            Populates context with given storage state. This method can be used to initialize context with logged-in information obtained via browserContext.storageState().

        Returns
        -------
        Page
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.newPage(
                    viewport=viewport,
                    ignoreHTTPSErrors=ignoreHTTPSErrors,
                    javaScriptEnabled=javaScriptEnabled,
                    bypassCSP=bypassCSP,
                    userAgent=userAgent,
                    locale=locale,
                    timezoneId=timezoneId,
                    geolocation=geolocation,
                    permissions=permissions,
                    extraHTTPHeaders=mapping.to_impl(extraHTTPHeaders),
                    offline=offline,
                    httpCredentials=httpCredentials,
                    deviceScaleFactor=deviceScaleFactor,
                    isMobile=isMobile,
                    hasTouch=hasTouch,
                    colorScheme=colorScheme,
                    acceptDownloads=acceptDownloads,
                    defaultBrowserType=defaultBrowserType,
                    proxy=proxy,
                    videosPath=videosPath,
                    videoSize=videoSize,
                    recordHar=recordHar,
                    recordVideo=recordVideo,
                    storageState=storageState,
                )
            )
        )

    def close(self) -&gt; NoneType:
        &#34;&#34;&#34;Browser.close

        In case this browser is obtained using browserType.launch, closes the browser and all of its pages (if any were opened).
        In case this browser is obtained using browserType.connect, clears all created contexts belonging to this browser and disconnects from the browser server.
        The Browser object itself is considered to be disposed and cannot be used anymore.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.close()))


mapping.register(BrowserImpl, Browser)


class BrowserType(SyncBase):
    def __init__(self, obj: BrowserTypeImpl):
        super().__init__(obj)

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;BrowserType.name

        Returns browser name. For example: `&#39;chromium&#39;`, `&#39;webkit&#39;` or `&#39;firefox&#39;`.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.name)

    @property
    def executablePath(self) -&gt; str:
        &#34;&#34;&#34;BrowserType.executablePath

        Returns
        -------
        str
            A path where Playwright expects to find a bundled browser executable.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.executablePath)

    def launch(
        self,
        executablePath: typing.Union[str, pathlib.Path] = None,
        args: typing.List[str] = None,
        ignoreDefaultArgs: typing.Union[bool, typing.List[str]] = None,
        handleSIGINT: bool = None,
        handleSIGTERM: bool = None,
        handleSIGHUP: bool = None,
        timeout: int = None,
        env: typing.Union[typing.Dict[str, typing.Union[str, int, bool]]] = None,
        headless: bool = None,
        devtools: bool = None,
        proxy: ProxyServer = None,
        downloadsPath: typing.Union[str, pathlib.Path] = None,
        slowMo: int = None,
        chromiumSandbox: bool = None,
        firefoxUserPrefs: typing.Union[
            typing.Dict[str, typing.Union[str, int, bool]]
        ] = None,
    ) -&gt; &#34;Browser&#34;:
        &#34;&#34;&#34;BrowserType.launch

        You can use `ignoreDefaultArgs` to filter out `--mute-audio` from default arguments:

        **Chromium-only** Playwright can also be used to control the Chrome browser, but it works best with the version of Chromium it is bundled with. There is no guarantee it will work with any other version. Use `executablePath` option with extreme caution.
        If Google Chrome (rather than Chromium) is preferred, a Chrome Canary or Dev Channel build is suggested.
        In browserType.launch([options]) above, any mention of Chromium also applies to Chrome.
        See `this article` for a description of the differences between Chromium and Chrome. `This article` describes some differences for Linux users.

        Parameters
        ----------
        executablePath : Union[str, pathlib.Path, NoneType]
            Path to a browser executable to run instead of the bundled one. If `executablePath` is a relative path, then it is resolved relative to current working directory. Note that Playwright only works with the bundled Chromium, Firefox or WebKit, use at your own risk.
        args : Optional[List[str]]
            Additional arguments to pass to the browser instance. The list of Chromium flags can be found here.
        ignoreDefaultArgs : Union[bool, List[str], NoneType]
            If `true`, Playwright does not pass its own configurations args and only uses the ones from `args`. If an array is given, then filters out the given default arguments. Dangerous option; use with care. Defaults to `false`.
        handleSIGINT : Optional[bool]
            Close the browser process on Ctrl-C. Defaults to `true`.
        handleSIGTERM : Optional[bool]
            Close the browser process on SIGTERM. Defaults to `true`.
        handleSIGHUP : Optional[bool]
            Close the browser process on SIGHUP. Defaults to `true`.
        timeout : Optional[int]
            Maximum time in milliseconds to wait for the browser instance to start. Defaults to `30000` (30 seconds). Pass `0` to disable timeout.
        env : Optional[Dict[str, Union[str, int, bool]]]
            Specify environment variables that will be visible to the browser. Defaults to `process.env`.
        headless : Optional[bool]
            Whether to run browser in headless mode. More details for Chromium and Firefox. Defaults to `true` unless the `devtools` option is `true`.
        devtools : Optional[bool]
            **Chromium-only** Whether to auto-open a Developer Tools panel for each tab. If this option is `true`, the `headless` option will be set `false`.
        proxy : Optional[{&#34;server&#34;: str, &#34;bypass&#34;: Optional[str], &#34;username&#34;: Optional[str], &#34;password&#34;: Optional[str]}]
            Network proxy settings.
        downloadsPath : Union[str, pathlib.Path, NoneType]
            If specified, accepted downloads are downloaded into this directory. Otherwise, temporary directory is created and is deleted when browser is closed.
        slowMo : Optional[int]
            Slows down Playwright operations by the specified amount of milliseconds. Useful so that you can see what is going on.
        chromiumSandbox : Optional[bool]
            Enable Chromium sandboxing. Defaults to `false`.
        firefoxUserPrefs : Optional[Dict[str, Union[str, int, bool]]]
            Firefox user preferences. Learn more about the Firefox user preferences at `about:config`.

        Returns
        -------
        Browser
            Promise which resolves to browser instance.
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.launch(
                    executablePath=executablePath,
                    args=args,
                    ignoreDefaultArgs=ignoreDefaultArgs,
                    handleSIGINT=handleSIGINT,
                    handleSIGTERM=handleSIGTERM,
                    handleSIGHUP=handleSIGHUP,
                    timeout=timeout,
                    env=mapping.to_impl(env),
                    headless=headless,
                    devtools=devtools,
                    proxy=proxy,
                    downloadsPath=downloadsPath,
                    slowMo=slowMo,
                    chromiumSandbox=chromiumSandbox,
                    firefoxUserPrefs=mapping.to_impl(firefoxUserPrefs),
                )
            )
        )

    def launchPersistentContext(
        self,
        userDataDir: typing.Union[str, pathlib.Path],
        executablePath: typing.Union[str, pathlib.Path] = None,
        args: typing.List[str] = None,
        ignoreDefaultArgs: typing.Union[bool, typing.List[str]] = None,
        handleSIGINT: bool = None,
        handleSIGTERM: bool = None,
        handleSIGHUP: bool = None,
        timeout: int = None,
        env: typing.Union[typing.Dict[str, typing.Union[str, int, bool]]] = None,
        headless: bool = None,
        devtools: bool = None,
        proxy: ProxyServer = None,
        downloadsPath: typing.Union[str, pathlib.Path] = None,
        slowMo: int = None,
        viewport: typing.Union[IntSize, Literal[0]] = None,
        ignoreHTTPSErrors: bool = None,
        javaScriptEnabled: bool = None,
        bypassCSP: bool = None,
        userAgent: str = None,
        locale: str = None,
        timezoneId: str = None,
        geolocation: Geolocation = None,
        permissions: typing.List[str] = None,
        extraHTTPHeaders: typing.Union[typing.Dict[str, str]] = None,
        offline: bool = None,
        httpCredentials: Credentials = None,
        deviceScaleFactor: int = None,
        isMobile: bool = None,
        hasTouch: bool = None,
        colorScheme: Literal[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;] = None,
        acceptDownloads: bool = None,
        chromiumSandbox: bool = None,
        videosPath: str = None,
        videoSize: IntSize = None,
        recordHar: RecordHarOptions = None,
        recordVideo: RecordVideoOptions = None,
    ) -&gt; &#34;BrowserContext&#34;:
        &#34;&#34;&#34;BrowserType.launchPersistentContext

        Launches browser that uses persistent storage located at `userDataDir` and returns the only context. Closing this context will automatically close the browser.

        Parameters
        ----------
        userDataDir : Union[str, pathlib.Path]
            Path to a User Data Directory, which stores browser session data like cookies and local storage. More details for Chromium and Firefox.
        executablePath : Union[str, pathlib.Path, NoneType]
            Path to a browser executable to run instead of the bundled one. If `executablePath` is a relative path, then it is resolved relative to current working directory. **BEWARE**: Playwright is only guaranteed to work with the bundled Chromium, Firefox or WebKit, use at your own risk.
        args : Optional[List[str]]
            Additional arguments to pass to the browser instance. The list of Chromium flags can be found here.
        ignoreDefaultArgs : Union[bool, List[str], NoneType]
            If `true`, then do not use any of the default arguments. If an array is given, then filter out the given default arguments. Dangerous option; use with care. Defaults to `false`.
        handleSIGINT : Optional[bool]
            Close the browser process on Ctrl-C. Defaults to `true`.
        handleSIGTERM : Optional[bool]
            Close the browser process on SIGTERM. Defaults to `true`.
        handleSIGHUP : Optional[bool]
            Close the browser process on SIGHUP. Defaults to `true`.
        timeout : Optional[int]
            Maximum time in milliseconds to wait for the browser instance to start. Defaults to `30000` (30 seconds). Pass `0` to disable timeout.
        env : Optional[Dict[str, Union[str, int, bool]]]
            Specify environment variables that will be visible to the browser. Defaults to `process.env`.
        headless : Optional[bool]
            Whether to run browser in headless mode. More details for Chromium and Firefox. Defaults to `true` unless the `devtools` option is `true`.
        devtools : Optional[bool]
            **Chromium-only** Whether to auto-open a Developer Tools panel for each tab. If this option is `true`, the `headless` option will be set `false`.
        proxy : Optional[{&#34;server&#34;: str, &#34;bypass&#34;: Optional[str], &#34;username&#34;: Optional[str], &#34;password&#34;: Optional[str]}]
            Network proxy settings.
        downloadsPath : Union[str, pathlib.Path, NoneType]
            If specified, accepted downloads are downloaded into this directory. Otherwise, temporary directory is created and is deleted when browser is closed.
        slowMo : Optional[int]
            Slows down Playwright operations by the specified amount of milliseconds. Useful so that you can see what is going on. Defaults to 0.
        viewport : Union[{&#34;width&#34;: int, &#34;height&#34;: int}, &#39;0&#39;, NoneType]
            Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. `null` disables the default viewport.
        ignoreHTTPSErrors : Optional[bool]
            Whether to ignore HTTPS errors during navigation. Defaults to `false`.
        javaScriptEnabled : Optional[bool]
            Whether or not to enable JavaScript in the context. Defaults to true.
        bypassCSP : Optional[bool]
            Toggles bypassing page&#39;s Content-Security-Policy.
        userAgent : Optional[str]
            Specific user agent to use in this context.
        locale : Optional[str]
            Specify user locale, for example `en-GB`, `de-DE`, etc. Locale will affect `navigator.language` value, `Accept-Language` request header value as well as number and date formatting rules.
        timezoneId : Optional[str]
            Changes the timezone of the context. See ICU’s `metaZones.txt` for a list of supported timezone IDs.
        geolocation : Optional[{&#34;latitude&#34;: float, &#34;longitude&#34;: float, &#34;accuracy&#34;: Optional[float]}]
        permissions : Optional[List[str]]
            A list of permissions to grant to all pages in this context. See browserContext.grantPermissions for more details.
        extraHTTPHeaders : Optional[Dict[str, str]]
            An object containing additional HTTP headers to be sent with every request. All header values must be strings.
        offline : Optional[bool]
            Whether to emulate network being offline. Defaults to `false`.
        httpCredentials : Optional[{&#34;username&#34;: str, &#34;password&#34;: str}]
            Credentials for HTTP authentication.
        deviceScaleFactor : Optional[int]
            Specify device scale factor (can be thought of as dpr). Defaults to `1`.
        isMobile : Optional[bool]
            Whether the `meta viewport` tag is taken into account and touch events are enabled. Defaults to `false`. Not supported in Firefox.
        hasTouch : Optional[bool]
            Specifies if viewport supports touch events. Defaults to false.
        colorScheme : Optional[Literal[&#39;dark&#39;, &#39;light&#39;, &#39;no-preference&#39;]]
            Emulates `&#39;prefers-colors-scheme&#39;` media feature, supported values are `&#39;light&#39;`, `&#39;dark&#39;`, `&#39;no-preference&#39;`. See page.emulateMedia(options) for more details. Defaults to &#39;`light`&#39;.
        acceptDownloads : Optional[bool]
            Whether to automatically download all the attachments. Defaults to `false` where all the downloads are canceled.
        chromiumSandbox : Optional[bool]
            Enable Chromium sandboxing. Defaults to `true`.
        videosPath : Optional[str]
            **NOTE** Use `recordVideo` instead, it takes precedence over `videosPath`. Enables video recording for all pages to `videosPath` directory. If not specified, videos are not recorded. Make sure to await `browserContext.close` for videos to be saved.
        videoSize : Optional[{&#34;width&#34;: int, &#34;height&#34;: int}]
            **NOTE** Use `recordVideo` instead, it takes precedence over `videoSize`. Specifies dimensions of the automatically recorded video. Can only be used if `videosPath` is set. If not specified the size will be equal to `viewport`. If `viewport` is not configured explicitly the video size defaults to 1280x720. Actual picture of the page will be scaled down if necessary to fit specified size.
        recordHar : Optional[{&#34;omitContent&#34;: Optional[bool], &#34;path&#34;: str}]
            Enables HAR recording for all the pages into `recordHar.path` file. If not specified, HAR is not recorded. Make sure to await `page.close` for HAR to be saved.
        recordVideo : Optional[{&#34;dir&#34;: str, &#34;size&#34;: Optional[{&#34;width&#34;: int, &#34;height&#34;: int}]}]
            Enables video recording for all pages into `recordVideo.dir` directory. If not specified videos are not recorded. Make sure to await `browserContext.close` for videos to be saved.

        Returns
        -------
        BrowserContext
            Promise that resolves to the persistent browser context instance.
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.launchPersistentContext(
                    userDataDir=userDataDir,
                    executablePath=executablePath,
                    args=args,
                    ignoreDefaultArgs=ignoreDefaultArgs,
                    handleSIGINT=handleSIGINT,
                    handleSIGTERM=handleSIGTERM,
                    handleSIGHUP=handleSIGHUP,
                    timeout=timeout,
                    env=mapping.to_impl(env),
                    headless=headless,
                    devtools=devtools,
                    proxy=proxy,
                    downloadsPath=downloadsPath,
                    slowMo=slowMo,
                    viewport=viewport,
                    ignoreHTTPSErrors=ignoreHTTPSErrors,
                    javaScriptEnabled=javaScriptEnabled,
                    bypassCSP=bypassCSP,
                    userAgent=userAgent,
                    locale=locale,
                    timezoneId=timezoneId,
                    geolocation=geolocation,
                    permissions=permissions,
                    extraHTTPHeaders=mapping.to_impl(extraHTTPHeaders),
                    offline=offline,
                    httpCredentials=httpCredentials,
                    deviceScaleFactor=deviceScaleFactor,
                    isMobile=isMobile,
                    hasTouch=hasTouch,
                    colorScheme=colorScheme,
                    acceptDownloads=acceptDownloads,
                    chromiumSandbox=chromiumSandbox,
                    videosPath=videosPath,
                    videoSize=videoSize,
                    recordHar=recordHar,
                    recordVideo=recordVideo,
                )
            )
        )


mapping.register(BrowserTypeImpl, BrowserType)


class Playwright(SyncBase):
    def __init__(self, obj: PlaywrightImpl):
        super().__init__(obj)

    @property
    def chromium(self) -&gt; &#34;BrowserType&#34;:
        return mapping.from_impl(self._impl_obj.chromium)

    @property
    def firefox(self) -&gt; &#34;BrowserType&#34;:
        return mapping.from_impl(self._impl_obj.firefox)

    @property
    def webkit(self) -&gt; &#34;BrowserType&#34;:
        return mapping.from_impl(self._impl_obj.webkit)

    @property
    def selectors(self) -&gt; &#34;Selectors&#34;:
        return mapping.from_impl(self._impl_obj.selectors)

    @property
    def devices(self) -&gt; typing.Dict[str, DeviceDescriptor]:
        return mapping.from_maybe_impl(self._impl_obj.devices)

    def stop(self) -&gt; NoneType:
        return mapping.from_maybe_impl(self._impl_obj.stop())


mapping.register(PlaywrightImpl, Playwright)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="playwright.sync_api.Accessibility"><code class="flex name class">
<span>class <span class="ident">Accessibility</span></span>
<span>(</span><span>obj: playwright.accessibility.Accessibility)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Accessibility(SyncBase):
    def __init__(self, obj: AccessibilityImpl):
        super().__init__(obj)

    def snapshot(
        self, interestingOnly: bool = None, root: &#34;ElementHandle&#34; = None
    ) -&gt; typing.Union[typing.Dict, NoneType]:
        &#34;&#34;&#34;Accessibility.snapshot

        Captures the current state of the accessibility tree. The returned object represents the root accessible node of the page.

        **NOTE** The Chromium accessibility tree contains nodes that go unused on most platforms and by
        most screen readers. Playwright will discard them as well for an easier to process tree,
        unless `interestingOnly` is set to `false`.

        An example of dumping the entire accessibility tree:
        An example of logging the focused node&#39;s name:

        Parameters
        ----------
        interestingOnly : Optional[bool]
            Prune uninteresting nodes from the tree. Defaults to `true`.
        root : Optional[ElementHandle]
            The root DOM element for the snapshot. Defaults to the whole page.

        Returns
        -------
        Optional[Dict]
            An AXNode object with the following properties:
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.snapshot(
                    interestingOnly=interestingOnly, root=mapping.to_impl(root)
                )
            )
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright.sync_base.SyncBase</li>
<li>playwright.impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="playwright.sync_api.Accessibility.snapshot"><code class="name flex">
<span>def <span class="ident">snapshot</span></span>(<span>self, interestingOnly: bool = None, root: <a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a> = None) ‑> Union[Dict, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Accessibility.snapshot</p>
<p>Captures the current state of the accessibility tree. The returned object represents the root accessible node of the page.</p>
<p><strong>NOTE</strong> The Chromium accessibility tree contains nodes that go unused on most platforms and by
most screen readers. Playwright will discard them as well for an easier to process tree,
unless <code>interestingOnly</code> is set to <code>false</code>.</p>
<p>An example of dumping the entire accessibility tree:
An example of logging the focused node's name:</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>interestingOnly</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Prune uninteresting nodes from the tree. Defaults to <code>true</code>.</dd>
<dt><strong><code>root</code></strong> :&ensp;<code>Optional[<a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a>]</code></dt>
<dd>The root DOM element for the snapshot. Defaults to the whole page.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[Dict]</code></dt>
<dd>An AXNode object with the following properties:</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def snapshot(
    self, interestingOnly: bool = None, root: &#34;ElementHandle&#34; = None
) -&gt; typing.Union[typing.Dict, NoneType]:
    &#34;&#34;&#34;Accessibility.snapshot

    Captures the current state of the accessibility tree. The returned object represents the root accessible node of the page.

    **NOTE** The Chromium accessibility tree contains nodes that go unused on most platforms and by
    most screen readers. Playwright will discard them as well for an easier to process tree,
    unless `interestingOnly` is set to `false`.

    An example of dumping the entire accessibility tree:
    An example of logging the focused node&#39;s name:

    Parameters
    ----------
    interestingOnly : Optional[bool]
        Prune uninteresting nodes from the tree. Defaults to `true`.
    root : Optional[ElementHandle]
        The root DOM element for the snapshot. Defaults to the whole page.

    Returns
    -------
    Optional[Dict]
        An AXNode object with the following properties:
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.snapshot(
                interestingOnly=interestingOnly, root=mapping.to_impl(root)
            )
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.sync_api.BindingCall"><code class="flex name class">
<span>class <span class="ident">BindingCall</span></span>
<span>(</span><span>obj: playwright.page.BindingCall)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BindingCall(SyncBase):
    def __init__(self, obj: BindingCallImpl):
        super().__init__(obj)

    def call(self, func: typing.Callable) -&gt; NoneType:
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.call(func=self._wrap_handler(func)))
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright.sync_base.SyncBase</li>
<li>playwright.impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="playwright.sync_api.BindingCall.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, func: Callable) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, func: typing.Callable) -&gt; NoneType:
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.call(func=self._wrap_handler(func)))
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.sync_api.Browser"><code class="flex name class">
<span>class <span class="ident">Browser</span></span>
<span>(</span><span>obj: playwright.browser.Browser)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Browser(SyncBase):
    def __init__(self, obj: BrowserImpl):
        super().__init__(obj)

    @property
    def contexts(self) -&gt; typing.List[&#34;BrowserContext&#34;]:
        &#34;&#34;&#34;Browser.contexts

        Returns an array of all open browser contexts. In a newly created browser, this will return zero
        browser contexts.

        Returns
        -------
        List[BrowserContext]
        &#34;&#34;&#34;
        return mapping.from_impl_list(self._impl_obj.contexts)

    @property
    def version(self) -&gt; str:
        &#34;&#34;&#34;Browser.version

        Returns the browser version.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.version)

    def isConnected(self) -&gt; bool:
        &#34;&#34;&#34;Browser.isConnected

        Indicates that the browser is connected.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.isConnected())

    def newContext(
        self,
        viewport: typing.Union[IntSize, Literal[0]] = None,
        ignoreHTTPSErrors: bool = None,
        javaScriptEnabled: bool = None,
        bypassCSP: bool = None,
        userAgent: str = None,
        locale: str = None,
        timezoneId: str = None,
        geolocation: Geolocation = None,
        permissions: typing.List[str] = None,
        extraHTTPHeaders: typing.Union[typing.Dict[str, str]] = None,
        offline: bool = None,
        httpCredentials: Credentials = None,
        deviceScaleFactor: int = None,
        isMobile: bool = None,
        hasTouch: bool = None,
        colorScheme: Literal[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;] = None,
        acceptDownloads: bool = None,
        defaultBrowserType: str = None,
        proxy: ProxyServer = None,
        videosPath: str = None,
        videoSize: IntSize = None,
        recordHar: RecordHarOptions = None,
        recordVideo: RecordVideoOptions = None,
        storageState: SetStorageState = None,
    ) -&gt; &#34;BrowserContext&#34;:
        &#34;&#34;&#34;Browser.newContext

        Creates a new browser context. It won&#39;t share cookies/cache with other browser contexts.

        Parameters
        ----------
        viewport : Union[{&#34;width&#34;: int, &#34;height&#34;: int}, &#39;0&#39;, NoneType]
            Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. `null` disables the default viewport.
        ignoreHTTPSErrors : Optional[bool]
            Whether to ignore HTTPS errors during navigation. Defaults to `false`.
        javaScriptEnabled : Optional[bool]
            Whether or not to enable JavaScript in the context. Defaults to true.
        bypassCSP : Optional[bool]
            Toggles bypassing page&#39;s Content-Security-Policy.
        userAgent : Optional[str]
            Specific user agent to use in this context.
        locale : Optional[str]
            Specify user locale, for example `en-GB`, `de-DE`, etc. Locale will affect `navigator.language` value, `Accept-Language` request header value as well as number and date formatting rules.
        timezoneId : Optional[str]
            Changes the timezone of the context. See ICU’s `metaZones.txt` for a list of supported timezone IDs.
        geolocation : Optional[{&#34;latitude&#34;: float, &#34;longitude&#34;: float, &#34;accuracy&#34;: Optional[float]}]
        permissions : Optional[List[str]]
            A list of permissions to grant to all pages in this context. See browserContext.grantPermissions for more details.
        extraHTTPHeaders : Optional[Dict[str, str]]
            An object containing additional HTTP headers to be sent with every request. All header values must be strings.
        offline : Optional[bool]
            Whether to emulate network being offline. Defaults to `false`.
        httpCredentials : Optional[{&#34;username&#34;: str, &#34;password&#34;: str}]
            Credentials for HTTP authentication.
        deviceScaleFactor : Optional[int]
            Specify device scale factor (can be thought of as dpr). Defaults to `1`.
        isMobile : Optional[bool]
            Whether the `meta viewport` tag is taken into account and touch events are enabled. Defaults to `false`. Not supported in Firefox.
        hasTouch : Optional[bool]
            Specifies if viewport supports touch events. Defaults to false.
        colorScheme : Optional[Literal[&#39;dark&#39;, &#39;light&#39;, &#39;no-preference&#39;]]
            Emulates `&#39;prefers-colors-scheme&#39;` media feature, supported values are `&#39;light&#39;`, `&#39;dark&#39;`, `&#39;no-preference&#39;`. See page.emulateMedia(options) for more details. Defaults to &#39;`light`&#39;.
        acceptDownloads : Optional[bool]
            Whether to automatically download all the attachments. Defaults to `false` where all the downloads are canceled.
        proxy : Optional[{&#34;server&#34;: str, &#34;bypass&#34;: Optional[str], &#34;username&#34;: Optional[str], &#34;password&#34;: Optional[str]}]
            Network proxy settings to use with this context. Note that browser needs to be launched with the global proxy for this option to work. If all contexts override the proxy, global proxy will be never used and can be any string, for example `launch({ proxy: { server: &#39;per-context&#39; } })`.
        videosPath : Optional[str]
            **NOTE** Use `recordVideo` instead, it takes precedence over `videosPath`. Enables video recording for all pages to `videosPath` directory. If not specified, videos are not recorded. Make sure to await `browserContext.close` for videos to be saved.
        videoSize : Optional[{&#34;width&#34;: int, &#34;height&#34;: int}]
            **NOTE** Use `recordVideo` instead, it takes precedence over `videoSize`. Specifies dimensions of the automatically recorded video. Can only be used if `videosPath` is set. If not specified the size will be equal to `viewport`. If `viewport` is not configured explicitly the video size defaults to 1280x720. Actual picture of the page will be scaled down if necessary to fit specified size.
        recordHar : Optional[{&#34;omitContent&#34;: Optional[bool], &#34;path&#34;: str}]
            Enables HAR recording for all pages into `recordHar.path` file. If not specified, the HAR is not recorded. Make sure to await `browserContext.close` for the HAR to be saved.
        recordVideo : Optional[{&#34;dir&#34;: str, &#34;size&#34;: Optional[{&#34;width&#34;: int, &#34;height&#34;: int}]}]
            Enables video recording for all pages into `recordVideo.dir` directory. If not specified videos are not recorded. Make sure to await `browserContext.close` for videos to be saved.
        storageState : Optional[{&#34;cookies&#34;: Optional[List[Dict]], &#34;origins&#34;: Optional[List[Dict]]}]
            Populates context with given storage state. This method can be used to initialize context with logged-in information obtained via browserContext.storageState().

        Returns
        -------
        BrowserContext
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.newContext(
                    viewport=viewport,
                    ignoreHTTPSErrors=ignoreHTTPSErrors,
                    javaScriptEnabled=javaScriptEnabled,
                    bypassCSP=bypassCSP,
                    userAgent=userAgent,
                    locale=locale,
                    timezoneId=timezoneId,
                    geolocation=geolocation,
                    permissions=permissions,
                    extraHTTPHeaders=mapping.to_impl(extraHTTPHeaders),
                    offline=offline,
                    httpCredentials=httpCredentials,
                    deviceScaleFactor=deviceScaleFactor,
                    isMobile=isMobile,
                    hasTouch=hasTouch,
                    colorScheme=colorScheme,
                    acceptDownloads=acceptDownloads,
                    defaultBrowserType=defaultBrowserType,
                    proxy=proxy,
                    videosPath=videosPath,
                    videoSize=videoSize,
                    recordHar=recordHar,
                    recordVideo=recordVideo,
                    storageState=storageState,
                )
            )
        )

    def newPage(
        self,
        viewport: typing.Union[IntSize, Literal[0]] = None,
        ignoreHTTPSErrors: bool = None,
        javaScriptEnabled: bool = None,
        bypassCSP: bool = None,
        userAgent: str = None,
        locale: str = None,
        timezoneId: str = None,
        geolocation: Geolocation = None,
        permissions: typing.List[str] = None,
        extraHTTPHeaders: typing.Union[typing.Dict[str, str]] = None,
        offline: bool = None,
        httpCredentials: Credentials = None,
        deviceScaleFactor: int = None,
        isMobile: bool = None,
        hasTouch: bool = None,
        colorScheme: Literal[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;] = None,
        acceptDownloads: bool = None,
        defaultBrowserType: str = None,
        proxy: ProxyServer = None,
        videosPath: str = None,
        videoSize: IntSize = None,
        recordHar: RecordHarOptions = None,
        recordVideo: RecordVideoOptions = None,
        storageState: SetStorageState = None,
    ) -&gt; &#34;Page&#34;:
        &#34;&#34;&#34;Browser.newPage

        Creates a new page in a new browser context. Closing this page will close the context as well.
        This is a convenience API that should only be used for the single-page scenarios and short snippets. Production code and testing frameworks should explicitly create browser.newContext followed by the browserContext.newPage to control their exact life times.

        Parameters
        ----------
        viewport : Union[{&#34;width&#34;: int, &#34;height&#34;: int}, &#39;0&#39;, NoneType]
            Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. `null` disables the default viewport.
        ignoreHTTPSErrors : Optional[bool]
            Whether to ignore HTTPS errors during navigation. Defaults to `false`.
        javaScriptEnabled : Optional[bool]
            Whether or not to enable JavaScript in the context. Defaults to `true`.
        bypassCSP : Optional[bool]
            Toggles bypassing page&#39;s Content-Security-Policy.
        userAgent : Optional[str]
            Specific user agent to use in this context.
        locale : Optional[str]
            Specify user locale, for example `en-GB`, `de-DE`, etc. Locale will affect `navigator.language` value, `Accept-Language` request header value as well as number and date formatting rules.
        timezoneId : Optional[str]
            Changes the timezone of the context. See ICU’s `metaZones.txt` for a list of supported timezone IDs.
        geolocation : Optional[{&#34;latitude&#34;: float, &#34;longitude&#34;: float, &#34;accuracy&#34;: Optional[float]}]
        permissions : Optional[List[str]]
            A list of permissions to grant to all pages in this context. See browserContext.grantPermissions for more details.
        extraHTTPHeaders : Optional[Dict[str, str]]
            An object containing additional HTTP headers to be sent with every request. All header values must be strings.
        offline : Optional[bool]
            Whether to emulate network being offline. Defaults to `false`.
        httpCredentials : Optional[{&#34;username&#34;: str, &#34;password&#34;: str}]
            Credentials for HTTP authentication.
        deviceScaleFactor : Optional[int]
            Specify device scale factor (can be thought of as dpr). Defaults to `1`.
        isMobile : Optional[bool]
            Whether the `meta viewport` tag is taken into account and touch events are enabled. Defaults to `false`. Not supported in Firefox.
        hasTouch : Optional[bool]
            Specifies if viewport supports touch events. Defaults to false.
        colorScheme : Optional[Literal[&#39;dark&#39;, &#39;light&#39;, &#39;no-preference&#39;]]
            Emulates `&#39;prefers-colors-scheme&#39;` media feature, supported values are `&#39;light&#39;`, `&#39;dark&#39;`, `&#39;no-preference&#39;`. See page.emulateMedia(options) for more details. Defaults to &#39;`light`&#39;.
        acceptDownloads : Optional[bool]
            Whether to automatically download all the attachments. Defaults to `false` where all the downloads are canceled.
        proxy : Optional[{&#34;server&#34;: str, &#34;bypass&#34;: Optional[str], &#34;username&#34;: Optional[str], &#34;password&#34;: Optional[str]}]
            Network proxy settings to use with this context. Note that browser needs to be launched with the global proxy for this option to work. If all contexts override the proxy, global proxy will be never used and can be any string, for example `launch({ proxy: { server: &#39;per-context&#39; } })`.
        videosPath : Optional[str]
            **NOTE** Use `recordVideo` instead, it takes precedence over `videosPath`. Enables video recording for all pages to `videosPath` directory. If not specified, videos are not recorded. Make sure to await `page.close` for videos to be saved.
        videoSize : Optional[{&#34;width&#34;: int, &#34;height&#34;: int}]
            **NOTE** Use `recordVideo` instead, it takes precedence over `videoSize`. Specifies dimensions of the automatically recorded video. Can only be used if `videosPath` is set. If not specified the size will be equal to `viewport`. If `viewport` is not configured explicitly the video size defaults to 1280x720. Actual picture of the page will be scaled down if necessary to fit specified size.
        recordHar : Optional[{&#34;omitContent&#34;: Optional[bool], &#34;path&#34;: str}]
            Enables HAR recording for all pages into `recordHar.path` file. If not specified, the HAR is not recorded. Make sure to await `page.close` for the HAR to be saved.
        recordVideo : Optional[{&#34;dir&#34;: str, &#34;size&#34;: Optional[{&#34;width&#34;: int, &#34;height&#34;: int}]}]
            Enables video recording for all pages into `recordVideo.dir` directory. If not specified videos are not recorded. Make sure to await `page.close` for videos to be saved.
        storageState : Optional[{&#34;cookies&#34;: Optional[List[Dict]], &#34;origins&#34;: Optional[List[Dict]]}]
            Populates context with given storage state. This method can be used to initialize context with logged-in information obtained via browserContext.storageState().

        Returns
        -------
        Page
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.newPage(
                    viewport=viewport,
                    ignoreHTTPSErrors=ignoreHTTPSErrors,
                    javaScriptEnabled=javaScriptEnabled,
                    bypassCSP=bypassCSP,
                    userAgent=userAgent,
                    locale=locale,
                    timezoneId=timezoneId,
                    geolocation=geolocation,
                    permissions=permissions,
                    extraHTTPHeaders=mapping.to_impl(extraHTTPHeaders),
                    offline=offline,
                    httpCredentials=httpCredentials,
                    deviceScaleFactor=deviceScaleFactor,
                    isMobile=isMobile,
                    hasTouch=hasTouch,
                    colorScheme=colorScheme,
                    acceptDownloads=acceptDownloads,
                    defaultBrowserType=defaultBrowserType,
                    proxy=proxy,
                    videosPath=videosPath,
                    videoSize=videoSize,
                    recordHar=recordHar,
                    recordVideo=recordVideo,
                    storageState=storageState,
                )
            )
        )

    def close(self) -&gt; NoneType:
        &#34;&#34;&#34;Browser.close

        In case this browser is obtained using browserType.launch, closes the browser and all of its pages (if any were opened).
        In case this browser is obtained using browserType.connect, clears all created contexts belonging to this browser and disconnects from the browser server.
        The Browser object itself is considered to be disposed and cannot be used anymore.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.close()))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright.sync_base.SyncBase</li>
<li>playwright.impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.sync_api.Browser.contexts"><code class="name">var <span class="ident">contexts</span> : List[<a title="playwright.async_api.BrowserContext" href="async_api.html#playwright.async_api.BrowserContext">BrowserContext</a>]</code></dt>
<dd>
<div class="desc"><p>Browser.contexts</p>
<p>Returns an array of all open browser contexts. In a newly created browser, this will return zero
browser contexts.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="playwright.sync_api.BrowserContext" href="#playwright.sync_api.BrowserContext">BrowserContext</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def contexts(self) -&gt; typing.List[&#34;BrowserContext&#34;]:
    &#34;&#34;&#34;Browser.contexts

    Returns an array of all open browser contexts. In a newly created browser, this will return zero
    browser contexts.

    Returns
    -------
    List[BrowserContext]
    &#34;&#34;&#34;
    return mapping.from_impl_list(self._impl_obj.contexts)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Browser.version"><code class="name">var <span class="ident">version</span> : str</code></dt>
<dd>
<div class="desc"><p>Browser.version</p>
<p>Returns the browser version.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def version(self) -&gt; str:
    &#34;&#34;&#34;Browser.version

    Returns the browser version.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.version)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.sync_api.Browser.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Browser.close</p>
<p>In case this browser is obtained using browserType.launch, closes the browser and all of its pages (if any were opened).
In case this browser is obtained using browserType.connect, clears all created contexts belonging to this browser and disconnects from the browser server.
The Browser object itself is considered to be disposed and cannot be used anymore.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self) -&gt; NoneType:
    &#34;&#34;&#34;Browser.close

    In case this browser is obtained using browserType.launch, closes the browser and all of its pages (if any were opened).
    In case this browser is obtained using browserType.connect, clears all created contexts belonging to this browser and disconnects from the browser server.
    The Browser object itself is considered to be disposed and cannot be used anymore.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.close()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Browser.isConnected"><code class="name flex">
<span>def <span class="ident">isConnected</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Browser.isConnected</p>
<p>Indicates that the browser is connected.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isConnected(self) -&gt; bool:
    &#34;&#34;&#34;Browser.isConnected

    Indicates that the browser is connected.

    Returns
    -------
    bool
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.isConnected())</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Browser.newContext"><code class="name flex">
<span>def <span class="ident">newContext</span></span>(<span>self, viewport: Union[playwright.helper.IntSize, Literal[0]] = None, ignoreHTTPSErrors: bool = None, javaScriptEnabled: bool = None, bypassCSP: bool = None, userAgent: str = None, locale: str = None, timezoneId: str = None, geolocation: playwright.helper.Geolocation = None, permissions: List[str] = None, extraHTTPHeaders: Dict[str, str] = None, offline: bool = None, httpCredentials: playwright.helper.Credentials = None, deviceScaleFactor: int = None, isMobile: bool = None, hasTouch: bool = None, colorScheme: Literal['dark', 'light', 'no-preference'] = None, acceptDownloads: bool = None, defaultBrowserType: str = None, proxy: playwright.helper.ProxyServer = None, videosPath: str = None, videoSize: playwright.helper.IntSize = None, recordHar: playwright.helper.RecordHarOptions = None, recordVideo: playwright.helper.RecordVideoOptions = None, storageState: playwright.helper.SetStorageState = None) ‑> <a title="playwright.sync_api.BrowserContext" href="#playwright.sync_api.BrowserContext">BrowserContext</a></span>
</code></dt>
<dd>
<div class="desc"><p>Browser.newContext</p>
<p>Creates a new browser context. It won't share cookies/cache with other browser contexts.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>viewport</code></strong> :&ensp;<code>Union[{"width": int, "height": int}, '0', NoneType]</code></dt>
<dd>Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. <code>null</code> disables the default viewport.</dd>
<dt><strong><code>ignoreHTTPSErrors</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to ignore HTTPS errors during navigation. Defaults to <code>false</code>.</dd>
<dt><strong><code>javaScriptEnabled</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether or not to enable JavaScript in the context. Defaults to true.</dd>
<dt><strong><code>bypassCSP</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Toggles bypassing page's Content-Security-Policy.</dd>
<dt><strong><code>userAgent</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Specific user agent to use in this context.</dd>
<dt><strong><code>locale</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Specify user locale, for example <code>en-GB</code>, <code>de-DE</code>, etc. Locale will affect <code>navigator.language</code> value, <code>Accept-Language</code> request header value as well as number and date formatting rules.</dd>
<dt><strong><code>timezoneId</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Changes the timezone of the context. See ICU’s <code>metaZones.txt</code> for a list of supported timezone IDs.</dd>
<dt><strong><code>geolocation</code></strong> :&ensp;<code>Optional[{"latitude": float, "longitude": float, "accuracy": Optional[float]}]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>permissions</code></strong> :&ensp;<code>Optional[List[str]]</code></dt>
<dd>A list of permissions to grant to all pages in this context. See browserContext.grantPermissions for more details.</dd>
<dt><strong><code>extraHTTPHeaders</code></strong> :&ensp;<code>Optional[Dict[str, str]]</code></dt>
<dd>An object containing additional HTTP headers to be sent with every request. All header values must be strings.</dd>
<dt><strong><code>offline</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to emulate network being offline. Defaults to <code>false</code>.</dd>
<dt><strong><code>httpCredentials</code></strong> :&ensp;<code>Optional[{"username": str, "password": str}]</code></dt>
<dd>Credentials for HTTP authentication.</dd>
<dt><strong><code>deviceScaleFactor</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Specify device scale factor (can be thought of as dpr). Defaults to <code>1</code>.</dd>
<dt><strong><code>isMobile</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether the <code>meta viewport</code> tag is taken into account and touch events are enabled. Defaults to <code>false</code>. Not supported in Firefox.</dd>
<dt><strong><code>hasTouch</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Specifies if viewport supports touch events. Defaults to false.</dd>
<dt><strong><code>colorScheme</code></strong> :&ensp;<code>Optional[Literal['dark', 'light', 'no-preference']]</code></dt>
<dd>Emulates <code>'prefers-colors-scheme'</code> media feature, supported values are <code>'light'</code>, <code>'dark'</code>, <code>'no-preference'</code>. See page.emulateMedia(options) for more details. Defaults to '<code>light</code>'.</dd>
<dt><strong><code>acceptDownloads</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to automatically download all the attachments. Defaults to <code>false</code> where all the downloads are canceled.</dd>
<dt><strong><code>proxy</code></strong> :&ensp;<code>Optional[{"server": str, "bypass": Optional[str], "username": Optional[str], "password": Optional[str]}]</code></dt>
<dd>Network proxy settings to use with this context. Note that browser needs to be launched with the global proxy for this option to work. If all contexts override the proxy, global proxy will be never used and can be any string, for example <code>launch({ proxy: { server: 'per-context' } })</code>.</dd>
<dt><strong><code>videosPath</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd><strong>NOTE</strong> Use <code>recordVideo</code> instead, it takes precedence over <code>videosPath</code>. Enables video recording for all pages to <code>videosPath</code> directory. If not specified, videos are not recorded. Make sure to await <code>browserContext.close</code> for videos to be saved.</dd>
<dt><strong><code>videoSize</code></strong> :&ensp;<code>Optional[{"width": int, "height": int}]</code></dt>
<dd><strong>NOTE</strong> Use <code>recordVideo</code> instead, it takes precedence over <code>videoSize</code>. Specifies dimensions of the automatically recorded video. Can only be used if <code>videosPath</code> is set. If not specified the size will be equal to <code>viewport</code>. If <code>viewport</code> is not configured explicitly the video size defaults to 1280x720. Actual picture of the page will be scaled down if necessary to fit specified size.</dd>
<dt><strong><code>recordHar</code></strong> :&ensp;<code>Optional[{"omitContent": Optional[bool], "path": str}]</code></dt>
<dd>Enables HAR recording for all pages into <code>recordHar.path</code> file. If not specified, the HAR is not recorded. Make sure to await <code>browserContext.close</code> for the HAR to be saved.</dd>
<dt><strong><code>recordVideo</code></strong> :&ensp;<code>Optional[{"dir": str, "size": Optional[{"width": int, "height": int}]}]</code></dt>
<dd>Enables video recording for all pages into <code>recordVideo.dir</code> directory. If not specified videos are not recorded. Make sure to await <code>browserContext.close</code> for videos to be saved.</dd>
<dt><strong><code>storageState</code></strong> :&ensp;<code>Optional[{"cookies": Optional[List[Dict]], "origins": Optional[List[Dict]]}]</code></dt>
<dd>Populates context with given storage state. This method can be used to initialize context with logged-in information obtained via browserContext.storageState().</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.BrowserContext" href="#playwright.sync_api.BrowserContext">BrowserContext</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newContext(
    self,
    viewport: typing.Union[IntSize, Literal[0]] = None,
    ignoreHTTPSErrors: bool = None,
    javaScriptEnabled: bool = None,
    bypassCSP: bool = None,
    userAgent: str = None,
    locale: str = None,
    timezoneId: str = None,
    geolocation: Geolocation = None,
    permissions: typing.List[str] = None,
    extraHTTPHeaders: typing.Union[typing.Dict[str, str]] = None,
    offline: bool = None,
    httpCredentials: Credentials = None,
    deviceScaleFactor: int = None,
    isMobile: bool = None,
    hasTouch: bool = None,
    colorScheme: Literal[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;] = None,
    acceptDownloads: bool = None,
    defaultBrowserType: str = None,
    proxy: ProxyServer = None,
    videosPath: str = None,
    videoSize: IntSize = None,
    recordHar: RecordHarOptions = None,
    recordVideo: RecordVideoOptions = None,
    storageState: SetStorageState = None,
) -&gt; &#34;BrowserContext&#34;:
    &#34;&#34;&#34;Browser.newContext

    Creates a new browser context. It won&#39;t share cookies/cache with other browser contexts.

    Parameters
    ----------
    viewport : Union[{&#34;width&#34;: int, &#34;height&#34;: int}, &#39;0&#39;, NoneType]
        Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. `null` disables the default viewport.
    ignoreHTTPSErrors : Optional[bool]
        Whether to ignore HTTPS errors during navigation. Defaults to `false`.
    javaScriptEnabled : Optional[bool]
        Whether or not to enable JavaScript in the context. Defaults to true.
    bypassCSP : Optional[bool]
        Toggles bypassing page&#39;s Content-Security-Policy.
    userAgent : Optional[str]
        Specific user agent to use in this context.
    locale : Optional[str]
        Specify user locale, for example `en-GB`, `de-DE`, etc. Locale will affect `navigator.language` value, `Accept-Language` request header value as well as number and date formatting rules.
    timezoneId : Optional[str]
        Changes the timezone of the context. See ICU’s `metaZones.txt` for a list of supported timezone IDs.
    geolocation : Optional[{&#34;latitude&#34;: float, &#34;longitude&#34;: float, &#34;accuracy&#34;: Optional[float]}]
    permissions : Optional[List[str]]
        A list of permissions to grant to all pages in this context. See browserContext.grantPermissions for more details.
    extraHTTPHeaders : Optional[Dict[str, str]]
        An object containing additional HTTP headers to be sent with every request. All header values must be strings.
    offline : Optional[bool]
        Whether to emulate network being offline. Defaults to `false`.
    httpCredentials : Optional[{&#34;username&#34;: str, &#34;password&#34;: str}]
        Credentials for HTTP authentication.
    deviceScaleFactor : Optional[int]
        Specify device scale factor (can be thought of as dpr). Defaults to `1`.
    isMobile : Optional[bool]
        Whether the `meta viewport` tag is taken into account and touch events are enabled. Defaults to `false`. Not supported in Firefox.
    hasTouch : Optional[bool]
        Specifies if viewport supports touch events. Defaults to false.
    colorScheme : Optional[Literal[&#39;dark&#39;, &#39;light&#39;, &#39;no-preference&#39;]]
        Emulates `&#39;prefers-colors-scheme&#39;` media feature, supported values are `&#39;light&#39;`, `&#39;dark&#39;`, `&#39;no-preference&#39;`. See page.emulateMedia(options) for more details. Defaults to &#39;`light`&#39;.
    acceptDownloads : Optional[bool]
        Whether to automatically download all the attachments. Defaults to `false` where all the downloads are canceled.
    proxy : Optional[{&#34;server&#34;: str, &#34;bypass&#34;: Optional[str], &#34;username&#34;: Optional[str], &#34;password&#34;: Optional[str]}]
        Network proxy settings to use with this context. Note that browser needs to be launched with the global proxy for this option to work. If all contexts override the proxy, global proxy will be never used and can be any string, for example `launch({ proxy: { server: &#39;per-context&#39; } })`.
    videosPath : Optional[str]
        **NOTE** Use `recordVideo` instead, it takes precedence over `videosPath`. Enables video recording for all pages to `videosPath` directory. If not specified, videos are not recorded. Make sure to await `browserContext.close` for videos to be saved.
    videoSize : Optional[{&#34;width&#34;: int, &#34;height&#34;: int}]
        **NOTE** Use `recordVideo` instead, it takes precedence over `videoSize`. Specifies dimensions of the automatically recorded video. Can only be used if `videosPath` is set. If not specified the size will be equal to `viewport`. If `viewport` is not configured explicitly the video size defaults to 1280x720. Actual picture of the page will be scaled down if necessary to fit specified size.
    recordHar : Optional[{&#34;omitContent&#34;: Optional[bool], &#34;path&#34;: str}]
        Enables HAR recording for all pages into `recordHar.path` file. If not specified, the HAR is not recorded. Make sure to await `browserContext.close` for the HAR to be saved.
    recordVideo : Optional[{&#34;dir&#34;: str, &#34;size&#34;: Optional[{&#34;width&#34;: int, &#34;height&#34;: int}]}]
        Enables video recording for all pages into `recordVideo.dir` directory. If not specified videos are not recorded. Make sure to await `browserContext.close` for videos to be saved.
    storageState : Optional[{&#34;cookies&#34;: Optional[List[Dict]], &#34;origins&#34;: Optional[List[Dict]]}]
        Populates context with given storage state. This method can be used to initialize context with logged-in information obtained via browserContext.storageState().

    Returns
    -------
    BrowserContext
    &#34;&#34;&#34;
    return mapping.from_impl(
        self._sync(
            self._impl_obj.newContext(
                viewport=viewport,
                ignoreHTTPSErrors=ignoreHTTPSErrors,
                javaScriptEnabled=javaScriptEnabled,
                bypassCSP=bypassCSP,
                userAgent=userAgent,
                locale=locale,
                timezoneId=timezoneId,
                geolocation=geolocation,
                permissions=permissions,
                extraHTTPHeaders=mapping.to_impl(extraHTTPHeaders),
                offline=offline,
                httpCredentials=httpCredentials,
                deviceScaleFactor=deviceScaleFactor,
                isMobile=isMobile,
                hasTouch=hasTouch,
                colorScheme=colorScheme,
                acceptDownloads=acceptDownloads,
                defaultBrowserType=defaultBrowserType,
                proxy=proxy,
                videosPath=videosPath,
                videoSize=videoSize,
                recordHar=recordHar,
                recordVideo=recordVideo,
                storageState=storageState,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Browser.newPage"><code class="name flex">
<span>def <span class="ident">newPage</span></span>(<span>self, viewport: Union[playwright.helper.IntSize, Literal[0]] = None, ignoreHTTPSErrors: bool = None, javaScriptEnabled: bool = None, bypassCSP: bool = None, userAgent: str = None, locale: str = None, timezoneId: str = None, geolocation: playwright.helper.Geolocation = None, permissions: List[str] = None, extraHTTPHeaders: Dict[str, str] = None, offline: bool = None, httpCredentials: playwright.helper.Credentials = None, deviceScaleFactor: int = None, isMobile: bool = None, hasTouch: bool = None, colorScheme: Literal['dark', 'light', 'no-preference'] = None, acceptDownloads: bool = None, defaultBrowserType: str = None, proxy: playwright.helper.ProxyServer = None, videosPath: str = None, videoSize: playwright.helper.IntSize = None, recordHar: playwright.helper.RecordHarOptions = None, recordVideo: playwright.helper.RecordVideoOptions = None, storageState: playwright.helper.SetStorageState = None) ‑> <a title="playwright.sync_api.Page" href="#playwright.sync_api.Page">Page</a></span>
</code></dt>
<dd>
<div class="desc"><p>Browser.newPage</p>
<p>Creates a new page in a new browser context. Closing this page will close the context as well.
This is a convenience API that should only be used for the single-page scenarios and short snippets. Production code and testing frameworks should explicitly create browser.newContext followed by the browserContext.newPage to control their exact life times.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>viewport</code></strong> :&ensp;<code>Union[{"width": int, "height": int}, '0', NoneType]</code></dt>
<dd>Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. <code>null</code> disables the default viewport.</dd>
<dt><strong><code>ignoreHTTPSErrors</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to ignore HTTPS errors during navigation. Defaults to <code>false</code>.</dd>
<dt><strong><code>javaScriptEnabled</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether or not to enable JavaScript in the context. Defaults to <code>true</code>.</dd>
<dt><strong><code>bypassCSP</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Toggles bypassing page's Content-Security-Policy.</dd>
<dt><strong><code>userAgent</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Specific user agent to use in this context.</dd>
<dt><strong><code>locale</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Specify user locale, for example <code>en-GB</code>, <code>de-DE</code>, etc. Locale will affect <code>navigator.language</code> value, <code>Accept-Language</code> request header value as well as number and date formatting rules.</dd>
<dt><strong><code>timezoneId</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Changes the timezone of the context. See ICU’s <code>metaZones.txt</code> for a list of supported timezone IDs.</dd>
<dt><strong><code>geolocation</code></strong> :&ensp;<code>Optional[{"latitude": float, "longitude": float, "accuracy": Optional[float]}]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>permissions</code></strong> :&ensp;<code>Optional[List[str]]</code></dt>
<dd>A list of permissions to grant to all pages in this context. See browserContext.grantPermissions for more details.</dd>
<dt><strong><code>extraHTTPHeaders</code></strong> :&ensp;<code>Optional[Dict[str, str]]</code></dt>
<dd>An object containing additional HTTP headers to be sent with every request. All header values must be strings.</dd>
<dt><strong><code>offline</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to emulate network being offline. Defaults to <code>false</code>.</dd>
<dt><strong><code>httpCredentials</code></strong> :&ensp;<code>Optional[{"username": str, "password": str}]</code></dt>
<dd>Credentials for HTTP authentication.</dd>
<dt><strong><code>deviceScaleFactor</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Specify device scale factor (can be thought of as dpr). Defaults to <code>1</code>.</dd>
<dt><strong><code>isMobile</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether the <code>meta viewport</code> tag is taken into account and touch events are enabled. Defaults to <code>false</code>. Not supported in Firefox.</dd>
<dt><strong><code>hasTouch</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Specifies if viewport supports touch events. Defaults to false.</dd>
<dt><strong><code>colorScheme</code></strong> :&ensp;<code>Optional[Literal['dark', 'light', 'no-preference']]</code></dt>
<dd>Emulates <code>'prefers-colors-scheme'</code> media feature, supported values are <code>'light'</code>, <code>'dark'</code>, <code>'no-preference'</code>. See page.emulateMedia(options) for more details. Defaults to '<code>light</code>'.</dd>
<dt><strong><code>acceptDownloads</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to automatically download all the attachments. Defaults to <code>false</code> where all the downloads are canceled.</dd>
<dt><strong><code>proxy</code></strong> :&ensp;<code>Optional[{"server": str, "bypass": Optional[str], "username": Optional[str], "password": Optional[str]}]</code></dt>
<dd>Network proxy settings to use with this context. Note that browser needs to be launched with the global proxy for this option to work. If all contexts override the proxy, global proxy will be never used and can be any string, for example <code>launch({ proxy: { server: 'per-context' } })</code>.</dd>
<dt><strong><code>videosPath</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd><strong>NOTE</strong> Use <code>recordVideo</code> instead, it takes precedence over <code>videosPath</code>. Enables video recording for all pages to <code>videosPath</code> directory. If not specified, videos are not recorded. Make sure to await <code>page.close</code> for videos to be saved.</dd>
<dt><strong><code>videoSize</code></strong> :&ensp;<code>Optional[{"width": int, "height": int}]</code></dt>
<dd><strong>NOTE</strong> Use <code>recordVideo</code> instead, it takes precedence over <code>videoSize</code>. Specifies dimensions of the automatically recorded video. Can only be used if <code>videosPath</code> is set. If not specified the size will be equal to <code>viewport</code>. If <code>viewport</code> is not configured explicitly the video size defaults to 1280x720. Actual picture of the page will be scaled down if necessary to fit specified size.</dd>
<dt><strong><code>recordHar</code></strong> :&ensp;<code>Optional[{"omitContent": Optional[bool], "path": str}]</code></dt>
<dd>Enables HAR recording for all pages into <code>recordHar.path</code> file. If not specified, the HAR is not recorded. Make sure to await <code>page.close</code> for the HAR to be saved.</dd>
<dt><strong><code>recordVideo</code></strong> :&ensp;<code>Optional[{"dir": str, "size": Optional[{"width": int, "height": int}]}]</code></dt>
<dd>Enables video recording for all pages into <code>recordVideo.dir</code> directory. If not specified videos are not recorded. Make sure to await <code>page.close</code> for videos to be saved.</dd>
<dt><strong><code>storageState</code></strong> :&ensp;<code>Optional[{"cookies": Optional[List[Dict]], "origins": Optional[List[Dict]]}]</code></dt>
<dd>Populates context with given storage state. This method can be used to initialize context with logged-in information obtained via browserContext.storageState().</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.Page" href="#playwright.sync_api.Page">Page</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newPage(
    self,
    viewport: typing.Union[IntSize, Literal[0]] = None,
    ignoreHTTPSErrors: bool = None,
    javaScriptEnabled: bool = None,
    bypassCSP: bool = None,
    userAgent: str = None,
    locale: str = None,
    timezoneId: str = None,
    geolocation: Geolocation = None,
    permissions: typing.List[str] = None,
    extraHTTPHeaders: typing.Union[typing.Dict[str, str]] = None,
    offline: bool = None,
    httpCredentials: Credentials = None,
    deviceScaleFactor: int = None,
    isMobile: bool = None,
    hasTouch: bool = None,
    colorScheme: Literal[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;] = None,
    acceptDownloads: bool = None,
    defaultBrowserType: str = None,
    proxy: ProxyServer = None,
    videosPath: str = None,
    videoSize: IntSize = None,
    recordHar: RecordHarOptions = None,
    recordVideo: RecordVideoOptions = None,
    storageState: SetStorageState = None,
) -&gt; &#34;Page&#34;:
    &#34;&#34;&#34;Browser.newPage

    Creates a new page in a new browser context. Closing this page will close the context as well.
    This is a convenience API that should only be used for the single-page scenarios and short snippets. Production code and testing frameworks should explicitly create browser.newContext followed by the browserContext.newPage to control their exact life times.

    Parameters
    ----------
    viewport : Union[{&#34;width&#34;: int, &#34;height&#34;: int}, &#39;0&#39;, NoneType]
        Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. `null` disables the default viewport.
    ignoreHTTPSErrors : Optional[bool]
        Whether to ignore HTTPS errors during navigation. Defaults to `false`.
    javaScriptEnabled : Optional[bool]
        Whether or not to enable JavaScript in the context. Defaults to `true`.
    bypassCSP : Optional[bool]
        Toggles bypassing page&#39;s Content-Security-Policy.
    userAgent : Optional[str]
        Specific user agent to use in this context.
    locale : Optional[str]
        Specify user locale, for example `en-GB`, `de-DE`, etc. Locale will affect `navigator.language` value, `Accept-Language` request header value as well as number and date formatting rules.
    timezoneId : Optional[str]
        Changes the timezone of the context. See ICU’s `metaZones.txt` for a list of supported timezone IDs.
    geolocation : Optional[{&#34;latitude&#34;: float, &#34;longitude&#34;: float, &#34;accuracy&#34;: Optional[float]}]
    permissions : Optional[List[str]]
        A list of permissions to grant to all pages in this context. See browserContext.grantPermissions for more details.
    extraHTTPHeaders : Optional[Dict[str, str]]
        An object containing additional HTTP headers to be sent with every request. All header values must be strings.
    offline : Optional[bool]
        Whether to emulate network being offline. Defaults to `false`.
    httpCredentials : Optional[{&#34;username&#34;: str, &#34;password&#34;: str}]
        Credentials for HTTP authentication.
    deviceScaleFactor : Optional[int]
        Specify device scale factor (can be thought of as dpr). Defaults to `1`.
    isMobile : Optional[bool]
        Whether the `meta viewport` tag is taken into account and touch events are enabled. Defaults to `false`. Not supported in Firefox.
    hasTouch : Optional[bool]
        Specifies if viewport supports touch events. Defaults to false.
    colorScheme : Optional[Literal[&#39;dark&#39;, &#39;light&#39;, &#39;no-preference&#39;]]
        Emulates `&#39;prefers-colors-scheme&#39;` media feature, supported values are `&#39;light&#39;`, `&#39;dark&#39;`, `&#39;no-preference&#39;`. See page.emulateMedia(options) for more details. Defaults to &#39;`light`&#39;.
    acceptDownloads : Optional[bool]
        Whether to automatically download all the attachments. Defaults to `false` where all the downloads are canceled.
    proxy : Optional[{&#34;server&#34;: str, &#34;bypass&#34;: Optional[str], &#34;username&#34;: Optional[str], &#34;password&#34;: Optional[str]}]
        Network proxy settings to use with this context. Note that browser needs to be launched with the global proxy for this option to work. If all contexts override the proxy, global proxy will be never used and can be any string, for example `launch({ proxy: { server: &#39;per-context&#39; } })`.
    videosPath : Optional[str]
        **NOTE** Use `recordVideo` instead, it takes precedence over `videosPath`. Enables video recording for all pages to `videosPath` directory. If not specified, videos are not recorded. Make sure to await `page.close` for videos to be saved.
    videoSize : Optional[{&#34;width&#34;: int, &#34;height&#34;: int}]
        **NOTE** Use `recordVideo` instead, it takes precedence over `videoSize`. Specifies dimensions of the automatically recorded video. Can only be used if `videosPath` is set. If not specified the size will be equal to `viewport`. If `viewport` is not configured explicitly the video size defaults to 1280x720. Actual picture of the page will be scaled down if necessary to fit specified size.
    recordHar : Optional[{&#34;omitContent&#34;: Optional[bool], &#34;path&#34;: str}]
        Enables HAR recording for all pages into `recordHar.path` file. If not specified, the HAR is not recorded. Make sure to await `page.close` for the HAR to be saved.
    recordVideo : Optional[{&#34;dir&#34;: str, &#34;size&#34;: Optional[{&#34;width&#34;: int, &#34;height&#34;: int}]}]
        Enables video recording for all pages into `recordVideo.dir` directory. If not specified videos are not recorded. Make sure to await `page.close` for videos to be saved.
    storageState : Optional[{&#34;cookies&#34;: Optional[List[Dict]], &#34;origins&#34;: Optional[List[Dict]]}]
        Populates context with given storage state. This method can be used to initialize context with logged-in information obtained via browserContext.storageState().

    Returns
    -------
    Page
    &#34;&#34;&#34;
    return mapping.from_impl(
        self._sync(
            self._impl_obj.newPage(
                viewport=viewport,
                ignoreHTTPSErrors=ignoreHTTPSErrors,
                javaScriptEnabled=javaScriptEnabled,
                bypassCSP=bypassCSP,
                userAgent=userAgent,
                locale=locale,
                timezoneId=timezoneId,
                geolocation=geolocation,
                permissions=permissions,
                extraHTTPHeaders=mapping.to_impl(extraHTTPHeaders),
                offline=offline,
                httpCredentials=httpCredentials,
                deviceScaleFactor=deviceScaleFactor,
                isMobile=isMobile,
                hasTouch=hasTouch,
                colorScheme=colorScheme,
                acceptDownloads=acceptDownloads,
                defaultBrowserType=defaultBrowserType,
                proxy=proxy,
                videosPath=videosPath,
                videoSize=videoSize,
                recordHar=recordHar,
                recordVideo=recordVideo,
                storageState=storageState,
            )
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.sync_api.BrowserContext"><code class="flex name class">
<span>class <span class="ident">BrowserContext</span></span>
<span>(</span><span>obj: playwright.browser_context.BrowserContext)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BrowserContext(SyncBase):
    def __init__(self, obj: BrowserContextImpl):
        super().__init__(obj)

    @property
    def pages(self) -&gt; typing.List[&#34;Page&#34;]:
        &#34;&#34;&#34;BrowserContext.pages

        Returns
        -------
        List[Page]
            All open pages in the context. Non visible pages, such as `&#34;background_page&#34;`, will not be listed here. You can find them using chromiumBrowserContext.backgroundPages().
        &#34;&#34;&#34;
        return mapping.from_impl_list(self._impl_obj.pages)

    @property
    def browser(self) -&gt; typing.Union[&#34;Browser&#34;, NoneType]:
        &#34;&#34;&#34;BrowserContext.browser

        Returns
        -------
        Optional[Browser]
            Returns the browser instance of the context. If it was launched as a persistent context null gets returned.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._impl_obj.browser)

    def setDefaultNavigationTimeout(self, timeout: int) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.setDefaultNavigationTimeout

        This setting will change the default maximum navigation time for the following methods and related shortcuts:

        page.goBack([options])
        page.goForward([options])
        page.goto(url[, options])
        page.reload([options])
        page.setContent(html[, options])
        page.waitForNavigation([options])

        **NOTE** `page.setDefaultNavigationTimeout` and `page.setDefaultTimeout` take priority over `browserContext.setDefaultNavigationTimeout`.

        Parameters
        ----------
        timeout : int
            Maximum navigation time in milliseconds
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._impl_obj.setDefaultNavigationTimeout(timeout=timeout)
        )

    def setDefaultTimeout(self, timeout: int) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.setDefaultTimeout

        This setting will change the default maximum time for all the methods accepting `timeout` option.

        **NOTE** `page.setDefaultNavigationTimeout`, `page.setDefaultTimeout` and `browserContext.setDefaultNavigationTimeout` take priority over `browserContext.setDefaultTimeout`.

        Parameters
        ----------
        timeout : int
            Maximum time in milliseconds
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._impl_obj.setDefaultTimeout(timeout=timeout)
        )

    def newPage(self) -&gt; &#34;Page&#34;:
        &#34;&#34;&#34;BrowserContext.newPage

        Creates a new page in the browser context.

        Returns
        -------
        Page
        &#34;&#34;&#34;
        return mapping.from_impl(self._sync(self._impl_obj.newPage()))

    def cookies(
        self, urls: typing.Union[str, typing.List[str]] = None
    ) -&gt; typing.List[typing.Dict]:
        &#34;&#34;&#34;BrowserContext.cookies

        If no URLs are specified, this method returns all cookies.
        If URLs are specified, only cookies that affect those URLs are returned.

        Parameters
        ----------
        urls : Union[str, List[str], NoneType]

        Returns
        -------
        List[Dict]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.cookies(urls=urls)))

    def addCookies(self, cookies: typing.List[typing.Dict]) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.addCookies


        Parameters
        ----------
        cookies : List[Dict]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.addCookies(cookies=mapping.to_impl(cookies)))
        )

    def clearCookies(self) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.clearCookies

        Clears context cookies.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.clearCookies()))

    def grantPermissions(
        self, permissions: typing.List[str], origin: str = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.grantPermissions

        Grants specified permissions to the browser context. Only grants corresponding permissions to the given origin if specified.

        Parameters
        ----------
        permissions : List[str]
            A permission or an array of permissions to grant. Permissions can be one of the following values:
             - `&#39;geolocation&#39;`
             - `&#39;midi&#39;`
             - `&#39;midi-sysex&#39;` (system-exclusive midi)
             - `&#39;notifications&#39;`
             - `&#39;push&#39;`
             - `&#39;camera&#39;`
             - `&#39;microphone&#39;`
             - `&#39;background-sync&#39;`
             - `&#39;ambient-light-sensor&#39;`
             - `&#39;accelerometer&#39;`
             - `&#39;gyroscope&#39;`
             - `&#39;magnetometer&#39;`
             - `&#39;accessibility-events&#39;`
             - `&#39;clipboard-read&#39;`
             - `&#39;clipboard-write&#39;`
             - `&#39;payment-handler&#39;`
        origin : Optional[str]
            The origin to grant permissions to, e.g. &#34;https://example.com&#34;.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.grantPermissions(permissions=permissions, origin=origin)
            )
        )

    def clearPermissions(self) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.clearPermissions

        Clears all permission overrides for the browser context.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.clearPermissions()))

    def setGeolocation(self, geolocation: Geolocation = None) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.setGeolocation

        Sets the context&#39;s geolocation. Passing `null` or `undefined` emulates position unavailable.

        **NOTE** Consider using browserContext.grantPermissions to grant permissions for the browser context pages to read its geolocation.

        Parameters
        ----------
        geolocation : Optional[{&#34;latitude&#34;: float, &#34;longitude&#34;: float, &#34;accuracy&#34;: Optional[float]}]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.setGeolocation(geolocation=geolocation))
        )

    def setExtraHTTPHeaders(self, headers: typing.Dict[str, str]) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.setExtraHTTPHeaders

        The extra HTTP headers will be sent with every request initiated by any page in the context. These headers are merged with page-specific extra HTTP headers set with page.setExtraHTTPHeaders(). If page overrides a particular header, page-specific header value will be used instead of the browser context header value.

        **NOTE** `browserContext.setExtraHTTPHeaders` does not guarantee the order of headers in the outgoing requests.

        Parameters
        ----------
        headers : Dict[str, str]
            An object containing additional HTTP headers to be sent with every request. All header values must be strings.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.setExtraHTTPHeaders(headers=mapping.to_impl(headers))
            )
        )

    def setOffline(self, offline: bool) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.setOffline

        Parameters
        ----------
        offline : bool
            Whether to emulate network being offline for the browser context.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.setOffline(offline=offline))
        )

    def addInitScript(
        self, source: str = None, path: typing.Union[str, pathlib.Path] = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.addInitScript

        Adds a script which would be evaluated in one of the following scenarios:

        Whenever a page is created in the browser context or is navigated.
        Whenever a child frame is attached or navigated in any page in the browser context. In this case, the script is evaluated in the context of the newly attached frame.

        The script is evaluated after the document was created but before any of its scripts were run. This is useful to amend  the JavaScript environment, e.g. to seed `Math.random`.
        An example of overriding `Math.random` before the page loads:

        **NOTE** The order of evaluation of multiple scripts installed via browserContext.addInitScript(script[, arg]) and page.addInitScript(script[, arg]) is not defined.

        Parameters
        ----------
        source : Optional[str]
            Script to be evaluated in all pages in the browser context.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.addInitScript(source=source, path=path))
        )

    def exposeBinding(
        self, name: str, binding: typing.Callable, handle: bool = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.exposeBinding

        The method adds a function called `name` on the `window` object of every frame in every page in the context.
        When called, the function executes `playwrightBinding` in Node.js and returns a Promise which resolves to the return value of `playwrightBinding`.
        If the `playwrightBinding` returns a Promise, it will be awaited.
        The first argument of the `playwrightBinding` function contains information about the caller:
        `{ browserContext: BrowserContext, page: Page, frame: Frame }`.
        See page.exposeBinding(name, playwrightBinding) for page-only version.
        An example of exposing page URL to all frames in all pages in the context:

        An example of passing an element handle:

        Parameters
        ----------
        name : str
            Name of the function on the window object.
        binding : Callable
            Callback function that will be called in the Playwright&#39;s context.
        handle : Optional[bool]
            Whether to pass the argument as a handle, instead of passing by value. When passing a handle, only one argument is supported. When passing by value, multiple arguments are supported.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.exposeBinding(
                    name=name, binding=self._wrap_handler(binding), handle=handle
                )
            )
        )

    def exposeFunction(self, name: str, binding: typing.Callable) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.exposeFunction

        The method adds a function called `name` on the `window` object of every frame in every page in the context.
        When called, the function executes `playwrightFunction` in Node.js and returns a Promise which resolves to the return value of `playwrightFunction`.
        If the `playwrightFunction` returns a Promise, it will be awaited.
        See page.exposeFunction(name, playwrightFunction) for page-only version.
        An example of adding an `md5` function to all pages in the context:

        Parameters
        ----------
        name : str
            Name of the function on the window object.
        binding : Callable
            Callback function that will be called in the Playwright&#39;s context.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.exposeFunction(
                    name=name, binding=self._wrap_handler(binding)
                )
            )
        )

    def route(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]],
        handler: typing.Callable[[&#34;Route&#34;, &#34;Request&#34;], typing.Any],
    ) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.route

        Routing provides the capability to modify network requests that are made by any page in the browser context.
        Once route is enabled, every request matching the url pattern will stall unless it&#39;s continued, fulfilled or aborted.
        An example of a naïve handler that aborts all image requests:
        or the same snippet using a regex pattern instead:
        Page routes (set up with page.route(url, handler)) take precedence over browser context routes when request matches both handlers.

        **NOTE** Enabling routing disables http cache.

        Parameters
        ----------
        url : Union[str, Pattern, typing.Callable[[str], bool]]
            A glob pattern, regex pattern or predicate receiving URL to match while routing.
        handler : typing.Callable[[playwright.network.Route, playwright.network.Request], typing.Any]
            handler function to route the request.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.route(
                    url=self._wrap_handler(url), handler=self._wrap_handler(handler)
                )
            )
        )

    def unroute(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]],
        handler: typing.Union[typing.Callable[[&#34;Route&#34;, &#34;Request&#34;], typing.Any]] = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.unroute

        Removes a route created with browserContext.route(url, handler). When `handler` is not specified, removes all routes for the `url`.

        Parameters
        ----------
        url : Union[str, Pattern, typing.Callable[[str], bool]]
            A glob pattern, regex pattern or predicate receiving URL used to register a routing with browserContext.route(url, handler).
        handler : Optional[typing.Callable[[playwright.network.Route, playwright.network.Request], typing.Any]]
            Handler function used to register a routing with browserContext.route(url, handler).
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.unroute(
                    url=self._wrap_handler(url), handler=self._wrap_handler(handler)
                )
            )
        )

    def waitForEvent(
        self,
        event: str,
        predicate: typing.Union[typing.Callable[[typing.Any], bool]] = None,
        timeout: int = None,
    ) -&gt; typing.Any:
        &#34;&#34;&#34;BrowserContext.waitForEvent

        Waits for event to fire and passes its value into the predicate function. Resolves when the predicate returns truthy value. Will throw an error if the context closes before the event
        is fired.

        Parameters
        ----------
        event : str
            Event name, same one would pass into `browserContext.on(event)`.

        Returns
        -------
        Any
            Promise which resolves to the event data value.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.waitForEvent(
                    event=event,
                    predicate=self._wrap_handler(predicate),
                    timeout=timeout,
                )
            )
        )

    def close(self) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.close

        Closes the browser context. All the pages that belong to the browser context
        will be closed.

        **NOTE** the default browser context cannot be closed.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.close()))

    def storageState(self) -&gt; StorageState:
        &#34;&#34;&#34;BrowserContext.storageState

        Returns storage state for this browser context, contains current cookies and local storage snapshot.

        Returns
        -------
        {&#34;cookies&#34;: List[Dict], &#34;origins&#34;: List[Dict]}
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.storageState()))

    def expect_event(
        self,
        event: str,
        predicate: typing.Union[typing.Callable[[typing.Any], bool]] = None,
        timeout: int = None,
    ) -&gt; EventContextManager:
        return EventContextManager(
            self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
        )

    def expect_page(
        self,
        predicate: typing.Union[typing.Callable[[&#34;Page&#34;], bool]] = None,
        timeout: int = None,
    ) -&gt; EventContextManager[&#34;Page&#34;]:
        event = &#34;page&#34;
        return EventContextManager(
            self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright.sync_base.SyncBase</li>
<li>playwright.impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="playwright.sync_api.ChromiumBrowserContext" href="#playwright.sync_api.ChromiumBrowserContext">ChromiumBrowserContext</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.sync_api.BrowserContext.browser"><code class="name">var <span class="ident">browser</span> : Union[<a title="playwright.async_api.Browser" href="async_api.html#playwright.async_api.Browser">Browser</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>BrowserContext.browser</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[<a title="playwright.sync_api.Browser" href="#playwright.sync_api.Browser">Browser</a>]</code></dt>
<dd>Returns the browser instance of the context. If it was launched as a persistent context null gets returned.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def browser(self) -&gt; typing.Union[&#34;Browser&#34;, NoneType]:
    &#34;&#34;&#34;BrowserContext.browser

    Returns
    -------
    Optional[Browser]
        Returns the browser instance of the context. If it was launched as a persistent context null gets returned.
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(self._impl_obj.browser)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.BrowserContext.pages"><code class="name">var <span class="ident">pages</span> : List[<a title="playwright.async_api.Page" href="async_api.html#playwright.async_api.Page">Page</a>]</code></dt>
<dd>
<div class="desc"><p>BrowserContext.pages</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="playwright.sync_api.Page" href="#playwright.sync_api.Page">Page</a>]</code></dt>
<dd>All open pages in the context. Non visible pages, such as <code>"background_page"</code>, will not be listed here. You can find them using chromiumBrowserContext.backgroundPages().</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pages(self) -&gt; typing.List[&#34;Page&#34;]:
    &#34;&#34;&#34;BrowserContext.pages

    Returns
    -------
    List[Page]
        All open pages in the context. Non visible pages, such as `&#34;background_page&#34;`, will not be listed here. You can find them using chromiumBrowserContext.backgroundPages().
    &#34;&#34;&#34;
    return mapping.from_impl_list(self._impl_obj.pages)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.sync_api.BrowserContext.addCookies"><code class="name flex">
<span>def <span class="ident">addCookies</span></span>(<span>self, cookies: List[Dict]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.addCookies</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cookies</code></strong> :&ensp;<code>List[Dict]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addCookies(self, cookies: typing.List[typing.Dict]) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.addCookies


    Parameters
    ----------
    cookies : List[Dict]
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.addCookies(cookies=mapping.to_impl(cookies)))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.BrowserContext.addInitScript"><code class="name flex">
<span>def <span class="ident">addInitScript</span></span>(<span>self, source: str = None, path: Union[str, pathlib.Path] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.addInitScript</p>
<p>Adds a script which would be evaluated in one of the following scenarios:</p>
<p>Whenever a page is created in the browser context or is navigated.
Whenever a child frame is attached or navigated in any page in the browser context. In this case, the script is evaluated in the context of the newly attached frame.</p>
<p>The script is evaluated after the document was created but before any of its scripts were run. This is useful to amend
the JavaScript environment, e.g. to seed <code>Math.random</code>.
An example of overriding <code>Math.random</code> before the page loads:</p>
<p><strong>NOTE</strong> The order of evaluation of multiple scripts installed via browserContext.addInitScript(script[, arg]) and page.addInitScript(script[, arg]) is not defined.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>source</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Script to be evaluated in all pages in the browser context.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addInitScript(
    self, source: str = None, path: typing.Union[str, pathlib.Path] = None
) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.addInitScript

    Adds a script which would be evaluated in one of the following scenarios:

    Whenever a page is created in the browser context or is navigated.
    Whenever a child frame is attached or navigated in any page in the browser context. In this case, the script is evaluated in the context of the newly attached frame.

    The script is evaluated after the document was created but before any of its scripts were run. This is useful to amend  the JavaScript environment, e.g. to seed `Math.random`.
    An example of overriding `Math.random` before the page loads:

    **NOTE** The order of evaluation of multiple scripts installed via browserContext.addInitScript(script[, arg]) and page.addInitScript(script[, arg]) is not defined.

    Parameters
    ----------
    source : Optional[str]
        Script to be evaluated in all pages in the browser context.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.addInitScript(source=source, path=path))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.BrowserContext.clearCookies"><code class="name flex">
<span>def <span class="ident">clearCookies</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.clearCookies</p>
<p>Clears context cookies.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clearCookies(self) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.clearCookies

    Clears context cookies.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.clearCookies()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.BrowserContext.clearPermissions"><code class="name flex">
<span>def <span class="ident">clearPermissions</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.clearPermissions</p>
<p>Clears all permission overrides for the browser context.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clearPermissions(self) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.clearPermissions

    Clears all permission overrides for the browser context.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.clearPermissions()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.BrowserContext.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.close</p>
<p>Closes the browser context. All the pages that belong to the browser context
will be closed.</p>
<p><strong>NOTE</strong> the default browser context cannot be closed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.close

    Closes the browser context. All the pages that belong to the browser context
    will be closed.

    **NOTE** the default browser context cannot be closed.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.close()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.BrowserContext.cookies"><code class="name flex">
<span>def <span class="ident">cookies</span></span>(<span>self, urls: Union[str, List[str]] = None) ‑> List[Dict]</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.cookies</p>
<p>If no URLs are specified, this method returns all cookies.
If URLs are specified, only cookies that affect those URLs are returned.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>urls</code></strong> :&ensp;<code>Union[str, List[str], NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[Dict]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cookies(
    self, urls: typing.Union[str, typing.List[str]] = None
) -&gt; typing.List[typing.Dict]:
    &#34;&#34;&#34;BrowserContext.cookies

    If no URLs are specified, this method returns all cookies.
    If URLs are specified, only cookies that affect those URLs are returned.

    Parameters
    ----------
    urls : Union[str, List[str], NoneType]

    Returns
    -------
    List[Dict]
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.cookies(urls=urls)))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.BrowserContext.expect_event"><code class="name flex">
<span>def <span class="ident">expect_event</span></span>(<span>self, event: str, predicate: Callable[[Any], bool] = None, timeout: int = None) ‑> playwright.sync_base.EventContextManager</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_event(
    self,
    event: str,
    predicate: typing.Union[typing.Callable[[typing.Any], bool]] = None,
    timeout: int = None,
) -&gt; EventContextManager:
    return EventContextManager(
        self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.BrowserContext.expect_page"><code class="name flex">
<span>def <span class="ident">expect_page</span></span>(<span>self, predicate: Callable[[ForwardRef('<a title="playwright.sync_api.Page" href="#playwright.sync_api.Page">Page</a>')], bool] = None, timeout: int = None) ‑> playwright.sync_base.EventContextManager[<a title="playwright.sync_api.Page" href="#playwright.sync_api.Page">Page</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_page(
    self,
    predicate: typing.Union[typing.Callable[[&#34;Page&#34;], bool]] = None,
    timeout: int = None,
) -&gt; EventContextManager[&#34;Page&#34;]:
    event = &#34;page&#34;
    return EventContextManager(
        self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.BrowserContext.exposeBinding"><code class="name flex">
<span>def <span class="ident">exposeBinding</span></span>(<span>self, name: str, binding: Callable, handle: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.exposeBinding</p>
<p>The method adds a function called <code>name</code> on the <code>window</code> object of every frame in every page in the context.
When called, the function executes <code>playwrightBinding</code> in Node.js and returns a Promise which resolves to the return value of <code>playwrightBinding</code>.
If the <code>playwrightBinding</code> returns a Promise, it will be awaited.
The first argument of the <code>playwrightBinding</code> function contains information about the caller:
<code>{ browserContext: BrowserContext, page: Page, frame: Frame }</code>.
See page.exposeBinding(name, playwrightBinding) for page-only version.
An example of exposing page URL to all frames in all pages in the context:</p>
<p>An example of passing an element handle:</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the function on the window object.</dd>
<dt><strong><code>binding</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Callback function that will be called in the Playwright's context.</dd>
<dt><strong><code>handle</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to pass the argument as a handle, instead of passing by value. When passing a handle, only one argument is supported. When passing by value, multiple arguments are supported.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exposeBinding(
    self, name: str, binding: typing.Callable, handle: bool = None
) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.exposeBinding

    The method adds a function called `name` on the `window` object of every frame in every page in the context.
    When called, the function executes `playwrightBinding` in Node.js and returns a Promise which resolves to the return value of `playwrightBinding`.
    If the `playwrightBinding` returns a Promise, it will be awaited.
    The first argument of the `playwrightBinding` function contains information about the caller:
    `{ browserContext: BrowserContext, page: Page, frame: Frame }`.
    See page.exposeBinding(name, playwrightBinding) for page-only version.
    An example of exposing page URL to all frames in all pages in the context:

    An example of passing an element handle:

    Parameters
    ----------
    name : str
        Name of the function on the window object.
    binding : Callable
        Callback function that will be called in the Playwright&#39;s context.
    handle : Optional[bool]
        Whether to pass the argument as a handle, instead of passing by value. When passing a handle, only one argument is supported. When passing by value, multiple arguments are supported.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.exposeBinding(
                name=name, binding=self._wrap_handler(binding), handle=handle
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.BrowserContext.exposeFunction"><code class="name flex">
<span>def <span class="ident">exposeFunction</span></span>(<span>self, name: str, binding: Callable) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.exposeFunction</p>
<p>The method adds a function called <code>name</code> on the <code>window</code> object of every frame in every page in the context.
When called, the function executes <code>playwrightFunction</code> in Node.js and returns a Promise which resolves to the return value of <code>playwrightFunction</code>.
If the <code>playwrightFunction</code> returns a Promise, it will be awaited.
See page.exposeFunction(name, playwrightFunction) for page-only version.
An example of adding an <code>md5</code> function to all pages in the context:</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the function on the window object.</dd>
<dt><strong><code>binding</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Callback function that will be called in the Playwright's context.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exposeFunction(self, name: str, binding: typing.Callable) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.exposeFunction

    The method adds a function called `name` on the `window` object of every frame in every page in the context.
    When called, the function executes `playwrightFunction` in Node.js and returns a Promise which resolves to the return value of `playwrightFunction`.
    If the `playwrightFunction` returns a Promise, it will be awaited.
    See page.exposeFunction(name, playwrightFunction) for page-only version.
    An example of adding an `md5` function to all pages in the context:

    Parameters
    ----------
    name : str
        Name of the function on the window object.
    binding : Callable
        Callback function that will be called in the Playwright&#39;s context.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.exposeFunction(
                name=name, binding=self._wrap_handler(binding)
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.BrowserContext.grantPermissions"><code class="name flex">
<span>def <span class="ident">grantPermissions</span></span>(<span>self, permissions: List[str], origin: str = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.grantPermissions</p>
<p>Grants specified permissions to the browser context. Only grants corresponding permissions to the given origin if specified.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>permissions</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>A permission or an array of permissions to grant. Permissions can be one of the following values:
- <code>'geolocation'</code>
- <code>'midi'</code>
- <code>'midi-sysex'</code> (system-exclusive midi)
- <code>'notifications'</code>
- <code>'push'</code>
- <code>'camera'</code>
- <code>'microphone'</code>
- <code>'background-sync'</code>
- <code>'ambient-light-sensor'</code>
- <code>'accelerometer'</code>
- <code>'gyroscope'</code>
- <code>'magnetometer'</code>
- <code>'accessibility-events'</code>
- <code>'clipboard-read'</code>
- <code>'clipboard-write'</code>
- <code>'payment-handler'</code></dd>
<dt><strong><code>origin</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The origin to grant permissions to, e.g. "https://example.com".</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grantPermissions(
    self, permissions: typing.List[str], origin: str = None
) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.grantPermissions

    Grants specified permissions to the browser context. Only grants corresponding permissions to the given origin if specified.

    Parameters
    ----------
    permissions : List[str]
        A permission or an array of permissions to grant. Permissions can be one of the following values:
         - `&#39;geolocation&#39;`
         - `&#39;midi&#39;`
         - `&#39;midi-sysex&#39;` (system-exclusive midi)
         - `&#39;notifications&#39;`
         - `&#39;push&#39;`
         - `&#39;camera&#39;`
         - `&#39;microphone&#39;`
         - `&#39;background-sync&#39;`
         - `&#39;ambient-light-sensor&#39;`
         - `&#39;accelerometer&#39;`
         - `&#39;gyroscope&#39;`
         - `&#39;magnetometer&#39;`
         - `&#39;accessibility-events&#39;`
         - `&#39;clipboard-read&#39;`
         - `&#39;clipboard-write&#39;`
         - `&#39;payment-handler&#39;`
    origin : Optional[str]
        The origin to grant permissions to, e.g. &#34;https://example.com&#34;.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.grantPermissions(permissions=permissions, origin=origin)
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.BrowserContext.newPage"><code class="name flex">
<span>def <span class="ident">newPage</span></span>(<span>self) ‑> <a title="playwright.sync_api.Page" href="#playwright.sync_api.Page">Page</a></span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.newPage</p>
<p>Creates a new page in the browser context.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.Page" href="#playwright.sync_api.Page">Page</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newPage(self) -&gt; &#34;Page&#34;:
    &#34;&#34;&#34;BrowserContext.newPage

    Creates a new page in the browser context.

    Returns
    -------
    Page
    &#34;&#34;&#34;
    return mapping.from_impl(self._sync(self._impl_obj.newPage()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.BrowserContext.route"><code class="name flex">
<span>def <span class="ident">route</span></span>(<span>self, url: Union[str, Pattern, Callable[[str], bool]], handler: Callable[[ForwardRef('<a title="playwright.sync_api.Route" href="#playwright.sync_api.Route">Route</a>'), ForwardRef('<a title="playwright.sync_api.Request" href="#playwright.sync_api.Request">Request</a>')], Any]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.route</p>
<p>Routing provides the capability to modify network requests that are made by any page in the browser context.
Once route is enabled, every request matching the url pattern will stall unless it's continued, fulfilled or aborted.
An example of a naïve handler that aborts all image requests:
or the same snippet using a regex pattern instead:
Page routes (set up with page.route(url, handler)) take precedence over browser context routes when request matches both handlers.</p>
<p><strong>NOTE</strong> Enabling routing disables http cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>Union[str, Pattern, typing.Callable[[str], bool]]</code></dt>
<dd>A glob pattern, regex pattern or predicate receiving URL to match while routing.</dd>
<dt><strong><code>handler</code></strong> :&ensp;<code>typing.Callable[[playwright.network.Route, playwright.network.Request], typing.Any]</code></dt>
<dd>handler function to route the request.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def route(
    self,
    url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]],
    handler: typing.Callable[[&#34;Route&#34;, &#34;Request&#34;], typing.Any],
) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.route

    Routing provides the capability to modify network requests that are made by any page in the browser context.
    Once route is enabled, every request matching the url pattern will stall unless it&#39;s continued, fulfilled or aborted.
    An example of a naïve handler that aborts all image requests:
    or the same snippet using a regex pattern instead:
    Page routes (set up with page.route(url, handler)) take precedence over browser context routes when request matches both handlers.

    **NOTE** Enabling routing disables http cache.

    Parameters
    ----------
    url : Union[str, Pattern, typing.Callable[[str], bool]]
        A glob pattern, regex pattern or predicate receiving URL to match while routing.
    handler : typing.Callable[[playwright.network.Route, playwright.network.Request], typing.Any]
        handler function to route the request.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.route(
                url=self._wrap_handler(url), handler=self._wrap_handler(handler)
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.BrowserContext.setDefaultNavigationTimeout"><code class="name flex">
<span>def <span class="ident">setDefaultNavigationTimeout</span></span>(<span>self, timeout: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.setDefaultNavigationTimeout</p>
<p>This setting will change the default maximum navigation time for the following methods and related shortcuts:</p>
<p>page.goBack([options])
page.goForward([options])
page.goto(url[, options])
page.reload([options])
page.setContent(html[, options])
page.waitForNavigation([options])</p>
<p><strong>NOTE</strong> <code>page.setDefaultNavigationTimeout</code> and <code>page.setDefaultTimeout</code> take priority over <code>browserContext.setDefaultNavigationTimeout</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum navigation time in milliseconds</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setDefaultNavigationTimeout(self, timeout: int) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.setDefaultNavigationTimeout

    This setting will change the default maximum navigation time for the following methods and related shortcuts:

    page.goBack([options])
    page.goForward([options])
    page.goto(url[, options])
    page.reload([options])
    page.setContent(html[, options])
    page.waitForNavigation([options])

    **NOTE** `page.setDefaultNavigationTimeout` and `page.setDefaultTimeout` take priority over `browserContext.setDefaultNavigationTimeout`.

    Parameters
    ----------
    timeout : int
        Maximum navigation time in milliseconds
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._impl_obj.setDefaultNavigationTimeout(timeout=timeout)
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.BrowserContext.setDefaultTimeout"><code class="name flex">
<span>def <span class="ident">setDefaultTimeout</span></span>(<span>self, timeout: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.setDefaultTimeout</p>
<p>This setting will change the default maximum time for all the methods accepting <code>timeout</code> option.</p>
<p><strong>NOTE</strong> <code>page.setDefaultNavigationTimeout</code>, <code>page.setDefaultTimeout</code> and <code>browserContext.setDefaultNavigationTimeout</code> take priority over <code>browserContext.setDefaultTimeout</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum time in milliseconds</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setDefaultTimeout(self, timeout: int) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.setDefaultTimeout

    This setting will change the default maximum time for all the methods accepting `timeout` option.

    **NOTE** `page.setDefaultNavigationTimeout`, `page.setDefaultTimeout` and `browserContext.setDefaultNavigationTimeout` take priority over `browserContext.setDefaultTimeout`.

    Parameters
    ----------
    timeout : int
        Maximum time in milliseconds
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._impl_obj.setDefaultTimeout(timeout=timeout)
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.BrowserContext.setExtraHTTPHeaders"><code class="name flex">
<span>def <span class="ident">setExtraHTTPHeaders</span></span>(<span>self, headers: Dict[str, str]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.setExtraHTTPHeaders</p>
<p>The extra HTTP headers will be sent with every request initiated by any page in the context. These headers are merged with page-specific extra HTTP headers set with page.setExtraHTTPHeaders(). If page overrides a particular header, page-specific header value will be used instead of the browser context header value.</p>
<p><strong>NOTE</strong> <code>browserContext.setExtraHTTPHeaders</code> does not guarantee the order of headers in the outgoing requests.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>headers</code></strong> :&ensp;<code>Dict[str, str]</code></dt>
<dd>An object containing additional HTTP headers to be sent with every request. All header values must be strings.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setExtraHTTPHeaders(self, headers: typing.Dict[str, str]) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.setExtraHTTPHeaders

    The extra HTTP headers will be sent with every request initiated by any page in the context. These headers are merged with page-specific extra HTTP headers set with page.setExtraHTTPHeaders(). If page overrides a particular header, page-specific header value will be used instead of the browser context header value.

    **NOTE** `browserContext.setExtraHTTPHeaders` does not guarantee the order of headers in the outgoing requests.

    Parameters
    ----------
    headers : Dict[str, str]
        An object containing additional HTTP headers to be sent with every request. All header values must be strings.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.setExtraHTTPHeaders(headers=mapping.to_impl(headers))
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.BrowserContext.setGeolocation"><code class="name flex">
<span>def <span class="ident">setGeolocation</span></span>(<span>self, geolocation: playwright.helper.Geolocation = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.setGeolocation</p>
<p>Sets the context's geolocation. Passing <code>null</code> or <code>undefined</code> emulates position unavailable.</p>
<p><strong>NOTE</strong> Consider using browserContext.grantPermissions to grant permissions for the browser context pages to read its geolocation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>geolocation</code></strong> :&ensp;<code>Optional[{"latitude": float, "longitude": float, "accuracy": Optional[float]}]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setGeolocation(self, geolocation: Geolocation = None) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.setGeolocation

    Sets the context&#39;s geolocation. Passing `null` or `undefined` emulates position unavailable.

    **NOTE** Consider using browserContext.grantPermissions to grant permissions for the browser context pages to read its geolocation.

    Parameters
    ----------
    geolocation : Optional[{&#34;latitude&#34;: float, &#34;longitude&#34;: float, &#34;accuracy&#34;: Optional[float]}]
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.setGeolocation(geolocation=geolocation))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.BrowserContext.setOffline"><code class="name flex">
<span>def <span class="ident">setOffline</span></span>(<span>self, offline: bool) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.setOffline</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>offline</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to emulate network being offline for the browser context.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setOffline(self, offline: bool) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.setOffline

    Parameters
    ----------
    offline : bool
        Whether to emulate network being offline for the browser context.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.setOffline(offline=offline))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.BrowserContext.storageState"><code class="name flex">
<span>def <span class="ident">storageState</span></span>(<span>self) ‑> playwright.helper.StorageState</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.storageState</p>
<p>Returns storage state for this browser context, contains current cookies and local storage snapshot.</p>
<h2 id="returns">Returns</h2>
<p>{"cookies": List[Dict], "origins": List[Dict]}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def storageState(self) -&gt; StorageState:
    &#34;&#34;&#34;BrowserContext.storageState

    Returns storage state for this browser context, contains current cookies and local storage snapshot.

    Returns
    -------
    {&#34;cookies&#34;: List[Dict], &#34;origins&#34;: List[Dict]}
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.storageState()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.BrowserContext.unroute"><code class="name flex">
<span>def <span class="ident">unroute</span></span>(<span>self, url: Union[str, Pattern, Callable[[str], bool]], handler: Callable[[ForwardRef('<a title="playwright.sync_api.Route" href="#playwright.sync_api.Route">Route</a>'), ForwardRef('<a title="playwright.sync_api.Request" href="#playwright.sync_api.Request">Request</a>')], Any] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.unroute</p>
<p>Removes a route created with browserContext.route(url, handler). When <code>handler</code> is not specified, removes all routes for the <code>url</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>Union[str, Pattern, typing.Callable[[str], bool]]</code></dt>
<dd>A glob pattern, regex pattern or predicate receiving URL used to register a routing with browserContext.route(url, handler).</dd>
<dt><strong><code>handler</code></strong> :&ensp;<code>Optional[typing.Callable[[playwright.network.Route, playwright.network.Request], typing.Any]]</code></dt>
<dd>Handler function used to register a routing with browserContext.route(url, handler).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unroute(
    self,
    url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]],
    handler: typing.Union[typing.Callable[[&#34;Route&#34;, &#34;Request&#34;], typing.Any]] = None,
) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.unroute

    Removes a route created with browserContext.route(url, handler). When `handler` is not specified, removes all routes for the `url`.

    Parameters
    ----------
    url : Union[str, Pattern, typing.Callable[[str], bool]]
        A glob pattern, regex pattern or predicate receiving URL used to register a routing with browserContext.route(url, handler).
    handler : Optional[typing.Callable[[playwright.network.Route, playwright.network.Request], typing.Any]]
        Handler function used to register a routing with browserContext.route(url, handler).
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.unroute(
                url=self._wrap_handler(url), handler=self._wrap_handler(handler)
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.BrowserContext.waitForEvent"><code class="name flex">
<span>def <span class="ident">waitForEvent</span></span>(<span>self, event: str, predicate: Callable[[Any], bool] = None, timeout: int = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.waitForEvent</p>
<p>Waits for event to fire and passes its value into the predicate function. Resolves when the predicate returns truthy value. Will throw an error if the context closes before the event
is fired.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>str</code></dt>
<dd>Event name, same one would pass into <code>browserContext.on(event)</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>Promise which resolves to the event data value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def waitForEvent(
    self,
    event: str,
    predicate: typing.Union[typing.Callable[[typing.Any], bool]] = None,
    timeout: int = None,
) -&gt; typing.Any:
    &#34;&#34;&#34;BrowserContext.waitForEvent

    Waits for event to fire and passes its value into the predicate function. Resolves when the predicate returns truthy value. Will throw an error if the context closes before the event
    is fired.

    Parameters
    ----------
    event : str
        Event name, same one would pass into `browserContext.on(event)`.

    Returns
    -------
    Any
        Promise which resolves to the event data value.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.waitForEvent(
                event=event,
                predicate=self._wrap_handler(predicate),
                timeout=timeout,
            )
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.sync_api.BrowserType"><code class="flex name class">
<span>class <span class="ident">BrowserType</span></span>
<span>(</span><span>obj: playwright.browser_type.BrowserType)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BrowserType(SyncBase):
    def __init__(self, obj: BrowserTypeImpl):
        super().__init__(obj)

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;BrowserType.name

        Returns browser name. For example: `&#39;chromium&#39;`, `&#39;webkit&#39;` or `&#39;firefox&#39;`.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.name)

    @property
    def executablePath(self) -&gt; str:
        &#34;&#34;&#34;BrowserType.executablePath

        Returns
        -------
        str
            A path where Playwright expects to find a bundled browser executable.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.executablePath)

    def launch(
        self,
        executablePath: typing.Union[str, pathlib.Path] = None,
        args: typing.List[str] = None,
        ignoreDefaultArgs: typing.Union[bool, typing.List[str]] = None,
        handleSIGINT: bool = None,
        handleSIGTERM: bool = None,
        handleSIGHUP: bool = None,
        timeout: int = None,
        env: typing.Union[typing.Dict[str, typing.Union[str, int, bool]]] = None,
        headless: bool = None,
        devtools: bool = None,
        proxy: ProxyServer = None,
        downloadsPath: typing.Union[str, pathlib.Path] = None,
        slowMo: int = None,
        chromiumSandbox: bool = None,
        firefoxUserPrefs: typing.Union[
            typing.Dict[str, typing.Union[str, int, bool]]
        ] = None,
    ) -&gt; &#34;Browser&#34;:
        &#34;&#34;&#34;BrowserType.launch

        You can use `ignoreDefaultArgs` to filter out `--mute-audio` from default arguments:

        **Chromium-only** Playwright can also be used to control the Chrome browser, but it works best with the version of Chromium it is bundled with. There is no guarantee it will work with any other version. Use `executablePath` option with extreme caution.
        If Google Chrome (rather than Chromium) is preferred, a Chrome Canary or Dev Channel build is suggested.
        In browserType.launch([options]) above, any mention of Chromium also applies to Chrome.
        See `this article` for a description of the differences between Chromium and Chrome. `This article` describes some differences for Linux users.

        Parameters
        ----------
        executablePath : Union[str, pathlib.Path, NoneType]
            Path to a browser executable to run instead of the bundled one. If `executablePath` is a relative path, then it is resolved relative to current working directory. Note that Playwright only works with the bundled Chromium, Firefox or WebKit, use at your own risk.
        args : Optional[List[str]]
            Additional arguments to pass to the browser instance. The list of Chromium flags can be found here.
        ignoreDefaultArgs : Union[bool, List[str], NoneType]
            If `true`, Playwright does not pass its own configurations args and only uses the ones from `args`. If an array is given, then filters out the given default arguments. Dangerous option; use with care. Defaults to `false`.
        handleSIGINT : Optional[bool]
            Close the browser process on Ctrl-C. Defaults to `true`.
        handleSIGTERM : Optional[bool]
            Close the browser process on SIGTERM. Defaults to `true`.
        handleSIGHUP : Optional[bool]
            Close the browser process on SIGHUP. Defaults to `true`.
        timeout : Optional[int]
            Maximum time in milliseconds to wait for the browser instance to start. Defaults to `30000` (30 seconds). Pass `0` to disable timeout.
        env : Optional[Dict[str, Union[str, int, bool]]]
            Specify environment variables that will be visible to the browser. Defaults to `process.env`.
        headless : Optional[bool]
            Whether to run browser in headless mode. More details for Chromium and Firefox. Defaults to `true` unless the `devtools` option is `true`.
        devtools : Optional[bool]
            **Chromium-only** Whether to auto-open a Developer Tools panel for each tab. If this option is `true`, the `headless` option will be set `false`.
        proxy : Optional[{&#34;server&#34;: str, &#34;bypass&#34;: Optional[str], &#34;username&#34;: Optional[str], &#34;password&#34;: Optional[str]}]
            Network proxy settings.
        downloadsPath : Union[str, pathlib.Path, NoneType]
            If specified, accepted downloads are downloaded into this directory. Otherwise, temporary directory is created and is deleted when browser is closed.
        slowMo : Optional[int]
            Slows down Playwright operations by the specified amount of milliseconds. Useful so that you can see what is going on.
        chromiumSandbox : Optional[bool]
            Enable Chromium sandboxing. Defaults to `false`.
        firefoxUserPrefs : Optional[Dict[str, Union[str, int, bool]]]
            Firefox user preferences. Learn more about the Firefox user preferences at `about:config`.

        Returns
        -------
        Browser
            Promise which resolves to browser instance.
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.launch(
                    executablePath=executablePath,
                    args=args,
                    ignoreDefaultArgs=ignoreDefaultArgs,
                    handleSIGINT=handleSIGINT,
                    handleSIGTERM=handleSIGTERM,
                    handleSIGHUP=handleSIGHUP,
                    timeout=timeout,
                    env=mapping.to_impl(env),
                    headless=headless,
                    devtools=devtools,
                    proxy=proxy,
                    downloadsPath=downloadsPath,
                    slowMo=slowMo,
                    chromiumSandbox=chromiumSandbox,
                    firefoxUserPrefs=mapping.to_impl(firefoxUserPrefs),
                )
            )
        )

    def launchPersistentContext(
        self,
        userDataDir: typing.Union[str, pathlib.Path],
        executablePath: typing.Union[str, pathlib.Path] = None,
        args: typing.List[str] = None,
        ignoreDefaultArgs: typing.Union[bool, typing.List[str]] = None,
        handleSIGINT: bool = None,
        handleSIGTERM: bool = None,
        handleSIGHUP: bool = None,
        timeout: int = None,
        env: typing.Union[typing.Dict[str, typing.Union[str, int, bool]]] = None,
        headless: bool = None,
        devtools: bool = None,
        proxy: ProxyServer = None,
        downloadsPath: typing.Union[str, pathlib.Path] = None,
        slowMo: int = None,
        viewport: typing.Union[IntSize, Literal[0]] = None,
        ignoreHTTPSErrors: bool = None,
        javaScriptEnabled: bool = None,
        bypassCSP: bool = None,
        userAgent: str = None,
        locale: str = None,
        timezoneId: str = None,
        geolocation: Geolocation = None,
        permissions: typing.List[str] = None,
        extraHTTPHeaders: typing.Union[typing.Dict[str, str]] = None,
        offline: bool = None,
        httpCredentials: Credentials = None,
        deviceScaleFactor: int = None,
        isMobile: bool = None,
        hasTouch: bool = None,
        colorScheme: Literal[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;] = None,
        acceptDownloads: bool = None,
        chromiumSandbox: bool = None,
        videosPath: str = None,
        videoSize: IntSize = None,
        recordHar: RecordHarOptions = None,
        recordVideo: RecordVideoOptions = None,
    ) -&gt; &#34;BrowserContext&#34;:
        &#34;&#34;&#34;BrowserType.launchPersistentContext

        Launches browser that uses persistent storage located at `userDataDir` and returns the only context. Closing this context will automatically close the browser.

        Parameters
        ----------
        userDataDir : Union[str, pathlib.Path]
            Path to a User Data Directory, which stores browser session data like cookies and local storage. More details for Chromium and Firefox.
        executablePath : Union[str, pathlib.Path, NoneType]
            Path to a browser executable to run instead of the bundled one. If `executablePath` is a relative path, then it is resolved relative to current working directory. **BEWARE**: Playwright is only guaranteed to work with the bundled Chromium, Firefox or WebKit, use at your own risk.
        args : Optional[List[str]]
            Additional arguments to pass to the browser instance. The list of Chromium flags can be found here.
        ignoreDefaultArgs : Union[bool, List[str], NoneType]
            If `true`, then do not use any of the default arguments. If an array is given, then filter out the given default arguments. Dangerous option; use with care. Defaults to `false`.
        handleSIGINT : Optional[bool]
            Close the browser process on Ctrl-C. Defaults to `true`.
        handleSIGTERM : Optional[bool]
            Close the browser process on SIGTERM. Defaults to `true`.
        handleSIGHUP : Optional[bool]
            Close the browser process on SIGHUP. Defaults to `true`.
        timeout : Optional[int]
            Maximum time in milliseconds to wait for the browser instance to start. Defaults to `30000` (30 seconds). Pass `0` to disable timeout.
        env : Optional[Dict[str, Union[str, int, bool]]]
            Specify environment variables that will be visible to the browser. Defaults to `process.env`.
        headless : Optional[bool]
            Whether to run browser in headless mode. More details for Chromium and Firefox. Defaults to `true` unless the `devtools` option is `true`.
        devtools : Optional[bool]
            **Chromium-only** Whether to auto-open a Developer Tools panel for each tab. If this option is `true`, the `headless` option will be set `false`.
        proxy : Optional[{&#34;server&#34;: str, &#34;bypass&#34;: Optional[str], &#34;username&#34;: Optional[str], &#34;password&#34;: Optional[str]}]
            Network proxy settings.
        downloadsPath : Union[str, pathlib.Path, NoneType]
            If specified, accepted downloads are downloaded into this directory. Otherwise, temporary directory is created and is deleted when browser is closed.
        slowMo : Optional[int]
            Slows down Playwright operations by the specified amount of milliseconds. Useful so that you can see what is going on. Defaults to 0.
        viewport : Union[{&#34;width&#34;: int, &#34;height&#34;: int}, &#39;0&#39;, NoneType]
            Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. `null` disables the default viewport.
        ignoreHTTPSErrors : Optional[bool]
            Whether to ignore HTTPS errors during navigation. Defaults to `false`.
        javaScriptEnabled : Optional[bool]
            Whether or not to enable JavaScript in the context. Defaults to true.
        bypassCSP : Optional[bool]
            Toggles bypassing page&#39;s Content-Security-Policy.
        userAgent : Optional[str]
            Specific user agent to use in this context.
        locale : Optional[str]
            Specify user locale, for example `en-GB`, `de-DE`, etc. Locale will affect `navigator.language` value, `Accept-Language` request header value as well as number and date formatting rules.
        timezoneId : Optional[str]
            Changes the timezone of the context. See ICU’s `metaZones.txt` for a list of supported timezone IDs.
        geolocation : Optional[{&#34;latitude&#34;: float, &#34;longitude&#34;: float, &#34;accuracy&#34;: Optional[float]}]
        permissions : Optional[List[str]]
            A list of permissions to grant to all pages in this context. See browserContext.grantPermissions for more details.
        extraHTTPHeaders : Optional[Dict[str, str]]
            An object containing additional HTTP headers to be sent with every request. All header values must be strings.
        offline : Optional[bool]
            Whether to emulate network being offline. Defaults to `false`.
        httpCredentials : Optional[{&#34;username&#34;: str, &#34;password&#34;: str}]
            Credentials for HTTP authentication.
        deviceScaleFactor : Optional[int]
            Specify device scale factor (can be thought of as dpr). Defaults to `1`.
        isMobile : Optional[bool]
            Whether the `meta viewport` tag is taken into account and touch events are enabled. Defaults to `false`. Not supported in Firefox.
        hasTouch : Optional[bool]
            Specifies if viewport supports touch events. Defaults to false.
        colorScheme : Optional[Literal[&#39;dark&#39;, &#39;light&#39;, &#39;no-preference&#39;]]
            Emulates `&#39;prefers-colors-scheme&#39;` media feature, supported values are `&#39;light&#39;`, `&#39;dark&#39;`, `&#39;no-preference&#39;`. See page.emulateMedia(options) for more details. Defaults to &#39;`light`&#39;.
        acceptDownloads : Optional[bool]
            Whether to automatically download all the attachments. Defaults to `false` where all the downloads are canceled.
        chromiumSandbox : Optional[bool]
            Enable Chromium sandboxing. Defaults to `true`.
        videosPath : Optional[str]
            **NOTE** Use `recordVideo` instead, it takes precedence over `videosPath`. Enables video recording for all pages to `videosPath` directory. If not specified, videos are not recorded. Make sure to await `browserContext.close` for videos to be saved.
        videoSize : Optional[{&#34;width&#34;: int, &#34;height&#34;: int}]
            **NOTE** Use `recordVideo` instead, it takes precedence over `videoSize`. Specifies dimensions of the automatically recorded video. Can only be used if `videosPath` is set. If not specified the size will be equal to `viewport`. If `viewport` is not configured explicitly the video size defaults to 1280x720. Actual picture of the page will be scaled down if necessary to fit specified size.
        recordHar : Optional[{&#34;omitContent&#34;: Optional[bool], &#34;path&#34;: str}]
            Enables HAR recording for all the pages into `recordHar.path` file. If not specified, HAR is not recorded. Make sure to await `page.close` for HAR to be saved.
        recordVideo : Optional[{&#34;dir&#34;: str, &#34;size&#34;: Optional[{&#34;width&#34;: int, &#34;height&#34;: int}]}]
            Enables video recording for all pages into `recordVideo.dir` directory. If not specified videos are not recorded. Make sure to await `browserContext.close` for videos to be saved.

        Returns
        -------
        BrowserContext
            Promise that resolves to the persistent browser context instance.
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.launchPersistentContext(
                    userDataDir=userDataDir,
                    executablePath=executablePath,
                    args=args,
                    ignoreDefaultArgs=ignoreDefaultArgs,
                    handleSIGINT=handleSIGINT,
                    handleSIGTERM=handleSIGTERM,
                    handleSIGHUP=handleSIGHUP,
                    timeout=timeout,
                    env=mapping.to_impl(env),
                    headless=headless,
                    devtools=devtools,
                    proxy=proxy,
                    downloadsPath=downloadsPath,
                    slowMo=slowMo,
                    viewport=viewport,
                    ignoreHTTPSErrors=ignoreHTTPSErrors,
                    javaScriptEnabled=javaScriptEnabled,
                    bypassCSP=bypassCSP,
                    userAgent=userAgent,
                    locale=locale,
                    timezoneId=timezoneId,
                    geolocation=geolocation,
                    permissions=permissions,
                    extraHTTPHeaders=mapping.to_impl(extraHTTPHeaders),
                    offline=offline,
                    httpCredentials=httpCredentials,
                    deviceScaleFactor=deviceScaleFactor,
                    isMobile=isMobile,
                    hasTouch=hasTouch,
                    colorScheme=colorScheme,
                    acceptDownloads=acceptDownloads,
                    chromiumSandbox=chromiumSandbox,
                    videosPath=videosPath,
                    videoSize=videoSize,
                    recordHar=recordHar,
                    recordVideo=recordVideo,
                )
            )
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright.sync_base.SyncBase</li>
<li>playwright.impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.sync_api.BrowserType.executablePath"><code class="name">var <span class="ident">executablePath</span> : str</code></dt>
<dd>
<div class="desc"><p>BrowserType.executablePath</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A path where Playwright expects to find a bundled browser executable.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def executablePath(self) -&gt; str:
    &#34;&#34;&#34;BrowserType.executablePath

    Returns
    -------
    str
        A path where Playwright expects to find a bundled browser executable.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.executablePath)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.BrowserType.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>BrowserType.name</p>
<p>Returns browser name. For example: <code>'chromium'</code>, <code>'webkit'</code> or <code>'firefox'</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;BrowserType.name

    Returns browser name. For example: `&#39;chromium&#39;`, `&#39;webkit&#39;` or `&#39;firefox&#39;`.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.name)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.sync_api.BrowserType.launch"><code class="name flex">
<span>def <span class="ident">launch</span></span>(<span>self, executablePath: Union[str, pathlib.Path] = None, args: List[str] = None, ignoreDefaultArgs: Union[bool, List[str]] = None, handleSIGINT: bool = None, handleSIGTERM: bool = None, handleSIGHUP: bool = None, timeout: int = None, env: Dict[str, Union[str, int, bool]] = None, headless: bool = None, devtools: bool = None, proxy: playwright.helper.ProxyServer = None, downloadsPath: Union[str, pathlib.Path] = None, slowMo: int = None, chromiumSandbox: bool = None, firefoxUserPrefs: Dict[str, Union[str, int, bool]] = None) ‑> <a title="playwright.sync_api.Browser" href="#playwright.sync_api.Browser">Browser</a></span>
</code></dt>
<dd>
<div class="desc"><p>BrowserType.launch</p>
<p>You can use <code>ignoreDefaultArgs</code> to filter out <code>--mute-audio</code> from default arguments:</p>
<p><strong>Chromium-only</strong> Playwright can also be used to control the Chrome browser, but it works best with the version of Chromium it is bundled with. There is no guarantee it will work with any other version. Use <code>executablePath</code> option with extreme caution.
If Google Chrome (rather than Chromium) is preferred, a Chrome Canary or Dev Channel build is suggested.
In browserType.launch([options]) above, any mention of Chromium also applies to Chrome.
See <code>this article</code> for a description of the differences between Chromium and Chrome. <code>This article</code> describes some differences for Linux users.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>executablePath</code></strong> :&ensp;<code>Union[str, pathlib.Path, NoneType]</code></dt>
<dd>Path to a browser executable to run instead of the bundled one. If <code>executablePath</code> is a relative path, then it is resolved relative to current working directory. Note that Playwright only works with the bundled Chromium, Firefox or WebKit, use at your own risk.</dd>
<dt><strong><code>args</code></strong> :&ensp;<code>Optional[List[str]]</code></dt>
<dd>Additional arguments to pass to the browser instance. The list of Chromium flags can be found here.</dd>
<dt><strong><code>ignoreDefaultArgs</code></strong> :&ensp;<code>Union[bool, List[str], NoneType]</code></dt>
<dd>If <code>true</code>, Playwright does not pass its own configurations args and only uses the ones from <code>args</code>. If an array is given, then filters out the given default arguments. Dangerous option; use with care. Defaults to <code>false</code>.</dd>
<dt><strong><code>handleSIGINT</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Close the browser process on Ctrl-C. Defaults to <code>true</code>.</dd>
<dt><strong><code>handleSIGTERM</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Close the browser process on SIGTERM. Defaults to <code>true</code>.</dd>
<dt><strong><code>handleSIGHUP</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Close the browser process on SIGHUP. Defaults to <code>true</code>.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds to wait for the browser instance to start. Defaults to <code>30000</code> (30 seconds). Pass <code>0</code> to disable timeout.</dd>
<dt><strong><code>env</code></strong> :&ensp;<code>Optional[Dict[str, Union[str, int, bool]]]</code></dt>
<dd>Specify environment variables that will be visible to the browser. Defaults to <code>process.env</code>.</dd>
<dt><strong><code>headless</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to run browser in headless mode. More details for Chromium and Firefox. Defaults to <code>true</code> unless the <code>devtools</code> option is <code>true</code>.</dd>
<dt><strong><code>devtools</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd><strong>Chromium-only</strong> Whether to auto-open a Developer Tools panel for each tab. If this option is <code>true</code>, the <code>headless</code> option will be set <code>false</code>.</dd>
<dt><strong><code>proxy</code></strong> :&ensp;<code>Optional[{"server": str, "bypass": Optional[str], "username": Optional[str], "password": Optional[str]}]</code></dt>
<dd>Network proxy settings.</dd>
<dt><strong><code>downloadsPath</code></strong> :&ensp;<code>Union[str, pathlib.Path, NoneType]</code></dt>
<dd>If specified, accepted downloads are downloaded into this directory. Otherwise, temporary directory is created and is deleted when browser is closed.</dd>
<dt><strong><code>slowMo</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Slows down Playwright operations by the specified amount of milliseconds. Useful so that you can see what is going on.</dd>
<dt><strong><code>chromiumSandbox</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Enable Chromium sandboxing. Defaults to <code>false</code>.</dd>
<dt><strong><code>firefoxUserPrefs</code></strong> :&ensp;<code>Optional[Dict[str, Union[str, int, bool]]]</code></dt>
<dd>Firefox user preferences. Learn more about the Firefox user preferences at <code>about:config</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.Browser" href="#playwright.sync_api.Browser">Browser</a></code></dt>
<dd>Promise which resolves to browser instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def launch(
    self,
    executablePath: typing.Union[str, pathlib.Path] = None,
    args: typing.List[str] = None,
    ignoreDefaultArgs: typing.Union[bool, typing.List[str]] = None,
    handleSIGINT: bool = None,
    handleSIGTERM: bool = None,
    handleSIGHUP: bool = None,
    timeout: int = None,
    env: typing.Union[typing.Dict[str, typing.Union[str, int, bool]]] = None,
    headless: bool = None,
    devtools: bool = None,
    proxy: ProxyServer = None,
    downloadsPath: typing.Union[str, pathlib.Path] = None,
    slowMo: int = None,
    chromiumSandbox: bool = None,
    firefoxUserPrefs: typing.Union[
        typing.Dict[str, typing.Union[str, int, bool]]
    ] = None,
) -&gt; &#34;Browser&#34;:
    &#34;&#34;&#34;BrowserType.launch

    You can use `ignoreDefaultArgs` to filter out `--mute-audio` from default arguments:

    **Chromium-only** Playwright can also be used to control the Chrome browser, but it works best with the version of Chromium it is bundled with. There is no guarantee it will work with any other version. Use `executablePath` option with extreme caution.
    If Google Chrome (rather than Chromium) is preferred, a Chrome Canary or Dev Channel build is suggested.
    In browserType.launch([options]) above, any mention of Chromium also applies to Chrome.
    See `this article` for a description of the differences between Chromium and Chrome. `This article` describes some differences for Linux users.

    Parameters
    ----------
    executablePath : Union[str, pathlib.Path, NoneType]
        Path to a browser executable to run instead of the bundled one. If `executablePath` is a relative path, then it is resolved relative to current working directory. Note that Playwright only works with the bundled Chromium, Firefox or WebKit, use at your own risk.
    args : Optional[List[str]]
        Additional arguments to pass to the browser instance. The list of Chromium flags can be found here.
    ignoreDefaultArgs : Union[bool, List[str], NoneType]
        If `true`, Playwright does not pass its own configurations args and only uses the ones from `args`. If an array is given, then filters out the given default arguments. Dangerous option; use with care. Defaults to `false`.
    handleSIGINT : Optional[bool]
        Close the browser process on Ctrl-C. Defaults to `true`.
    handleSIGTERM : Optional[bool]
        Close the browser process on SIGTERM. Defaults to `true`.
    handleSIGHUP : Optional[bool]
        Close the browser process on SIGHUP. Defaults to `true`.
    timeout : Optional[int]
        Maximum time in milliseconds to wait for the browser instance to start. Defaults to `30000` (30 seconds). Pass `0` to disable timeout.
    env : Optional[Dict[str, Union[str, int, bool]]]
        Specify environment variables that will be visible to the browser. Defaults to `process.env`.
    headless : Optional[bool]
        Whether to run browser in headless mode. More details for Chromium and Firefox. Defaults to `true` unless the `devtools` option is `true`.
    devtools : Optional[bool]
        **Chromium-only** Whether to auto-open a Developer Tools panel for each tab. If this option is `true`, the `headless` option will be set `false`.
    proxy : Optional[{&#34;server&#34;: str, &#34;bypass&#34;: Optional[str], &#34;username&#34;: Optional[str], &#34;password&#34;: Optional[str]}]
        Network proxy settings.
    downloadsPath : Union[str, pathlib.Path, NoneType]
        If specified, accepted downloads are downloaded into this directory. Otherwise, temporary directory is created and is deleted when browser is closed.
    slowMo : Optional[int]
        Slows down Playwright operations by the specified amount of milliseconds. Useful so that you can see what is going on.
    chromiumSandbox : Optional[bool]
        Enable Chromium sandboxing. Defaults to `false`.
    firefoxUserPrefs : Optional[Dict[str, Union[str, int, bool]]]
        Firefox user preferences. Learn more about the Firefox user preferences at `about:config`.

    Returns
    -------
    Browser
        Promise which resolves to browser instance.
    &#34;&#34;&#34;
    return mapping.from_impl(
        self._sync(
            self._impl_obj.launch(
                executablePath=executablePath,
                args=args,
                ignoreDefaultArgs=ignoreDefaultArgs,
                handleSIGINT=handleSIGINT,
                handleSIGTERM=handleSIGTERM,
                handleSIGHUP=handleSIGHUP,
                timeout=timeout,
                env=mapping.to_impl(env),
                headless=headless,
                devtools=devtools,
                proxy=proxy,
                downloadsPath=downloadsPath,
                slowMo=slowMo,
                chromiumSandbox=chromiumSandbox,
                firefoxUserPrefs=mapping.to_impl(firefoxUserPrefs),
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.BrowserType.launchPersistentContext"><code class="name flex">
<span>def <span class="ident">launchPersistentContext</span></span>(<span>self, userDataDir: Union[str, pathlib.Path], executablePath: Union[str, pathlib.Path] = None, args: List[str] = None, ignoreDefaultArgs: Union[bool, List[str]] = None, handleSIGINT: bool = None, handleSIGTERM: bool = None, handleSIGHUP: bool = None, timeout: int = None, env: Dict[str, Union[str, int, bool]] = None, headless: bool = None, devtools: bool = None, proxy: playwright.helper.ProxyServer = None, downloadsPath: Union[str, pathlib.Path] = None, slowMo: int = None, viewport: Union[playwright.helper.IntSize, Literal[0]] = None, ignoreHTTPSErrors: bool = None, javaScriptEnabled: bool = None, bypassCSP: bool = None, userAgent: str = None, locale: str = None, timezoneId: str = None, geolocation: playwright.helper.Geolocation = None, permissions: List[str] = None, extraHTTPHeaders: Dict[str, str] = None, offline: bool = None, httpCredentials: playwright.helper.Credentials = None, deviceScaleFactor: int = None, isMobile: bool = None, hasTouch: bool = None, colorScheme: Literal['dark', 'light', 'no-preference'] = None, acceptDownloads: bool = None, chromiumSandbox: bool = None, videosPath: str = None, videoSize: playwright.helper.IntSize = None, recordHar: playwright.helper.RecordHarOptions = None, recordVideo: playwright.helper.RecordVideoOptions = None) ‑> <a title="playwright.sync_api.BrowserContext" href="#playwright.sync_api.BrowserContext">BrowserContext</a></span>
</code></dt>
<dd>
<div class="desc"><p>BrowserType.launchPersistentContext</p>
<p>Launches browser that uses persistent storage located at <code>userDataDir</code> and returns the only context. Closing this context will automatically close the browser.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>userDataDir</code></strong> :&ensp;<code>Union[str, pathlib.Path]</code></dt>
<dd>Path to a User Data Directory, which stores browser session data like cookies and local storage. More details for Chromium and Firefox.</dd>
<dt><strong><code>executablePath</code></strong> :&ensp;<code>Union[str, pathlib.Path, NoneType]</code></dt>
<dd>Path to a browser executable to run instead of the bundled one. If <code>executablePath</code> is a relative path, then it is resolved relative to current working directory. <strong>BEWARE</strong>: Playwright is only guaranteed to work with the bundled Chromium, Firefox or WebKit, use at your own risk.</dd>
<dt><strong><code>args</code></strong> :&ensp;<code>Optional[List[str]]</code></dt>
<dd>Additional arguments to pass to the browser instance. The list of Chromium flags can be found here.</dd>
<dt><strong><code>ignoreDefaultArgs</code></strong> :&ensp;<code>Union[bool, List[str], NoneType]</code></dt>
<dd>If <code>true</code>, then do not use any of the default arguments. If an array is given, then filter out the given default arguments. Dangerous option; use with care. Defaults to <code>false</code>.</dd>
<dt><strong><code>handleSIGINT</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Close the browser process on Ctrl-C. Defaults to <code>true</code>.</dd>
<dt><strong><code>handleSIGTERM</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Close the browser process on SIGTERM. Defaults to <code>true</code>.</dd>
<dt><strong><code>handleSIGHUP</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Close the browser process on SIGHUP. Defaults to <code>true</code>.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds to wait for the browser instance to start. Defaults to <code>30000</code> (30 seconds). Pass <code>0</code> to disable timeout.</dd>
<dt><strong><code>env</code></strong> :&ensp;<code>Optional[Dict[str, Union[str, int, bool]]]</code></dt>
<dd>Specify environment variables that will be visible to the browser. Defaults to <code>process.env</code>.</dd>
<dt><strong><code>headless</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to run browser in headless mode. More details for Chromium and Firefox. Defaults to <code>true</code> unless the <code>devtools</code> option is <code>true</code>.</dd>
<dt><strong><code>devtools</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd><strong>Chromium-only</strong> Whether to auto-open a Developer Tools panel for each tab. If this option is <code>true</code>, the <code>headless</code> option will be set <code>false</code>.</dd>
<dt><strong><code>proxy</code></strong> :&ensp;<code>Optional[{"server": str, "bypass": Optional[str], "username": Optional[str], "password": Optional[str]}]</code></dt>
<dd>Network proxy settings.</dd>
<dt><strong><code>downloadsPath</code></strong> :&ensp;<code>Union[str, pathlib.Path, NoneType]</code></dt>
<dd>If specified, accepted downloads are downloaded into this directory. Otherwise, temporary directory is created and is deleted when browser is closed.</dd>
<dt><strong><code>slowMo</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Slows down Playwright operations by the specified amount of milliseconds. Useful so that you can see what is going on. Defaults to 0.</dd>
<dt><strong><code>viewport</code></strong> :&ensp;<code>Union[{"width": int, "height": int}, '0', NoneType]</code></dt>
<dd>Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. <code>null</code> disables the default viewport.</dd>
<dt><strong><code>ignoreHTTPSErrors</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to ignore HTTPS errors during navigation. Defaults to <code>false</code>.</dd>
<dt><strong><code>javaScriptEnabled</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether or not to enable JavaScript in the context. Defaults to true.</dd>
<dt><strong><code>bypassCSP</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Toggles bypassing page's Content-Security-Policy.</dd>
<dt><strong><code>userAgent</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Specific user agent to use in this context.</dd>
<dt><strong><code>locale</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Specify user locale, for example <code>en-GB</code>, <code>de-DE</code>, etc. Locale will affect <code>navigator.language</code> value, <code>Accept-Language</code> request header value as well as number and date formatting rules.</dd>
<dt><strong><code>timezoneId</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Changes the timezone of the context. See ICU’s <code>metaZones.txt</code> for a list of supported timezone IDs.</dd>
<dt><strong><code>geolocation</code></strong> :&ensp;<code>Optional[{"latitude": float, "longitude": float, "accuracy": Optional[float]}]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>permissions</code></strong> :&ensp;<code>Optional[List[str]]</code></dt>
<dd>A list of permissions to grant to all pages in this context. See browserContext.grantPermissions for more details.</dd>
<dt><strong><code>extraHTTPHeaders</code></strong> :&ensp;<code>Optional[Dict[str, str]]</code></dt>
<dd>An object containing additional HTTP headers to be sent with every request. All header values must be strings.</dd>
<dt><strong><code>offline</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to emulate network being offline. Defaults to <code>false</code>.</dd>
<dt><strong><code>httpCredentials</code></strong> :&ensp;<code>Optional[{"username": str, "password": str}]</code></dt>
<dd>Credentials for HTTP authentication.</dd>
<dt><strong><code>deviceScaleFactor</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Specify device scale factor (can be thought of as dpr). Defaults to <code>1</code>.</dd>
<dt><strong><code>isMobile</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether the <code>meta viewport</code> tag is taken into account and touch events are enabled. Defaults to <code>false</code>. Not supported in Firefox.</dd>
<dt><strong><code>hasTouch</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Specifies if viewport supports touch events. Defaults to false.</dd>
<dt><strong><code>colorScheme</code></strong> :&ensp;<code>Optional[Literal['dark', 'light', 'no-preference']]</code></dt>
<dd>Emulates <code>'prefers-colors-scheme'</code> media feature, supported values are <code>'light'</code>, <code>'dark'</code>, <code>'no-preference'</code>. See page.emulateMedia(options) for more details. Defaults to '<code>light</code>'.</dd>
<dt><strong><code>acceptDownloads</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to automatically download all the attachments. Defaults to <code>false</code> where all the downloads are canceled.</dd>
<dt><strong><code>chromiumSandbox</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Enable Chromium sandboxing. Defaults to <code>true</code>.</dd>
<dt><strong><code>videosPath</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd><strong>NOTE</strong> Use <code>recordVideo</code> instead, it takes precedence over <code>videosPath</code>. Enables video recording for all pages to <code>videosPath</code> directory. If not specified, videos are not recorded. Make sure to await <code>browserContext.close</code> for videos to be saved.</dd>
<dt><strong><code>videoSize</code></strong> :&ensp;<code>Optional[{"width": int, "height": int}]</code></dt>
<dd><strong>NOTE</strong> Use <code>recordVideo</code> instead, it takes precedence over <code>videoSize</code>. Specifies dimensions of the automatically recorded video. Can only be used if <code>videosPath</code> is set. If not specified the size will be equal to <code>viewport</code>. If <code>viewport</code> is not configured explicitly the video size defaults to 1280x720. Actual picture of the page will be scaled down if necessary to fit specified size.</dd>
<dt><strong><code>recordHar</code></strong> :&ensp;<code>Optional[{"omitContent": Optional[bool], "path": str}]</code></dt>
<dd>Enables HAR recording for all the pages into <code>recordHar.path</code> file. If not specified, HAR is not recorded. Make sure to await <code>page.close</code> for HAR to be saved.</dd>
<dt><strong><code>recordVideo</code></strong> :&ensp;<code>Optional[{"dir": str, "size": Optional[{"width": int, "height": int}]}]</code></dt>
<dd>Enables video recording for all pages into <code>recordVideo.dir</code> directory. If not specified videos are not recorded. Make sure to await <code>browserContext.close</code> for videos to be saved.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.BrowserContext" href="#playwright.sync_api.BrowserContext">BrowserContext</a></code></dt>
<dd>Promise that resolves to the persistent browser context instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def launchPersistentContext(
    self,
    userDataDir: typing.Union[str, pathlib.Path],
    executablePath: typing.Union[str, pathlib.Path] = None,
    args: typing.List[str] = None,
    ignoreDefaultArgs: typing.Union[bool, typing.List[str]] = None,
    handleSIGINT: bool = None,
    handleSIGTERM: bool = None,
    handleSIGHUP: bool = None,
    timeout: int = None,
    env: typing.Union[typing.Dict[str, typing.Union[str, int, bool]]] = None,
    headless: bool = None,
    devtools: bool = None,
    proxy: ProxyServer = None,
    downloadsPath: typing.Union[str, pathlib.Path] = None,
    slowMo: int = None,
    viewport: typing.Union[IntSize, Literal[0]] = None,
    ignoreHTTPSErrors: bool = None,
    javaScriptEnabled: bool = None,
    bypassCSP: bool = None,
    userAgent: str = None,
    locale: str = None,
    timezoneId: str = None,
    geolocation: Geolocation = None,
    permissions: typing.List[str] = None,
    extraHTTPHeaders: typing.Union[typing.Dict[str, str]] = None,
    offline: bool = None,
    httpCredentials: Credentials = None,
    deviceScaleFactor: int = None,
    isMobile: bool = None,
    hasTouch: bool = None,
    colorScheme: Literal[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;] = None,
    acceptDownloads: bool = None,
    chromiumSandbox: bool = None,
    videosPath: str = None,
    videoSize: IntSize = None,
    recordHar: RecordHarOptions = None,
    recordVideo: RecordVideoOptions = None,
) -&gt; &#34;BrowserContext&#34;:
    &#34;&#34;&#34;BrowserType.launchPersistentContext

    Launches browser that uses persistent storage located at `userDataDir` and returns the only context. Closing this context will automatically close the browser.

    Parameters
    ----------
    userDataDir : Union[str, pathlib.Path]
        Path to a User Data Directory, which stores browser session data like cookies and local storage. More details for Chromium and Firefox.
    executablePath : Union[str, pathlib.Path, NoneType]
        Path to a browser executable to run instead of the bundled one. If `executablePath` is a relative path, then it is resolved relative to current working directory. **BEWARE**: Playwright is only guaranteed to work with the bundled Chromium, Firefox or WebKit, use at your own risk.
    args : Optional[List[str]]
        Additional arguments to pass to the browser instance. The list of Chromium flags can be found here.
    ignoreDefaultArgs : Union[bool, List[str], NoneType]
        If `true`, then do not use any of the default arguments. If an array is given, then filter out the given default arguments. Dangerous option; use with care. Defaults to `false`.
    handleSIGINT : Optional[bool]
        Close the browser process on Ctrl-C. Defaults to `true`.
    handleSIGTERM : Optional[bool]
        Close the browser process on SIGTERM. Defaults to `true`.
    handleSIGHUP : Optional[bool]
        Close the browser process on SIGHUP. Defaults to `true`.
    timeout : Optional[int]
        Maximum time in milliseconds to wait for the browser instance to start. Defaults to `30000` (30 seconds). Pass `0` to disable timeout.
    env : Optional[Dict[str, Union[str, int, bool]]]
        Specify environment variables that will be visible to the browser. Defaults to `process.env`.
    headless : Optional[bool]
        Whether to run browser in headless mode. More details for Chromium and Firefox. Defaults to `true` unless the `devtools` option is `true`.
    devtools : Optional[bool]
        **Chromium-only** Whether to auto-open a Developer Tools panel for each tab. If this option is `true`, the `headless` option will be set `false`.
    proxy : Optional[{&#34;server&#34;: str, &#34;bypass&#34;: Optional[str], &#34;username&#34;: Optional[str], &#34;password&#34;: Optional[str]}]
        Network proxy settings.
    downloadsPath : Union[str, pathlib.Path, NoneType]
        If specified, accepted downloads are downloaded into this directory. Otherwise, temporary directory is created and is deleted when browser is closed.
    slowMo : Optional[int]
        Slows down Playwright operations by the specified amount of milliseconds. Useful so that you can see what is going on. Defaults to 0.
    viewport : Union[{&#34;width&#34;: int, &#34;height&#34;: int}, &#39;0&#39;, NoneType]
        Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. `null` disables the default viewport.
    ignoreHTTPSErrors : Optional[bool]
        Whether to ignore HTTPS errors during navigation. Defaults to `false`.
    javaScriptEnabled : Optional[bool]
        Whether or not to enable JavaScript in the context. Defaults to true.
    bypassCSP : Optional[bool]
        Toggles bypassing page&#39;s Content-Security-Policy.
    userAgent : Optional[str]
        Specific user agent to use in this context.
    locale : Optional[str]
        Specify user locale, for example `en-GB`, `de-DE`, etc. Locale will affect `navigator.language` value, `Accept-Language` request header value as well as number and date formatting rules.
    timezoneId : Optional[str]
        Changes the timezone of the context. See ICU’s `metaZones.txt` for a list of supported timezone IDs.
    geolocation : Optional[{&#34;latitude&#34;: float, &#34;longitude&#34;: float, &#34;accuracy&#34;: Optional[float]}]
    permissions : Optional[List[str]]
        A list of permissions to grant to all pages in this context. See browserContext.grantPermissions for more details.
    extraHTTPHeaders : Optional[Dict[str, str]]
        An object containing additional HTTP headers to be sent with every request. All header values must be strings.
    offline : Optional[bool]
        Whether to emulate network being offline. Defaults to `false`.
    httpCredentials : Optional[{&#34;username&#34;: str, &#34;password&#34;: str}]
        Credentials for HTTP authentication.
    deviceScaleFactor : Optional[int]
        Specify device scale factor (can be thought of as dpr). Defaults to `1`.
    isMobile : Optional[bool]
        Whether the `meta viewport` tag is taken into account and touch events are enabled. Defaults to `false`. Not supported in Firefox.
    hasTouch : Optional[bool]
        Specifies if viewport supports touch events. Defaults to false.
    colorScheme : Optional[Literal[&#39;dark&#39;, &#39;light&#39;, &#39;no-preference&#39;]]
        Emulates `&#39;prefers-colors-scheme&#39;` media feature, supported values are `&#39;light&#39;`, `&#39;dark&#39;`, `&#39;no-preference&#39;`. See page.emulateMedia(options) for more details. Defaults to &#39;`light`&#39;.
    acceptDownloads : Optional[bool]
        Whether to automatically download all the attachments. Defaults to `false` where all the downloads are canceled.
    chromiumSandbox : Optional[bool]
        Enable Chromium sandboxing. Defaults to `true`.
    videosPath : Optional[str]
        **NOTE** Use `recordVideo` instead, it takes precedence over `videosPath`. Enables video recording for all pages to `videosPath` directory. If not specified, videos are not recorded. Make sure to await `browserContext.close` for videos to be saved.
    videoSize : Optional[{&#34;width&#34;: int, &#34;height&#34;: int}]
        **NOTE** Use `recordVideo` instead, it takes precedence over `videoSize`. Specifies dimensions of the automatically recorded video. Can only be used if `videosPath` is set. If not specified the size will be equal to `viewport`. If `viewport` is not configured explicitly the video size defaults to 1280x720. Actual picture of the page will be scaled down if necessary to fit specified size.
    recordHar : Optional[{&#34;omitContent&#34;: Optional[bool], &#34;path&#34;: str}]
        Enables HAR recording for all the pages into `recordHar.path` file. If not specified, HAR is not recorded. Make sure to await `page.close` for HAR to be saved.
    recordVideo : Optional[{&#34;dir&#34;: str, &#34;size&#34;: Optional[{&#34;width&#34;: int, &#34;height&#34;: int}]}]
        Enables video recording for all pages into `recordVideo.dir` directory. If not specified videos are not recorded. Make sure to await `browserContext.close` for videos to be saved.

    Returns
    -------
    BrowserContext
        Promise that resolves to the persistent browser context instance.
    &#34;&#34;&#34;
    return mapping.from_impl(
        self._sync(
            self._impl_obj.launchPersistentContext(
                userDataDir=userDataDir,
                executablePath=executablePath,
                args=args,
                ignoreDefaultArgs=ignoreDefaultArgs,
                handleSIGINT=handleSIGINT,
                handleSIGTERM=handleSIGTERM,
                handleSIGHUP=handleSIGHUP,
                timeout=timeout,
                env=mapping.to_impl(env),
                headless=headless,
                devtools=devtools,
                proxy=proxy,
                downloadsPath=downloadsPath,
                slowMo=slowMo,
                viewport=viewport,
                ignoreHTTPSErrors=ignoreHTTPSErrors,
                javaScriptEnabled=javaScriptEnabled,
                bypassCSP=bypassCSP,
                userAgent=userAgent,
                locale=locale,
                timezoneId=timezoneId,
                geolocation=geolocation,
                permissions=permissions,
                extraHTTPHeaders=mapping.to_impl(extraHTTPHeaders),
                offline=offline,
                httpCredentials=httpCredentials,
                deviceScaleFactor=deviceScaleFactor,
                isMobile=isMobile,
                hasTouch=hasTouch,
                colorScheme=colorScheme,
                acceptDownloads=acceptDownloads,
                chromiumSandbox=chromiumSandbox,
                videosPath=videosPath,
                videoSize=videoSize,
                recordHar=recordHar,
                recordVideo=recordVideo,
            )
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.sync_api.CDPSession"><code class="flex name class">
<span>class <span class="ident">CDPSession</span></span>
<span>(</span><span>obj: playwright.cdp_session.CDPSession)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CDPSession(SyncBase):
    def __init__(self, obj: CDPSessionImpl):
        super().__init__(obj)

    def send(self, method: str, params: typing.Dict = None) -&gt; typing.Dict:
        &#34;&#34;&#34;CDPSession.send

        Parameters
        ----------
        method : str
            protocol method name
        params : Optional[Dict]
            Optional method parameters

        Returns
        -------
        Dict
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.send(method=method, params=mapping.to_impl(params))
            )
        )

    def detach(self) -&gt; NoneType:
        &#34;&#34;&#34;CDPSession.detach

        Detaches the CDPSession from the target. Once detached, the CDPSession object won&#39;t emit any events and can&#39;t be used
        to send messages.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.detach()))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright.sync_base.SyncBase</li>
<li>playwright.impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="playwright.sync_api.CDPSession.detach"><code class="name flex">
<span>def <span class="ident">detach</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>CDPSession.detach</p>
<p>Detaches the CDPSession from the target. Once detached, the CDPSession object won't emit any events and can't be used
to send messages.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detach(self) -&gt; NoneType:
    &#34;&#34;&#34;CDPSession.detach

    Detaches the CDPSession from the target. Once detached, the CDPSession object won&#39;t emit any events and can&#39;t be used
    to send messages.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.detach()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.CDPSession.send"><code class="name flex">
<span>def <span class="ident">send</span></span>(<span>self, method: str, params: Dict = None) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>CDPSession.send</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code></dt>
<dd>protocol method name</dd>
<dt><strong><code>params</code></strong> :&ensp;<code>Optional[Dict]</code></dt>
<dd>Optional method parameters</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send(self, method: str, params: typing.Dict = None) -&gt; typing.Dict:
    &#34;&#34;&#34;CDPSession.send

    Parameters
    ----------
    method : str
        protocol method name
    params : Optional[Dict]
        Optional method parameters

    Returns
    -------
    Dict
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.send(method=method, params=mapping.to_impl(params))
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.sync_api.ChromiumBrowserContext"><code class="flex name class">
<span>class <span class="ident">ChromiumBrowserContext</span></span>
<span>(</span><span>obj: playwright.chromium_browser_context.ChromiumBrowserContext)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChromiumBrowserContext(BrowserContext):
    def __init__(self, obj: ChromiumBrowserContextImpl):
        super().__init__(obj)

    def backgroundPages(self) -&gt; typing.List[&#34;Page&#34;]:
        &#34;&#34;&#34;ChromiumBrowserContext.backgroundPages

        Returns
        -------
        List[Page]
            All existing background pages in the context.
        &#34;&#34;&#34;
        return mapping.from_impl_list(self._impl_obj.backgroundPages())

    def serviceWorkers(self) -&gt; typing.List[&#34;Worker&#34;]:
        &#34;&#34;&#34;ChromiumBrowserContext.serviceWorkers

        Returns
        -------
        List[Worker]
            All existing service workers in the context.
        &#34;&#34;&#34;
        return mapping.from_impl_list(self._impl_obj.serviceWorkers())

    def newCDPSession(self, page: &#34;Page&#34;) -&gt; &#34;CDPSession&#34;:
        &#34;&#34;&#34;ChromiumBrowserContext.newCDPSession

        Parameters
        ----------
        page : Page
            Page to create new session for.

        Returns
        -------
        CDPSession
            Promise that resolves to the newly created session.
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(self._impl_obj.newCDPSession(page=page._impl_obj))
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="playwright.sync_api.BrowserContext" href="#playwright.sync_api.BrowserContext">BrowserContext</a></li>
<li>playwright.sync_base.SyncBase</li>
<li>playwright.impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="playwright.sync_api.ChromiumBrowserContext.backgroundPages"><code class="name flex">
<span>def <span class="ident">backgroundPages</span></span>(<span>self) ‑> List[<a title="playwright.async_api.Page" href="async_api.html#playwright.async_api.Page">Page</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>ChromiumBrowserContext.backgroundPages</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="playwright.sync_api.Page" href="#playwright.sync_api.Page">Page</a>]</code></dt>
<dd>All existing background pages in the context.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def backgroundPages(self) -&gt; typing.List[&#34;Page&#34;]:
    &#34;&#34;&#34;ChromiumBrowserContext.backgroundPages

    Returns
    -------
    List[Page]
        All existing background pages in the context.
    &#34;&#34;&#34;
    return mapping.from_impl_list(self._impl_obj.backgroundPages())</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ChromiumBrowserContext.newCDPSession"><code class="name flex">
<span>def <span class="ident">newCDPSession</span></span>(<span>self, page: <a title="playwright.sync_api.Page" href="#playwright.sync_api.Page">Page</a>) ‑> <a title="playwright.sync_api.CDPSession" href="#playwright.sync_api.CDPSession">CDPSession</a></span>
</code></dt>
<dd>
<div class="desc"><p>ChromiumBrowserContext.newCDPSession</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>page</code></strong> :&ensp;<code><a title="playwright.sync_api.Page" href="#playwright.sync_api.Page">Page</a></code></dt>
<dd>Page to create new session for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.CDPSession" href="#playwright.sync_api.CDPSession">CDPSession</a></code></dt>
<dd>Promise that resolves to the newly created session.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newCDPSession(self, page: &#34;Page&#34;) -&gt; &#34;CDPSession&#34;:
    &#34;&#34;&#34;ChromiumBrowserContext.newCDPSession

    Parameters
    ----------
    page : Page
        Page to create new session for.

    Returns
    -------
    CDPSession
        Promise that resolves to the newly created session.
    &#34;&#34;&#34;
    return mapping.from_impl(
        self._sync(self._impl_obj.newCDPSession(page=page._impl_obj))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ChromiumBrowserContext.serviceWorkers"><code class="name flex">
<span>def <span class="ident">serviceWorkers</span></span>(<span>self) ‑> List[<a title="playwright.async_api.Worker" href="async_api.html#playwright.async_api.Worker">Worker</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>ChromiumBrowserContext.serviceWorkers</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="playwright.sync_api.Worker" href="#playwright.sync_api.Worker">Worker</a>]</code></dt>
<dd>All existing service workers in the context.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serviceWorkers(self) -&gt; typing.List[&#34;Worker&#34;]:
    &#34;&#34;&#34;ChromiumBrowserContext.serviceWorkers

    Returns
    -------
    List[Worker]
        All existing service workers in the context.
    &#34;&#34;&#34;
    return mapping.from_impl_list(self._impl_obj.serviceWorkers())</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="playwright.sync_api.BrowserContext" href="#playwright.sync_api.BrowserContext">BrowserContext</a></b></code>:
<ul class="hlist">
<li><code><a title="playwright.sync_api.BrowserContext.addCookies" href="#playwright.sync_api.BrowserContext.addCookies">addCookies</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.addInitScript" href="#playwright.sync_api.BrowserContext.addInitScript">addInitScript</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.browser" href="#playwright.sync_api.BrowserContext.browser">browser</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.clearCookies" href="#playwright.sync_api.BrowserContext.clearCookies">clearCookies</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.clearPermissions" href="#playwright.sync_api.BrowserContext.clearPermissions">clearPermissions</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.close" href="#playwright.sync_api.BrowserContext.close">close</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.cookies" href="#playwright.sync_api.BrowserContext.cookies">cookies</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.exposeBinding" href="#playwright.sync_api.BrowserContext.exposeBinding">exposeBinding</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.exposeFunction" href="#playwright.sync_api.BrowserContext.exposeFunction">exposeFunction</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.grantPermissions" href="#playwright.sync_api.BrowserContext.grantPermissions">grantPermissions</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.newPage" href="#playwright.sync_api.BrowserContext.newPage">newPage</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.pages" href="#playwright.sync_api.BrowserContext.pages">pages</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.route" href="#playwright.sync_api.BrowserContext.route">route</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.setDefaultNavigationTimeout" href="#playwright.sync_api.BrowserContext.setDefaultNavigationTimeout">setDefaultNavigationTimeout</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.setDefaultTimeout" href="#playwright.sync_api.BrowserContext.setDefaultTimeout">setDefaultTimeout</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.setExtraHTTPHeaders" href="#playwright.sync_api.BrowserContext.setExtraHTTPHeaders">setExtraHTTPHeaders</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.setGeolocation" href="#playwright.sync_api.BrowserContext.setGeolocation">setGeolocation</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.setOffline" href="#playwright.sync_api.BrowserContext.setOffline">setOffline</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.storageState" href="#playwright.sync_api.BrowserContext.storageState">storageState</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.unroute" href="#playwright.sync_api.BrowserContext.unroute">unroute</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.waitForEvent" href="#playwright.sync_api.BrowserContext.waitForEvent">waitForEvent</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="playwright.sync_api.ConsoleMessage"><code class="flex name class">
<span>class <span class="ident">ConsoleMessage</span></span>
<span>(</span><span>obj: playwright.console_message.ConsoleMessage)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConsoleMessage(SyncBase):
    def __init__(self, obj: ConsoleMessageImpl):
        super().__init__(obj)

    @property
    def type(self) -&gt; str:
        &#34;&#34;&#34;ConsoleMessage.type

        One of the following values: `&#39;log&#39;`, `&#39;debug&#39;`, `&#39;info&#39;`, `&#39;error&#39;`, `&#39;warning&#39;`, `&#39;dir&#39;`, `&#39;dirxml&#39;`, `&#39;table&#39;`, `&#39;trace&#39;`, `&#39;clear&#39;`, `&#39;startGroup&#39;`, `&#39;startGroupCollapsed&#39;`, `&#39;endGroup&#39;`, `&#39;assert&#39;`, `&#39;profile&#39;`, `&#39;profileEnd&#39;`, `&#39;count&#39;`, `&#39;timeEnd&#39;`.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.type)

    @property
    def text(self) -&gt; str:
        &#34;&#34;&#34;ConsoleMessage.text

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.text)

    @property
    def args(self) -&gt; typing.List[&#34;JSHandle&#34;]:
        &#34;&#34;&#34;ConsoleMessage.args

        Returns
        -------
        List[JSHandle]
        &#34;&#34;&#34;
        return mapping.from_impl_list(self._impl_obj.args)

    @property
    def location(self) -&gt; ConsoleMessageLocation:
        &#34;&#34;&#34;ConsoleMessage.location

        Returns
        -------
        {&#34;url&#34;: str, &#34;lineNumber&#34;: int, &#34;columnNumber&#34;: int}
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.location)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright.sync_base.SyncBase</li>
<li>playwright.impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.sync_api.ConsoleMessage.args"><code class="name">var <span class="ident">args</span> : List[<a title="playwright.async_api.JSHandle" href="async_api.html#playwright.async_api.JSHandle">JSHandle</a>]</code></dt>
<dd>
<div class="desc"><p>ConsoleMessage.args</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="playwright.sync_api.JSHandle" href="#playwright.sync_api.JSHandle">JSHandle</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def args(self) -&gt; typing.List[&#34;JSHandle&#34;]:
    &#34;&#34;&#34;ConsoleMessage.args

    Returns
    -------
    List[JSHandle]
    &#34;&#34;&#34;
    return mapping.from_impl_list(self._impl_obj.args)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ConsoleMessage.location"><code class="name">var <span class="ident">location</span> : playwright.helper.ConsoleMessageLocation</code></dt>
<dd>
<div class="desc"><p>ConsoleMessage.location</p>
<h2 id="returns">Returns</h2>
<p>{"url": str, "lineNumber": int, "columnNumber": int}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def location(self) -&gt; ConsoleMessageLocation:
    &#34;&#34;&#34;ConsoleMessage.location

    Returns
    -------
    {&#34;url&#34;: str, &#34;lineNumber&#34;: int, &#34;columnNumber&#34;: int}
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.location)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ConsoleMessage.text"><code class="name">var <span class="ident">text</span> : str</code></dt>
<dd>
<div class="desc"><p>ConsoleMessage.text</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def text(self) -&gt; str:
    &#34;&#34;&#34;ConsoleMessage.text

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.text)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ConsoleMessage.type"><code class="name">var <span class="ident">type</span> : str</code></dt>
<dd>
<div class="desc"><p>ConsoleMessage.type</p>
<p>One of the following values: <code>'log'</code>, <code>'debug'</code>, <code>'info'</code>, <code>'error'</code>, <code>'warning'</code>, <code>'dir'</code>, <code>'dirxml'</code>, <code>'table'</code>, <code>'trace'</code>, <code>'clear'</code>, <code>'startGroup'</code>, <code>'startGroupCollapsed'</code>, <code>'endGroup'</code>, <code>'assert'</code>, <code>'profile'</code>, <code>'profileEnd'</code>, <code>'count'</code>, <code>'timeEnd'</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self) -&gt; str:
    &#34;&#34;&#34;ConsoleMessage.type

    One of the following values: `&#39;log&#39;`, `&#39;debug&#39;`, `&#39;info&#39;`, `&#39;error&#39;`, `&#39;warning&#39;`, `&#39;dir&#39;`, `&#39;dirxml&#39;`, `&#39;table&#39;`, `&#39;trace&#39;`, `&#39;clear&#39;`, `&#39;startGroup&#39;`, `&#39;startGroupCollapsed&#39;`, `&#39;endGroup&#39;`, `&#39;assert&#39;`, `&#39;profile&#39;`, `&#39;profileEnd&#39;`, `&#39;count&#39;`, `&#39;timeEnd&#39;`.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.type)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.sync_api.Dialog"><code class="flex name class">
<span>class <span class="ident">Dialog</span></span>
<span>(</span><span>obj: playwright.dialog.Dialog)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Dialog(SyncBase):
    def __init__(self, obj: DialogImpl):
        super().__init__(obj)

    @property
    def type(self) -&gt; str:
        &#34;&#34;&#34;Dialog.type

        Returns
        -------
        str
            Dialog&#39;s type, can be one of `alert`, `beforeunload`, `confirm` or `prompt`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.type)

    @property
    def message(self) -&gt; str:
        &#34;&#34;&#34;Dialog.message

        Returns
        -------
        str
            A message displayed in the dialog.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.message)

    @property
    def defaultValue(self) -&gt; str:
        &#34;&#34;&#34;Dialog.defaultValue

        Returns
        -------
        str
            If dialog is prompt, returns default prompt value. Otherwise, returns empty string.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.defaultValue)

    def accept(self, promptText: str = None) -&gt; NoneType:
        &#34;&#34;&#34;Dialog.accept

        Parameters
        ----------
        promptText : Optional[str]
            A text to enter in prompt. Does not cause any effects if the dialog&#39;s `type` is not prompt.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.accept(promptText=promptText))
        )

    def dismiss(self) -&gt; NoneType:
        &#34;&#34;&#34;Dialog.dismiss&#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.dismiss()))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright.sync_base.SyncBase</li>
<li>playwright.impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.sync_api.Dialog.defaultValue"><code class="name">var <span class="ident">defaultValue</span> : str</code></dt>
<dd>
<div class="desc"><p>Dialog.defaultValue</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>If dialog is prompt, returns default prompt value. Otherwise, returns empty string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def defaultValue(self) -&gt; str:
    &#34;&#34;&#34;Dialog.defaultValue

    Returns
    -------
    str
        If dialog is prompt, returns default prompt value. Otherwise, returns empty string.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.defaultValue)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Dialog.message"><code class="name">var <span class="ident">message</span> : str</code></dt>
<dd>
<div class="desc"><p>Dialog.message</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A message displayed in the dialog.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def message(self) -&gt; str:
    &#34;&#34;&#34;Dialog.message

    Returns
    -------
    str
        A message displayed in the dialog.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.message)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Dialog.type"><code class="name">var <span class="ident">type</span> : str</code></dt>
<dd>
<div class="desc"><p>Dialog.type</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Dialog's type, can be one of <code>alert</code>, <code>beforeunload</code>, <code>confirm</code> or <code>prompt</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self) -&gt; str:
    &#34;&#34;&#34;Dialog.type

    Returns
    -------
    str
        Dialog&#39;s type, can be one of `alert`, `beforeunload`, `confirm` or `prompt`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.type)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.sync_api.Dialog.accept"><code class="name flex">
<span>def <span class="ident">accept</span></span>(<span>self, promptText: str = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Dialog.accept</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>promptText</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>A text to enter in prompt. Does not cause any effects if the dialog's <code>type</code> is not prompt.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def accept(self, promptText: str = None) -&gt; NoneType:
    &#34;&#34;&#34;Dialog.accept

    Parameters
    ----------
    promptText : Optional[str]
        A text to enter in prompt. Does not cause any effects if the dialog&#39;s `type` is not prompt.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.accept(promptText=promptText))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Dialog.dismiss"><code class="name flex">
<span>def <span class="ident">dismiss</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Dialog.dismiss</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dismiss(self) -&gt; NoneType:
    &#34;&#34;&#34;Dialog.dismiss&#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.dismiss()))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.sync_api.Download"><code class="flex name class">
<span>class <span class="ident">Download</span></span>
<span>(</span><span>obj: playwright.download.Download)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Download(SyncBase):
    def __init__(self, obj: DownloadImpl):
        super().__init__(obj)

    @property
    def url(self) -&gt; str:
        &#34;&#34;&#34;Download.url

        Returns downloaded url.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.url)

    @property
    def suggestedFilename(self) -&gt; str:
        &#34;&#34;&#34;Download.suggestedFilename

        Returns suggested filename for this download. It is typically computed by the browser from the `Content-Disposition` response header or the `download` attribute. See the spec on whatwg. Different browsers can use different logic for computing it.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.suggestedFilename)

    def delete(self) -&gt; NoneType:
        &#34;&#34;&#34;Download.delete

        Deletes the downloaded file.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.delete()))

    def failure(self) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;Download.failure

        Returns download error if any.

        Returns
        -------
        Optional[str]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.failure()))

    def path(self) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;Download.path

        Returns path to the downloaded file in case of successful download.

        Returns
        -------
        Optional[str]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.path()))

    def saveAs(self, path: typing.Union[str, pathlib.Path]) -&gt; NoneType:
        &#34;&#34;&#34;Download.saveAs

        Saves the download to a user-specified path.

        Parameters
        ----------
        path : Union[str, pathlib.Path]
            Path where the download should be saved.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.saveAs(path=path)))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright.sync_base.SyncBase</li>
<li>playwright.impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.sync_api.Download.suggestedFilename"><code class="name">var <span class="ident">suggestedFilename</span> : str</code></dt>
<dd>
<div class="desc"><p>Download.suggestedFilename</p>
<p>Returns suggested filename for this download. It is typically computed by the browser from the <code>Content-Disposition</code> response header or the <code>download</code> attribute. See the spec on whatwg. Different browsers can use different logic for computing it.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def suggestedFilename(self) -&gt; str:
    &#34;&#34;&#34;Download.suggestedFilename

    Returns suggested filename for this download. It is typically computed by the browser from the `Content-Disposition` response header or the `download` attribute. See the spec on whatwg. Different browsers can use different logic for computing it.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.suggestedFilename)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Download.url"><code class="name">var <span class="ident">url</span> : str</code></dt>
<dd>
<div class="desc"><p>Download.url</p>
<p>Returns downloaded url.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def url(self) -&gt; str:
    &#34;&#34;&#34;Download.url

    Returns downloaded url.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.url)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.sync_api.Download.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Download.delete</p>
<p>Deletes the downloaded file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self) -&gt; NoneType:
    &#34;&#34;&#34;Download.delete

    Deletes the downloaded file.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.delete()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Download.failure"><code class="name flex">
<span>def <span class="ident">failure</span></span>(<span>self) ‑> Union[str, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Download.failure</p>
<p>Returns download error if any.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[str]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def failure(self) -&gt; typing.Union[str, NoneType]:
    &#34;&#34;&#34;Download.failure

    Returns download error if any.

    Returns
    -------
    Optional[str]
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.failure()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Download.path"><code class="name flex">
<span>def <span class="ident">path</span></span>(<span>self) ‑> Union[str, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Download.path</p>
<p>Returns path to the downloaded file in case of successful download.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[str]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def path(self) -&gt; typing.Union[str, NoneType]:
    &#34;&#34;&#34;Download.path

    Returns path to the downloaded file in case of successful download.

    Returns
    -------
    Optional[str]
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.path()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Download.saveAs"><code class="name flex">
<span>def <span class="ident">saveAs</span></span>(<span>self, path: Union[str, pathlib.Path]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Download.saveAs</p>
<p>Saves the download to a user-specified path.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[str, pathlib.Path]</code></dt>
<dd>Path where the download should be saved.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saveAs(self, path: typing.Union[str, pathlib.Path]) -&gt; NoneType:
    &#34;&#34;&#34;Download.saveAs

    Saves the download to a user-specified path.

    Parameters
    ----------
    path : Union[str, pathlib.Path]
        Path where the download should be saved.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.saveAs(path=path)))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.sync_api.ElementHandle"><code class="flex name class">
<span>class <span class="ident">ElementHandle</span></span>
<span>(</span><span>obj: playwright.element_handle.ElementHandle)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ElementHandle(JSHandle):
    def __init__(self, obj: ElementHandleImpl):
        super().__init__(obj)

    def toString(self) -&gt; str:
        &#34;&#34;&#34;ElementHandle.toString

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.toString())

    def asElement(self) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
        &#34;&#34;&#34;ElementHandle.asElement

        Returns either `null` or the object handle itself, if the object handle is an instance of ElementHandle.

        Returns
        -------
        Optional[ElementHandle]
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._impl_obj.asElement())

    def ownerFrame(self) -&gt; typing.Union[&#34;Frame&#34;, NoneType]:
        &#34;&#34;&#34;ElementHandle.ownerFrame

        Returns
        -------
        Optional[Frame]
            Returns the frame containing the given element.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._sync(self._impl_obj.ownerFrame()))

    def contentFrame(self) -&gt; typing.Union[&#34;Frame&#34;, NoneType]:
        &#34;&#34;&#34;ElementHandle.contentFrame

        Returns
        -------
        Optional[Frame]
            Resolves to the content frame for element handles referencing iframe nodes, or `null` otherwise
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._sync(self._impl_obj.contentFrame()))

    def getAttribute(self, name: str) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;ElementHandle.getAttribute

        Returns element attribute value.

        Parameters
        ----------
        name : str
            Attribute name to get the value for.

        Returns
        -------
        Optional[str]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.getAttribute(name=name))
        )

    def textContent(self) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;ElementHandle.textContent

        Returns
        -------
        Optional[str]
            Resolves to the `node.textContent`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.textContent()))

    def innerText(self) -&gt; str:
        &#34;&#34;&#34;ElementHandle.innerText

        Returns
        -------
        str
            Resolves to the `element.innerText`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.innerText()))

    def innerHTML(self) -&gt; str:
        &#34;&#34;&#34;ElementHandle.innerHTML

        Returns
        -------
        str
            Resolves to the `element.innerHTML`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.innerHTML()))

    def dispatchEvent(self, type: str, eventInit: typing.Dict = None) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.dispatchEvent

        The snippet below dispatches the `click` event on the element. Regardless of the visibility state of the elment, `click` is dispatched. This is equivalend to calling `element.click()`.
        Under the hood, it creates an instance of an event based on the given `type`, initializes it with `eventInit` properties and dispatches it on the element. Events are `composed`, `cancelable` and bubble by default.
        Since `eventInit` is event-specific, please refer to the events documentation for the lists of initial properties:

        DragEvent
        FocusEvent
        KeyboardEvent
        MouseEvent
        PointerEvent
        TouchEvent
        Event

        You can also specify `JSHandle` as the property value if you want live objects to be passed into the event:

        Parameters
        ----------
        type : str
            DOM event type: `&#34;click&#34;`, `&#34;dragstart&#34;`, etc.
        eventInit : Optional[Dict]
            event-specific initialization properties.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.dispatchEvent(
                    type=type, eventInit=mapping.to_impl(eventInit)
                )
            )
        )

    def scrollIntoViewIfNeeded(self, timeout: int = None) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.scrollIntoViewIfNeeded

        This method waits for actionability checks, then tries to scroll element into view, unless it is completely visible as defined by IntersectionObserver&#39;s `ratio`.
        Throws when `elementHandle` does not point to an element connected to a Document or a ShadowRoot.

        Parameters
        ----------
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.scrollIntoViewIfNeeded(timeout=timeout))
        )

    def hover(
        self,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: MousePosition = None,
        timeout: int = None,
        force: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.hover

        This method hovers over the element by performing the following steps:

        Wait for actionability checks on the element, unless `force` option is set.
        Scroll the element into view if needed.
        Use page.mouse to hover over the center of the element, or the specified `position`.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

        If the element is detached from the DOM at any moment during the action, this method rejects.
        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        Parameters
        ----------
        modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
            Modifier keys to press. Ensures that only these modifiers are pressed during the hover, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
        position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
            A point to hover relative to the top-left corner of element padding box. If not specified, hovers over some visible point of the element.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.hover(
                    modifiers=modifiers, position=position, timeout=timeout, force=force
                )
            )
        )

    def click(
        self,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: MousePosition = None,
        delay: int = None,
        button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
        clickCount: int = None,
        timeout: int = None,
        force: bool = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.click

        This method clicks the element by performing the following steps:

        Wait for actionability checks on the element, unless `force` option is set.
        Scroll the element into view if needed.
        Use page.mouse to click in the center of the element, or the specified `position`.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

        If the element is detached from the DOM at any moment during the action, this method rejects.
        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        Parameters
        ----------
        modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
            Modifier keys to press. Ensures that only these modifiers are pressed during the click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
        position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
            A point to click relative to the top-left corner of element padding box. If not specified, clicks to some visible point of the element.
        delay : Optional[int]
            Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
        button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
            Defaults to `left`.
        clickCount : Optional[int]
            defaults to 1. See UIEvent.detail.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.click(
                    modifiers=modifiers,
                    position=position,
                    delay=delay,
                    button=button,
                    clickCount=clickCount,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def dblclick(
        self,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: MousePosition = None,
        delay: int = None,
        button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
        timeout: int = None,
        force: bool = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.dblclick

        This method double clicks the element by performing the following steps:

        Wait for actionability checks on the element, unless `force` option is set.
        Scroll the element into view if needed.
        Use page.mouse to double click in the center of the element, or the specified `position`.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set. Note that if the first click of the `dblclick()` triggers a navigation event, this method will reject.

        If the element is detached from the DOM at any moment during the action, this method rejects.
        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        **NOTE** `elementHandle.dblclick()` dispatches two `click` events and a single `dblclick` event.

        Parameters
        ----------
        modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
            Modifier keys to press. Ensures that only these modifiers are pressed during the double click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
        position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
            A point to double click relative to the top-left corner of element padding box. If not specified, double clicks to some visible point of the element.
        delay : Optional[int]
            Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
        button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
            Defaults to `left`.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.dblclick(
                    modifiers=modifiers,
                    position=position,
                    delay=delay,
                    button=button,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def selectOption(
        self,
        values: typing.Union[
            str,
            &#34;ElementHandle&#34;,
            SelectOption,
            typing.List[str],
            typing.List[&#34;ElementHandle&#34;],
            typing.List[SelectOption],
        ] = None,
        timeout: int = None,
        noWaitAfter: bool = None,
    ) -&gt; typing.List[str]:
        &#34;&#34;&#34;ElementHandle.selectOption

        Triggers a `change` and `input` event once all the provided options have been selected.
        If element is not a `&lt;select&gt;` element, the method throws an error.

        Parameters
        ----------
        values : Union[str, ElementHandle, {&#34;value&#34;: Optional[str], &#34;label&#34;: Optional[str], &#34;index&#34;: Optional[str]}, List[str], List[ElementHandle], List[{&#34;value&#34;: Optional[str], &#34;label&#34;: Optional[str], &#34;index&#34;: Optional[str]}], NoneType]
            Options to select. If the `&lt;select&gt;` has the `multiple` attribute, all matching options are selected, otherwise only the first option matching one of the passed options is selected. String values are equivalent to `{value:&#39;string&#39;}`. Option is considered matching if all specified properties match.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.

        Returns
        -------
        List[str]
            An array of option values that have been successfully selected.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.selectOption(
                    values=mapping.to_impl(values),
                    timeout=timeout,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def tap(
        self,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: MousePosition = None,
        timeout: int = None,
        force: bool = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.tap

        This method taps the element by performing the following steps:

        Wait for actionability checks on the element, unless `force` option is set.
        Scroll the element into view if needed.
        Use page.touchscreen to tap in the center of the element, or the specified `position`.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

        If the element is detached from the DOM at any moment during the action, this method rejects.
        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        **NOTE** `elementHandle.tap()` requires that the `hasTouch` option of the browser context be set to true.

        Parameters
        ----------
        modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
            Modifier keys to press. Ensures that only these modifiers are pressed during the tap, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
        position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
            A point to tap relative to the top-left corner of element padding box. If not specified, taps some visible point of the element.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.tap(
                    modifiers=modifiers,
                    position=position,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def fill(
        self, value: str, timeout: int = None, noWaitAfter: bool = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.fill

        This method waits for actionability checks, focuses the element, fills it and triggers an `input` event after filling.
        If the element is not an `&lt;input&gt;`, `&lt;textarea&gt;` or `[contenteditable]` element, this method throws an error.
        Note that you can pass an empty string to clear the input field.

        Parameters
        ----------
        value : str
            Value to set for the `&lt;input&gt;`, `&lt;textarea&gt;` or `[contenteditable]` element.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.fill(
                    value=value, timeout=timeout, noWaitAfter=noWaitAfter
                )
            )
        )

    def selectText(self, timeout: int = None) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.selectText

        This method waits for actionability checks, then focuses the element and selects all its text content.

        Parameters
        ----------
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.selectText(timeout=timeout))
        )

    def setInputFiles(
        self,
        files: typing.Union[
            str,
            pathlib.Path,
            FilePayload,
            typing.List[str],
            typing.List[pathlib.Path],
            typing.List[FilePayload],
        ],
        timeout: int = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.setInputFiles

        This method expects `elementHandle` to point to an input element.
        Sets the value of the file input to these file paths or files. If some of the `filePaths` are relative paths, then they are resolved relative to the current working directory. For empty array, clears the selected files.

        Parameters
        ----------
        files : Union[str, pathlib.Path, {&#34;name&#34;: str, &#34;mimeType&#34;: str, &#34;buffer&#34;: bytes}, List[str], List[pathlib.Path], List[{&#34;name&#34;: str, &#34;mimeType&#34;: str, &#34;buffer&#34;: bytes}]]
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.setInputFiles(
                    files=files, timeout=timeout, noWaitAfter=noWaitAfter
                )
            )
        )

    def focus(self) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.focus

        Calls focus on the element.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.focus()))

    def type(
        self,
        text: str,
        delay: int = None,
        timeout: int = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.type

        Focuses the element, and then sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text.
        To press a special key, like `Control` or `ArrowDown`, use `elementHandle.press`.
        An example of typing into a text field and then submitting the form:

        Parameters
        ----------
        text : str
            A text to type into a focused element.
        delay : Optional[int]
            Time to wait between key presses in milliseconds. Defaults to 0.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.type(
                    text=text, delay=delay, timeout=timeout, noWaitAfter=noWaitAfter
                )
            )
        )

    def press(
        self, key: str, delay: int = None, timeout: int = None, noWaitAfter: bool = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.press

        Focuses the element, and then uses `keyboard.down` and `keyboard.up`.
        `key` can specify the intended keyboardEvent.key value or a single character to generate the text for. A superset of the `key` values can be found here. Examples of the keys are:
        `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`, `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.
        Following modification shortcuts are also suported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`.
        Holding down `Shift` will type the text that corresponds to the `key` in the upper case.
        If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective texts.
        Shortcuts such as `key: &#34;Control+o&#34;` or `key: &#34;Control+Shift+T&#34;` are supported as well. When speficied with the modifier, modifier is pressed and being held while the subsequent key is being pressed.

        Parameters
        ----------
        key : str
            Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
        delay : Optional[int]
            Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.press(
                    key=key, delay=delay, timeout=timeout, noWaitAfter=noWaitAfter
                )
            )
        )

    def check(
        self, timeout: int = None, force: bool = None, noWaitAfter: bool = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.check

        This method checks the element by performing the following steps:

        Ensure that element is a checkbox or a radio input. If not, this method rejects. If the element is already checked, this method returns immediately.
        Wait for actionability checks on the element, unless `force` option is set.
        Scroll the element into view if needed.
        Use page.mouse to click in the center of the element.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
        Ensure that the element is now checked. If not, this method rejects.

        If the element is detached from the DOM at any moment during the action, this method rejects.
        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        Parameters
        ----------
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.check(
                    timeout=timeout, force=force, noWaitAfter=noWaitAfter
                )
            )
        )

    def uncheck(
        self, timeout: int = None, force: bool = None, noWaitAfter: bool = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.uncheck

        This method checks the element by performing the following steps:

        Ensure that element is a checkbox or a radio input. If not, this method rejects. If the element is already unchecked, this method returns immediately.
        Wait for actionability checks on the element, unless `force` option is set.
        Scroll the element into view if needed.
        Use page.mouse to click in the center of the element.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
        Ensure that the element is now unchecked. If not, this method rejects.

        If the element is detached from the DOM at any moment during the action, this method rejects.
        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        Parameters
        ----------
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.uncheck(
                    timeout=timeout, force=force, noWaitAfter=noWaitAfter
                )
            )
        )

    def boundingBox(self) -&gt; typing.Union[FloatRect, NoneType]:
        &#34;&#34;&#34;ElementHandle.boundingBox

        This method returns the bounding box of the element (relative to the main frame), or `null` if the element is not visible.

        Returns
        -------
        Optional[{&#34;x&#34;: float, &#34;y&#34;: float, &#34;width&#34;: float, &#34;height&#34;: float}]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.boundingBox()))

    def screenshot(
        self,
        timeout: int = None,
        type: Literal[&#34;jpeg&#34;, &#34;png&#34;] = None,
        path: typing.Union[str, pathlib.Path] = None,
        quality: int = None,
        omitBackground: bool = None,
    ) -&gt; bytes:
        &#34;&#34;&#34;ElementHandle.screenshot

        This method waits for the actionability checks, then scrolls element into view before taking a screenshot. If the element is detached from DOM, the method throws an error.

        Parameters
        ----------
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        type : Optional[Literal[&#39;jpeg&#39;, &#39;png&#39;]]
            Specify screenshot type, defaults to `png`.
        path : Union[str, pathlib.Path, NoneType]
            The file path to save the image to. The screenshot type will be inferred from file extension. If `path` is a relative path, then it is resolved relative to current working directory. If no path is provided, the image won&#39;t be saved to the disk.
        quality : Optional[int]
            The quality of the image, between 0-100. Not applicable to `png` images.
        omitBackground : Optional[bool]
            Hides default white background and allows capturing screenshots with transparency. Not applicable to `jpeg` images. Defaults to `false`.

        Returns
        -------
        bytes
            Promise which resolves to buffer with the captured screenshot.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.screenshot(
                    timeout=timeout,
                    type=type,
                    path=path,
                    quality=quality,
                    omitBackground=omitBackground,
                )
            )
        )

    def querySelector(self, selector: str) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
        &#34;&#34;&#34;ElementHandle.querySelector

        The method finds an element matching the specified selector in the `ElementHandle`&#39;s subtree. See Working with selectors for more details. If no elements match the selector, the return value resolves to `null`.

        Parameters
        ----------
        selector : str
            A selector to query element for. See working with selectors for more details.

        Returns
        -------
        Optional[ElementHandle]
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._sync(self._impl_obj.querySelector(selector=selector))
        )

    def querySelectorAll(self, selector: str) -&gt; typing.List[&#34;ElementHandle&#34;]:
        &#34;&#34;&#34;ElementHandle.querySelectorAll

        The method finds all elements matching the specified selector in the `ElementHandle`s subtree. See Working with selectors for more details. If no elements match the selector, the return value resolves to `[]`.

        Parameters
        ----------
        selector : str
            A selector to query element for. See working with selectors for more details.

        Returns
        -------
        List[ElementHandle]
        &#34;&#34;&#34;
        return mapping.from_impl_list(
            self._sync(self._impl_obj.querySelectorAll(selector=selector))
        )

    def evalOnSelector(
        self,
        selector: str,
        expression: str,
        arg: typing.Any = None,
        force_expr: bool = None,
    ) -&gt; typing.Any:
        &#34;&#34;&#34;ElementHandle.evalOnSelector

        The method finds an element matching the specified selector in the `ElementHandle`s subtree and passes it as a first argument to `pageFunction`. See Working with selectors for more details. If no elements match the selector, the method throws an error.
        If `pageFunction` returns a Promise, then `frame.$eval` would wait for the promise to resolve and return its value.
        Examples:

        Parameters
        ----------
        selector : str
            A selector to query element for. See working with selectors for more details.
        expression : str
            Function to be evaluated in browser context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        Any
            Promise which resolves to the return value of `pageFunction`
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.evalOnSelector(
                    selector=selector,
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )

    def evalOnSelectorAll(
        self,
        selector: str,
        expression: str,
        arg: typing.Any = None,
        force_expr: bool = None,
    ) -&gt; typing.Any:
        &#34;&#34;&#34;ElementHandle.evalOnSelectorAll

        The method finds all elements matching the specified selector in the `ElementHandle`&#39;s subtree and passes an array of matched elements as a first argument to `pageFunction`. See Working with selectors for more details.
        If `pageFunction` returns a Promise, then `frame.$$eval` would wait for the promise to resolve and return its value.
        Examples:
        ```html
        &lt;div class=&#34;feed&#34;&gt;
          &lt;div class=&#34;tweet&#34;&gt;Hello!&lt;/div&gt;
          &lt;div class=&#34;tweet&#34;&gt;Hi!&lt;/div&gt;
        &lt;/div&gt;
        ```

        Parameters
        ----------
        selector : str
            A selector to query element for. See working with selectors for more details.
        expression : str
            Function to be evaluated in browser context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        Any
            Promise which resolves to the return value of `pageFunction`
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.evalOnSelectorAll(
                    selector=selector,
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )

    def waitForElementState(
        self,
        state: Literal[&#34;disabled&#34;, &#34;enabled&#34;, &#34;hidden&#34;, &#34;stable&#34;, &#34;visible&#34;],
        timeout: int = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.waitForElementState

        Depending on the `state` parameter, this method waits for one of the actionability checks to pass. This method throws when the element is detached while waiting, unless waiting for the `&#34;hidden&#34;` state.

        `&#34;visible&#34;` Wait until the element is visible.
        `&#34;hidden&#34;` Wait until the element is not visible or not attached. Note that waiting for hidden does not throw when the element detaches.
        `&#34;stable&#34;` Wait until the element is both visible and stable.
        `&#34;enabled&#34;` Wait until the element is enabled.
        `&#34;disabled&#34;` Wait until the element is not enabled.

        If the element does not satisfy the condition for the `timeout` milliseconds, this method will throw.

        Parameters
        ----------
        state : Literal[&#39;disabled&#39;, &#39;enabled&#39;, &#39;hidden&#39;, &#39;stable&#39;, &#39;visible&#39;]
            A state to wait for, see below for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.waitForElementState(state=state, timeout=timeout))
        )

    def waitForSelector(
        self,
        selector: str,
        state: Literal[&#34;attached&#34;, &#34;detached&#34;, &#34;hidden&#34;, &#34;visible&#34;] = None,
        timeout: int = None,
    ) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
        &#34;&#34;&#34;ElementHandle.waitForSelector

        Wait for the `selector` relative to the element handle to satisfy `state` option (either appear/disappear from dom, or become visible/hidden). If at the moment of calling the method `selector` already satisfies the condition, the method will return immediately. If the selector doesn&#39;t satisfy the condition for the `timeout` milliseconds, the function will throw.

        **NOTE** This method does not work across navigations, use page.waitForSelector(selector[, options]) instead.

        Parameters
        ----------
        selector : str
            A selector of an element to wait for, relative to the element handle. See working with selectors for more details.
        state : Optional[Literal[&#39;attached&#39;, &#39;detached&#39;, &#39;hidden&#39;, &#39;visible&#39;]]
            Defaults to `&#39;visible&#39;`. Can be either:
             - `&#39;attached&#39;` - wait for element to be present in DOM.
             - `&#39;detached&#39;` - wait for element to not be present in DOM.
             - `&#39;visible&#39;` - wait for element to have non-empty bounding box and no `visibility:hidden`. Note that element without any content or with `display:none` has an empty bounding box and is not considered visible.
             - `&#39;hidden&#39;` - wait for element to be either detached from DOM, or have an empty bounding box or `visibility:hidden`. This is opposite to the `&#39;visible&#39;` option.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

        Returns
        -------
        Optional[ElementHandle]
            Promise that resolves when element specified by selector satisfies `state` option. Resolves to `null` if waiting for `hidden` or `detached`.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._sync(
                self._impl_obj.waitForSelector(
                    selector=selector, state=state, timeout=timeout
                )
            )
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="playwright.sync_api.JSHandle" href="#playwright.sync_api.JSHandle">JSHandle</a></li>
<li>playwright.sync_base.SyncBase</li>
<li>playwright.impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="playwright.sync_api.ElementHandle.asElement"><code class="name flex">
<span>def <span class="ident">asElement</span></span>(<span>self) ‑> Union[<a title="playwright.async_api.ElementHandle" href="async_api.html#playwright.async_api.ElementHandle">ElementHandle</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.asElement</p>
<p>Returns either <code>null</code> or the object handle itself, if the object handle is an instance of ElementHandle.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[<a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def asElement(self) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
    &#34;&#34;&#34;ElementHandle.asElement

    Returns either `null` or the object handle itself, if the object handle is an instance of ElementHandle.

    Returns
    -------
    Optional[ElementHandle]
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(self._impl_obj.asElement())</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.boundingBox"><code class="name flex">
<span>def <span class="ident">boundingBox</span></span>(<span>self) ‑> Union[playwright.helper.FloatRect, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.boundingBox</p>
<p>This method returns the bounding box of the element (relative to the main frame), or <code>null</code> if the element is not visible.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[{"x": float, "y": float, "width": float, "height": float}]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boundingBox(self) -&gt; typing.Union[FloatRect, NoneType]:
    &#34;&#34;&#34;ElementHandle.boundingBox

    This method returns the bounding box of the element (relative to the main frame), or `null` if the element is not visible.

    Returns
    -------
    Optional[{&#34;x&#34;: float, &#34;y&#34;: float, &#34;width&#34;: float, &#34;height&#34;: float}]
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.boundingBox()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.check"><code class="name flex">
<span>def <span class="ident">check</span></span>(<span>self, timeout: int = None, force: bool = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.check</p>
<p>This method checks the element by performing the following steps:</p>
<p>Ensure that element is a checkbox or a radio input. If not, this method rejects. If the element is already checked, this method returns immediately.
Wait for actionability checks on the element, unless <code>force</code> option is set.
Scroll the element into view if needed.
Use page.mouse to click in the center of the element.
Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.
Ensure that the element is now checked. If not, this method rejects.</p>
<p>If the element is detached from the DOM at any moment during the action, this method rejects.
When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a TimeoutError. Passing zero timeout disables this.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to bypass the actionability checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check(
    self, timeout: int = None, force: bool = None, noWaitAfter: bool = None
) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.check

    This method checks the element by performing the following steps:

    Ensure that element is a checkbox or a radio input. If not, this method rejects. If the element is already checked, this method returns immediately.
    Wait for actionability checks on the element, unless `force` option is set.
    Scroll the element into view if needed.
    Use page.mouse to click in the center of the element.
    Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
    Ensure that the element is now checked. If not, this method rejects.

    If the element is detached from the DOM at any moment during the action, this method rejects.
    When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

    Parameters
    ----------
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    force : Optional[bool]
        Whether to bypass the actionability checks. Defaults to `false`.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.check(
                timeout=timeout, force=force, noWaitAfter=noWaitAfter
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.click"><code class="name flex">
<span>def <span class="ident">click</span></span>(<span>self, modifiers: List[Literal['Alt', 'Control', 'Meta', 'Shift']] = None, position: playwright.helper.MousePosition = None, delay: int = None, button: Literal['left', 'middle', 'right'] = None, clickCount: int = None, timeout: int = None, force: bool = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.click</p>
<p>This method clicks the element by performing the following steps:</p>
<p>Wait for actionability checks on the element, unless <code>force</code> option is set.
Scroll the element into view if needed.
Use page.mouse to click in the center of the element, or the specified <code>position</code>.
Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.</p>
<p>If the element is detached from the DOM at any moment during the action, this method rejects.
When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a TimeoutError. Passing zero timeout disables this.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>modifiers</code></strong> :&ensp;<code>Optional[List[Literal['Alt', 'Control', 'Meta', 'Shift']]]</code></dt>
<dd>Modifier keys to press. Ensures that only these modifiers are pressed during the click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>Optional[{"x": float, "y": float}]</code></dt>
<dd>A point to click relative to the top-left corner of element padding box. If not specified, clicks to some visible point of the element.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Time to wait between <code>mousedown</code> and <code>mouseup</code> in milliseconds. Defaults to 0.</dd>
<dt><strong><code>button</code></strong> :&ensp;<code>Optional[Literal['left', 'middle', 'right']]</code></dt>
<dd>Defaults to <code>left</code>.</dd>
<dt><strong><code>clickCount</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>defaults to 1. See UIEvent.detail.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to bypass the actionability checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def click(
    self,
    modifiers: typing.Union[
        typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
    ] = None,
    position: MousePosition = None,
    delay: int = None,
    button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
    clickCount: int = None,
    timeout: int = None,
    force: bool = None,
    noWaitAfter: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.click

    This method clicks the element by performing the following steps:

    Wait for actionability checks on the element, unless `force` option is set.
    Scroll the element into view if needed.
    Use page.mouse to click in the center of the element, or the specified `position`.
    Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

    If the element is detached from the DOM at any moment during the action, this method rejects.
    When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

    Parameters
    ----------
    modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
        Modifier keys to press. Ensures that only these modifiers are pressed during the click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
    position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
        A point to click relative to the top-left corner of element padding box. If not specified, clicks to some visible point of the element.
    delay : Optional[int]
        Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
    button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
        Defaults to `left`.
    clickCount : Optional[int]
        defaults to 1. See UIEvent.detail.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    force : Optional[bool]
        Whether to bypass the actionability checks. Defaults to `false`.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.click(
                modifiers=modifiers,
                position=position,
                delay=delay,
                button=button,
                clickCount=clickCount,
                timeout=timeout,
                force=force,
                noWaitAfter=noWaitAfter,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.contentFrame"><code class="name flex">
<span>def <span class="ident">contentFrame</span></span>(<span>self) ‑> Union[<a title="playwright.async_api.Frame" href="async_api.html#playwright.async_api.Frame">Frame</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.contentFrame</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[<a title="playwright.sync_api.Frame" href="#playwright.sync_api.Frame">Frame</a>]</code></dt>
<dd>Resolves to the content frame for element handles referencing iframe nodes, or <code>null</code> otherwise</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contentFrame(self) -&gt; typing.Union[&#34;Frame&#34;, NoneType]:
    &#34;&#34;&#34;ElementHandle.contentFrame

    Returns
    -------
    Optional[Frame]
        Resolves to the content frame for element handles referencing iframe nodes, or `null` otherwise
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(self._sync(self._impl_obj.contentFrame()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.dblclick"><code class="name flex">
<span>def <span class="ident">dblclick</span></span>(<span>self, modifiers: List[Literal['Alt', 'Control', 'Meta', 'Shift']] = None, position: playwright.helper.MousePosition = None, delay: int = None, button: Literal['left', 'middle', 'right'] = None, timeout: int = None, force: bool = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.dblclick</p>
<p>This method double clicks the element by performing the following steps:</p>
<p>Wait for actionability checks on the element, unless <code>force</code> option is set.
Scroll the element into view if needed.
Use page.mouse to double click in the center of the element, or the specified <code>position</code>.
Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set. Note that if the first click of the <code>dblclick()</code> triggers a navigation event, this method will reject.</p>
<p>If the element is detached from the DOM at any moment during the action, this method rejects.
When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a TimeoutError. Passing zero timeout disables this.</p>
<p><strong>NOTE</strong> <code>elementHandle.dblclick()</code> dispatches two <code>click</code> events and a single <code>dblclick</code> event.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>modifiers</code></strong> :&ensp;<code>Optional[List[Literal['Alt', 'Control', 'Meta', 'Shift']]]</code></dt>
<dd>Modifier keys to press. Ensures that only these modifiers are pressed during the double click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>Optional[{"x": float, "y": float}]</code></dt>
<dd>A point to double click relative to the top-left corner of element padding box. If not specified, double clicks to some visible point of the element.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Time to wait between <code>mousedown</code> and <code>mouseup</code> in milliseconds. Defaults to 0.</dd>
<dt><strong><code>button</code></strong> :&ensp;<code>Optional[Literal['left', 'middle', 'right']]</code></dt>
<dd>Defaults to <code>left</code>.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to bypass the actionability checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dblclick(
    self,
    modifiers: typing.Union[
        typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
    ] = None,
    position: MousePosition = None,
    delay: int = None,
    button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
    timeout: int = None,
    force: bool = None,
    noWaitAfter: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.dblclick

    This method double clicks the element by performing the following steps:

    Wait for actionability checks on the element, unless `force` option is set.
    Scroll the element into view if needed.
    Use page.mouse to double click in the center of the element, or the specified `position`.
    Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set. Note that if the first click of the `dblclick()` triggers a navigation event, this method will reject.

    If the element is detached from the DOM at any moment during the action, this method rejects.
    When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

    **NOTE** `elementHandle.dblclick()` dispatches two `click` events and a single `dblclick` event.

    Parameters
    ----------
    modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
        Modifier keys to press. Ensures that only these modifiers are pressed during the double click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
    position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
        A point to double click relative to the top-left corner of element padding box. If not specified, double clicks to some visible point of the element.
    delay : Optional[int]
        Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
    button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
        Defaults to `left`.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    force : Optional[bool]
        Whether to bypass the actionability checks. Defaults to `false`.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.dblclick(
                modifiers=modifiers,
                position=position,
                delay=delay,
                button=button,
                timeout=timeout,
                force=force,
                noWaitAfter=noWaitAfter,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.dispatchEvent"><code class="name flex">
<span>def <span class="ident">dispatchEvent</span></span>(<span>self, type: str, eventInit: Dict = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.dispatchEvent</p>
<p>The snippet below dispatches the <code>click</code> event on the element. Regardless of the visibility state of the elment, <code>click</code> is dispatched. This is equivalend to calling <code>element.click()</code>.
Under the hood, it creates an instance of an event based on the given <code>type</code>, initializes it with <code>eventInit</code> properties and dispatches it on the element. Events are <code>composed</code>, <code>cancelable</code> and bubble by default.
Since <code>eventInit</code> is event-specific, please refer to the events documentation for the lists of initial properties:</p>
<p>DragEvent
FocusEvent
KeyboardEvent
MouseEvent
PointerEvent
TouchEvent
Event</p>
<p>You can also specify <code><a title="playwright.sync_api.JSHandle" href="#playwright.sync_api.JSHandle">JSHandle</a></code> as the property value if you want live objects to be passed into the event:</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code></dt>
<dd>DOM event type: <code>"click"</code>, <code>"dragstart"</code>, etc.</dd>
<dt><strong><code>eventInit</code></strong> :&ensp;<code>Optional[Dict]</code></dt>
<dd>event-specific initialization properties.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dispatchEvent(self, type: str, eventInit: typing.Dict = None) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.dispatchEvent

    The snippet below dispatches the `click` event on the element. Regardless of the visibility state of the elment, `click` is dispatched. This is equivalend to calling `element.click()`.
    Under the hood, it creates an instance of an event based on the given `type`, initializes it with `eventInit` properties and dispatches it on the element. Events are `composed`, `cancelable` and bubble by default.
    Since `eventInit` is event-specific, please refer to the events documentation for the lists of initial properties:

    DragEvent
    FocusEvent
    KeyboardEvent
    MouseEvent
    PointerEvent
    TouchEvent
    Event

    You can also specify `JSHandle` as the property value if you want live objects to be passed into the event:

    Parameters
    ----------
    type : str
        DOM event type: `&#34;click&#34;`, `&#34;dragstart&#34;`, etc.
    eventInit : Optional[Dict]
        event-specific initialization properties.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.dispatchEvent(
                type=type, eventInit=mapping.to_impl(eventInit)
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.evalOnSelector"><code class="name flex">
<span>def <span class="ident">evalOnSelector</span></span>(<span>self, selector: str, expression: str, arg: Any = None, force_expr: bool = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.evalOnSelector</p>
<p>The method finds an element matching the specified selector in the <code><a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a></code>s subtree and passes it as a first argument to <code>pageFunction</code>. See Working with selectors for more details. If no elements match the selector, the method throws an error.
If <code>pageFunction</code> returns a Promise, then <code>frame.$eval</code> would wait for the promise to resolve and return its value.
Examples:</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query element for. See working with selectors for more details.</dd>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>Function to be evaluated in browser context</dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Optional[Any]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>Promise which resolves to the return value of <code>pageFunction</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evalOnSelector(
    self,
    selector: str,
    expression: str,
    arg: typing.Any = None,
    force_expr: bool = None,
) -&gt; typing.Any:
    &#34;&#34;&#34;ElementHandle.evalOnSelector

    The method finds an element matching the specified selector in the `ElementHandle`s subtree and passes it as a first argument to `pageFunction`. See Working with selectors for more details. If no elements match the selector, the method throws an error.
    If `pageFunction` returns a Promise, then `frame.$eval` would wait for the promise to resolve and return its value.
    Examples:

    Parameters
    ----------
    selector : str
        A selector to query element for. See working with selectors for more details.
    expression : str
        Function to be evaluated in browser context
    force_expr : bool
        Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
    arg : Optional[Any]
        Optional argument to pass to `pageFunction`

    Returns
    -------
    Any
        Promise which resolves to the return value of `pageFunction`
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.evalOnSelector(
                selector=selector,
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.evalOnSelectorAll"><code class="name flex">
<span>def <span class="ident">evalOnSelectorAll</span></span>(<span>self, selector: str, expression: str, arg: Any = None, force_expr: bool = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.evalOnSelectorAll</p>
<p>The method finds all elements matching the specified selector in the <code><a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a></code>'s subtree and passes an array of matched elements as a first argument to <code>pageFunction</code>. See Working with selectors for more details.
If <code>pageFunction</code> returns a Promise, then <code>frame.$$eval</code> would wait for the promise to resolve and return its value.
Examples:</p>
<pre><code class="language-html">&lt;div class=&quot;feed&quot;&gt;
  &lt;div class=&quot;tweet&quot;&gt;Hello!&lt;/div&gt;
  &lt;div class=&quot;tweet&quot;&gt;Hi!&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query element for. See working with selectors for more details.</dd>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>Function to be evaluated in browser context</dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Optional[Any]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>Promise which resolves to the return value of <code>pageFunction</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evalOnSelectorAll(
    self,
    selector: str,
    expression: str,
    arg: typing.Any = None,
    force_expr: bool = None,
) -&gt; typing.Any:
    &#34;&#34;&#34;ElementHandle.evalOnSelectorAll

    The method finds all elements matching the specified selector in the `ElementHandle`&#39;s subtree and passes an array of matched elements as a first argument to `pageFunction`. See Working with selectors for more details.
    If `pageFunction` returns a Promise, then `frame.$$eval` would wait for the promise to resolve and return its value.
    Examples:
    ```html
    &lt;div class=&#34;feed&#34;&gt;
      &lt;div class=&#34;tweet&#34;&gt;Hello!&lt;/div&gt;
      &lt;div class=&#34;tweet&#34;&gt;Hi!&lt;/div&gt;
    &lt;/div&gt;
    ```

    Parameters
    ----------
    selector : str
        A selector to query element for. See working with selectors for more details.
    expression : str
        Function to be evaluated in browser context
    force_expr : bool
        Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
    arg : Optional[Any]
        Optional argument to pass to `pageFunction`

    Returns
    -------
    Any
        Promise which resolves to the return value of `pageFunction`
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.evalOnSelectorAll(
                selector=selector,
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.fill"><code class="name flex">
<span>def <span class="ident">fill</span></span>(<span>self, value: str, timeout: int = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.fill</p>
<p>This method waits for actionability checks, focuses the element, fills it and triggers an <code>input</code> event after filling.
If the element is not an <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> or <code>[contenteditable]</code> element, this method throws an error.
Note that you can pass an empty string to clear the input field.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>Value to set for the <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> or <code>[contenteditable]</code> element.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fill(
    self, value: str, timeout: int = None, noWaitAfter: bool = None
) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.fill

    This method waits for actionability checks, focuses the element, fills it and triggers an `input` event after filling.
    If the element is not an `&lt;input&gt;`, `&lt;textarea&gt;` or `[contenteditable]` element, this method throws an error.
    Note that you can pass an empty string to clear the input field.

    Parameters
    ----------
    value : str
        Value to set for the `&lt;input&gt;`, `&lt;textarea&gt;` or `[contenteditable]` element.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.fill(
                value=value, timeout=timeout, noWaitAfter=noWaitAfter
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.focus"><code class="name flex">
<span>def <span class="ident">focus</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.focus</p>
<p>Calls focus on the element.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def focus(self) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.focus

    Calls focus on the element.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.focus()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.getAttribute"><code class="name flex">
<span>def <span class="ident">getAttribute</span></span>(<span>self, name: str) ‑> Union[str, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.getAttribute</p>
<p>Returns element attribute value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Attribute name to get the value for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[str]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAttribute(self, name: str) -&gt; typing.Union[str, NoneType]:
    &#34;&#34;&#34;ElementHandle.getAttribute

    Returns element attribute value.

    Parameters
    ----------
    name : str
        Attribute name to get the value for.

    Returns
    -------
    Optional[str]
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.getAttribute(name=name))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.hover"><code class="name flex">
<span>def <span class="ident">hover</span></span>(<span>self, modifiers: List[Literal['Alt', 'Control', 'Meta', 'Shift']] = None, position: playwright.helper.MousePosition = None, timeout: int = None, force: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.hover</p>
<p>This method hovers over the element by performing the following steps:</p>
<p>Wait for actionability checks on the element, unless <code>force</code> option is set.
Scroll the element into view if needed.
Use page.mouse to hover over the center of the element, or the specified <code>position</code>.
Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.</p>
<p>If the element is detached from the DOM at any moment during the action, this method rejects.
When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a TimeoutError. Passing zero timeout disables this.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>modifiers</code></strong> :&ensp;<code>Optional[List[Literal['Alt', 'Control', 'Meta', 'Shift']]]</code></dt>
<dd>Modifier keys to press. Ensures that only these modifiers are pressed during the hover, and then restores current modifiers back. If not specified, currently pressed modifiers are used.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>Optional[{"x": float, "y": float}]</code></dt>
<dd>A point to hover relative to the top-left corner of element padding box. If not specified, hovers over some visible point of the element.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to bypass the actionability checks. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hover(
    self,
    modifiers: typing.Union[
        typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
    ] = None,
    position: MousePosition = None,
    timeout: int = None,
    force: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.hover

    This method hovers over the element by performing the following steps:

    Wait for actionability checks on the element, unless `force` option is set.
    Scroll the element into view if needed.
    Use page.mouse to hover over the center of the element, or the specified `position`.
    Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

    If the element is detached from the DOM at any moment during the action, this method rejects.
    When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

    Parameters
    ----------
    modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
        Modifier keys to press. Ensures that only these modifiers are pressed during the hover, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
    position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
        A point to hover relative to the top-left corner of element padding box. If not specified, hovers over some visible point of the element.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    force : Optional[bool]
        Whether to bypass the actionability checks. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.hover(
                modifiers=modifiers, position=position, timeout=timeout, force=force
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.innerHTML"><code class="name flex">
<span>def <span class="ident">innerHTML</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.innerHTML</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Resolves to the <code>element.innerHTML</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def innerHTML(self) -&gt; str:
    &#34;&#34;&#34;ElementHandle.innerHTML

    Returns
    -------
    str
        Resolves to the `element.innerHTML`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.innerHTML()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.innerText"><code class="name flex">
<span>def <span class="ident">innerText</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.innerText</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Resolves to the <code>element.innerText</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def innerText(self) -&gt; str:
    &#34;&#34;&#34;ElementHandle.innerText

    Returns
    -------
    str
        Resolves to the `element.innerText`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.innerText()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.ownerFrame"><code class="name flex">
<span>def <span class="ident">ownerFrame</span></span>(<span>self) ‑> Union[<a title="playwright.async_api.Frame" href="async_api.html#playwright.async_api.Frame">Frame</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.ownerFrame</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[<a title="playwright.sync_api.Frame" href="#playwright.sync_api.Frame">Frame</a>]</code></dt>
<dd>Returns the frame containing the given element.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ownerFrame(self) -&gt; typing.Union[&#34;Frame&#34;, NoneType]:
    &#34;&#34;&#34;ElementHandle.ownerFrame

    Returns
    -------
    Optional[Frame]
        Returns the frame containing the given element.
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(self._sync(self._impl_obj.ownerFrame()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.press"><code class="name flex">
<span>def <span class="ident">press</span></span>(<span>self, key: str, delay: int = None, timeout: int = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.press</p>
<p>Focuses the element, and then uses <code>keyboard.down</code> and <code>keyboard.up</code>.
<code>key</code> can specify the intended keyboardEvent.key value or a single character to generate the text for. A superset of the <code>key</code> values can be found here. Examples of the keys are:
<code>F1</code> - <code>F12</code>, <code>Digit0</code>- <code>Digit9</code>, <code>KeyA</code>- <code>KeyZ</code>, <code>Backquote</code>, <code>Minus</code>, <code>Equal</code>, <code>Backslash</code>, <code>Backspace</code>, <code>Tab</code>, <code>Delete</code>, <code>Escape</code>, <code>ArrowDown</code>, <code>End</code>, <code>Enter</code>, <code>Home</code>, <code>Insert</code>, <code>PageDown</code>, <code>PageUp</code>, <code>ArrowRight</code>, <code>ArrowUp</code>, etc.
Following modification shortcuts are also suported: <code>Shift</code>, <code>Control</code>, <code>Alt</code>, <code>Meta</code>, <code>ShiftLeft</code>.
Holding down <code>Shift</code> will type the text that corresponds to the <code>key</code> in the upper case.
If <code>key</code> is a single character, it is case-sensitive, so the values <code>a</code> and <code>A</code> will generate different respective texts.
Shortcuts such as <code>key: "Control+o"</code> or <code>key: "Control+Shift+T"</code> are supported as well. When speficied with the modifier, modifier is pressed and being held while the subsequent key is being pressed.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the key to press or a character to generate, such as <code>ArrowLeft</code> or <code>a</code>.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Time to wait between <code>keydown</code> and <code>keyup</code> in milliseconds. Defaults to 0.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def press(
    self, key: str, delay: int = None, timeout: int = None, noWaitAfter: bool = None
) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.press

    Focuses the element, and then uses `keyboard.down` and `keyboard.up`.
    `key` can specify the intended keyboardEvent.key value or a single character to generate the text for. A superset of the `key` values can be found here. Examples of the keys are:
    `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`, `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.
    Following modification shortcuts are also suported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`.
    Holding down `Shift` will type the text that corresponds to the `key` in the upper case.
    If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective texts.
    Shortcuts such as `key: &#34;Control+o&#34;` or `key: &#34;Control+Shift+T&#34;` are supported as well. When speficied with the modifier, modifier is pressed and being held while the subsequent key is being pressed.

    Parameters
    ----------
    key : str
        Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
    delay : Optional[int]
        Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.press(
                key=key, delay=delay, timeout=timeout, noWaitAfter=noWaitAfter
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.querySelector"><code class="name flex">
<span>def <span class="ident">querySelector</span></span>(<span>self, selector: str) ‑> Union[<a title="playwright.async_api.ElementHandle" href="async_api.html#playwright.async_api.ElementHandle">ElementHandle</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.querySelector</p>
<p>The method finds an element matching the specified selector in the <code><a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a></code>'s subtree. See Working with selectors for more details. If no elements match the selector, the return value resolves to <code>null</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query element for. See working with selectors for more details.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[<a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def querySelector(self, selector: str) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
    &#34;&#34;&#34;ElementHandle.querySelector

    The method finds an element matching the specified selector in the `ElementHandle`&#39;s subtree. See Working with selectors for more details. If no elements match the selector, the return value resolves to `null`.

    Parameters
    ----------
    selector : str
        A selector to query element for. See working with selectors for more details.

    Returns
    -------
    Optional[ElementHandle]
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(
        self._sync(self._impl_obj.querySelector(selector=selector))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.querySelectorAll"><code class="name flex">
<span>def <span class="ident">querySelectorAll</span></span>(<span>self, selector: str) ‑> List[<a title="playwright.async_api.ElementHandle" href="async_api.html#playwright.async_api.ElementHandle">ElementHandle</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.querySelectorAll</p>
<p>The method finds all elements matching the specified selector in the <code><a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a></code>s subtree. See Working with selectors for more details. If no elements match the selector, the return value resolves to <code>[]</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query element for. See working with selectors for more details.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def querySelectorAll(self, selector: str) -&gt; typing.List[&#34;ElementHandle&#34;]:
    &#34;&#34;&#34;ElementHandle.querySelectorAll

    The method finds all elements matching the specified selector in the `ElementHandle`s subtree. See Working with selectors for more details. If no elements match the selector, the return value resolves to `[]`.

    Parameters
    ----------
    selector : str
        A selector to query element for. See working with selectors for more details.

    Returns
    -------
    List[ElementHandle]
    &#34;&#34;&#34;
    return mapping.from_impl_list(
        self._sync(self._impl_obj.querySelectorAll(selector=selector))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.screenshot"><code class="name flex">
<span>def <span class="ident">screenshot</span></span>(<span>self, timeout: int = None, type: Literal['jpeg', 'png'] = None, path: Union[str, pathlib.Path] = None, quality: int = None, omitBackground: bool = None) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.screenshot</p>
<p>This method waits for the actionability checks, then scrolls element into view before taking a screenshot. If the element is detached from DOM, the method throws an error.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>Optional[Literal['jpeg', 'png']]</code></dt>
<dd>Specify screenshot type, defaults to <code>png</code>.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[str, pathlib.Path, NoneType]</code></dt>
<dd>The file path to save the image to. The screenshot type will be inferred from file extension. If <code>path</code> is a relative path, then it is resolved relative to current working directory. If no path is provided, the image won't be saved to the disk.</dd>
<dt><strong><code>quality</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>The quality of the image, between 0-100. Not applicable to <code>png</code> images.</dd>
<dt><strong><code>omitBackground</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Hides default white background and allows capturing screenshots with transparency. Not applicable to <code>jpeg</code> images. Defaults to <code>false</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>Promise which resolves to buffer with the captured screenshot.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def screenshot(
    self,
    timeout: int = None,
    type: Literal[&#34;jpeg&#34;, &#34;png&#34;] = None,
    path: typing.Union[str, pathlib.Path] = None,
    quality: int = None,
    omitBackground: bool = None,
) -&gt; bytes:
    &#34;&#34;&#34;ElementHandle.screenshot

    This method waits for the actionability checks, then scrolls element into view before taking a screenshot. If the element is detached from DOM, the method throws an error.

    Parameters
    ----------
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    type : Optional[Literal[&#39;jpeg&#39;, &#39;png&#39;]]
        Specify screenshot type, defaults to `png`.
    path : Union[str, pathlib.Path, NoneType]
        The file path to save the image to. The screenshot type will be inferred from file extension. If `path` is a relative path, then it is resolved relative to current working directory. If no path is provided, the image won&#39;t be saved to the disk.
    quality : Optional[int]
        The quality of the image, between 0-100. Not applicable to `png` images.
    omitBackground : Optional[bool]
        Hides default white background and allows capturing screenshots with transparency. Not applicable to `jpeg` images. Defaults to `false`.

    Returns
    -------
    bytes
        Promise which resolves to buffer with the captured screenshot.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.screenshot(
                timeout=timeout,
                type=type,
                path=path,
                quality=quality,
                omitBackground=omitBackground,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.scrollIntoViewIfNeeded"><code class="name flex">
<span>def <span class="ident">scrollIntoViewIfNeeded</span></span>(<span>self, timeout: int = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.scrollIntoViewIfNeeded</p>
<p>This method waits for actionability checks, then tries to scroll element into view, unless it is completely visible as defined by IntersectionObserver's <code>ratio</code>.
Throws when <code>elementHandle</code> does not point to an element connected to a Document or a ShadowRoot.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scrollIntoViewIfNeeded(self, timeout: int = None) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.scrollIntoViewIfNeeded

    This method waits for actionability checks, then tries to scroll element into view, unless it is completely visible as defined by IntersectionObserver&#39;s `ratio`.
    Throws when `elementHandle` does not point to an element connected to a Document or a ShadowRoot.

    Parameters
    ----------
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.scrollIntoViewIfNeeded(timeout=timeout))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.selectOption"><code class="name flex">
<span>def <span class="ident">selectOption</span></span>(<span>self, values: Union[str, ForwardRef('<a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a>'), playwright.helper.SelectOption, List[str], List[ForwardRef('<a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a>')], List[playwright.helper.SelectOption]] = None, timeout: int = None, noWaitAfter: bool = None) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.selectOption</p>
<p>Triggers a <code>change</code> and <code>input</code> event once all the provided options have been selected.
If element is not a <code>&lt;select&gt;</code> element, the method throws an error.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>values</code></strong> :&ensp;<code>Union[str, ElementHandle, {"value": Optional[str], "label": Optional[str], "index": Optional[str]}, List[str], List[ElementHandle], List[{"value": Optional[str], "label": Optional[str], "index": Optional[str]}], NoneType]</code></dt>
<dd>Options to select. If the <code>&lt;select&gt;</code> has the <code>multiple</code> attribute, all matching options are selected, otherwise only the first option matching one of the passed options is selected. String values are equivalent to <code>{value:'string'}</code>. Option is considered matching if all specified properties match.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[str]</code></dt>
<dd>An array of option values that have been successfully selected.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selectOption(
    self,
    values: typing.Union[
        str,
        &#34;ElementHandle&#34;,
        SelectOption,
        typing.List[str],
        typing.List[&#34;ElementHandle&#34;],
        typing.List[SelectOption],
    ] = None,
    timeout: int = None,
    noWaitAfter: bool = None,
) -&gt; typing.List[str]:
    &#34;&#34;&#34;ElementHandle.selectOption

    Triggers a `change` and `input` event once all the provided options have been selected.
    If element is not a `&lt;select&gt;` element, the method throws an error.

    Parameters
    ----------
    values : Union[str, ElementHandle, {&#34;value&#34;: Optional[str], &#34;label&#34;: Optional[str], &#34;index&#34;: Optional[str]}, List[str], List[ElementHandle], List[{&#34;value&#34;: Optional[str], &#34;label&#34;: Optional[str], &#34;index&#34;: Optional[str]}], NoneType]
        Options to select. If the `&lt;select&gt;` has the `multiple` attribute, all matching options are selected, otherwise only the first option matching one of the passed options is selected. String values are equivalent to `{value:&#39;string&#39;}`. Option is considered matching if all specified properties match.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.

    Returns
    -------
    List[str]
        An array of option values that have been successfully selected.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.selectOption(
                values=mapping.to_impl(values),
                timeout=timeout,
                noWaitAfter=noWaitAfter,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.selectText"><code class="name flex">
<span>def <span class="ident">selectText</span></span>(<span>self, timeout: int = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.selectText</p>
<p>This method waits for actionability checks, then focuses the element and selects all its text content.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selectText(self, timeout: int = None) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.selectText

    This method waits for actionability checks, then focuses the element and selects all its text content.

    Parameters
    ----------
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.selectText(timeout=timeout))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.setInputFiles"><code class="name flex">
<span>def <span class="ident">setInputFiles</span></span>(<span>self, files: Union[str, pathlib.Path, playwright.helper.FilePayload, List[str], List[pathlib.Path], List[playwright.helper.FilePayload]], timeout: int = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.setInputFiles</p>
<p>This method expects <code>elementHandle</code> to point to an input element.
Sets the value of the file input to these file paths or files. If some of the <code>filePaths</code> are relative paths, then they are resolved relative to the current working directory. For empty array, clears the selected files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>files</code></strong> :&ensp;<code>Union[str, pathlib.Path, {"name": str, "mimeType": str, "buffer": bytes}, List[str], List[pathlib.Path], List[{"name": str, "mimeType": str, "buffer": bytes}]]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setInputFiles(
    self,
    files: typing.Union[
        str,
        pathlib.Path,
        FilePayload,
        typing.List[str],
        typing.List[pathlib.Path],
        typing.List[FilePayload],
    ],
    timeout: int = None,
    noWaitAfter: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.setInputFiles

    This method expects `elementHandle` to point to an input element.
    Sets the value of the file input to these file paths or files. If some of the `filePaths` are relative paths, then they are resolved relative to the current working directory. For empty array, clears the selected files.

    Parameters
    ----------
    files : Union[str, pathlib.Path, {&#34;name&#34;: str, &#34;mimeType&#34;: str, &#34;buffer&#34;: bytes}, List[str], List[pathlib.Path], List[{&#34;name&#34;: str, &#34;mimeType&#34;: str, &#34;buffer&#34;: bytes}]]
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.setInputFiles(
                files=files, timeout=timeout, noWaitAfter=noWaitAfter
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.tap"><code class="name flex">
<span>def <span class="ident">tap</span></span>(<span>self, modifiers: List[Literal['Alt', 'Control', 'Meta', 'Shift']] = None, position: playwright.helper.MousePosition = None, timeout: int = None, force: bool = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.tap</p>
<p>This method taps the element by performing the following steps:</p>
<p>Wait for actionability checks on the element, unless <code>force</code> option is set.
Scroll the element into view if needed.
Use page.touchscreen to tap in the center of the element, or the specified <code>position</code>.
Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.</p>
<p>If the element is detached from the DOM at any moment during the action, this method rejects.
When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a TimeoutError. Passing zero timeout disables this.</p>
<p><strong>NOTE</strong> <code>elementHandle.tap()</code> requires that the <code>hasTouch</code> option of the browser context be set to true.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>modifiers</code></strong> :&ensp;<code>Optional[List[Literal['Alt', 'Control', 'Meta', 'Shift']]]</code></dt>
<dd>Modifier keys to press. Ensures that only these modifiers are pressed during the tap, and then restores current modifiers back. If not specified, currently pressed modifiers are used.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>Optional[{"x": float, "y": float}]</code></dt>
<dd>A point to tap relative to the top-left corner of element padding box. If not specified, taps some visible point of the element.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to bypass the actionability checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tap(
    self,
    modifiers: typing.Union[
        typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
    ] = None,
    position: MousePosition = None,
    timeout: int = None,
    force: bool = None,
    noWaitAfter: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.tap

    This method taps the element by performing the following steps:

    Wait for actionability checks on the element, unless `force` option is set.
    Scroll the element into view if needed.
    Use page.touchscreen to tap in the center of the element, or the specified `position`.
    Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

    If the element is detached from the DOM at any moment during the action, this method rejects.
    When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

    **NOTE** `elementHandle.tap()` requires that the `hasTouch` option of the browser context be set to true.

    Parameters
    ----------
    modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
        Modifier keys to press. Ensures that only these modifiers are pressed during the tap, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
    position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
        A point to tap relative to the top-left corner of element padding box. If not specified, taps some visible point of the element.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    force : Optional[bool]
        Whether to bypass the actionability checks. Defaults to `false`.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.tap(
                modifiers=modifiers,
                position=position,
                timeout=timeout,
                force=force,
                noWaitAfter=noWaitAfter,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.textContent"><code class="name flex">
<span>def <span class="ident">textContent</span></span>(<span>self) ‑> Union[str, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.textContent</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[str]</code></dt>
<dd>Resolves to the <code>node.textContent</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def textContent(self) -&gt; typing.Union[str, NoneType]:
    &#34;&#34;&#34;ElementHandle.textContent

    Returns
    -------
    Optional[str]
        Resolves to the `node.textContent`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.textContent()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.toString"><code class="name flex">
<span>def <span class="ident">toString</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.toString</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toString(self) -&gt; str:
    &#34;&#34;&#34;ElementHandle.toString

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.toString())</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.type"><code class="name flex">
<span>def <span class="ident">type</span></span>(<span>self, text: str, delay: int = None, timeout: int = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.type</p>
<p>Focuses the element, and then sends a <code>keydown</code>, <code>keypress</code>/<code>input</code>, and <code>keyup</code> event for each character in the text.
To press a special key, like <code>Control</code> or <code>ArrowDown</code>, use <code>elementHandle.press</code>.
An example of typing into a text field and then submitting the form:</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>A text to type into a focused element.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Time to wait between key presses in milliseconds. Defaults to 0.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def type(
    self,
    text: str,
    delay: int = None,
    timeout: int = None,
    noWaitAfter: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.type

    Focuses the element, and then sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text.
    To press a special key, like `Control` or `ArrowDown`, use `elementHandle.press`.
    An example of typing into a text field and then submitting the form:

    Parameters
    ----------
    text : str
        A text to type into a focused element.
    delay : Optional[int]
        Time to wait between key presses in milliseconds. Defaults to 0.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.type(
                text=text, delay=delay, timeout=timeout, noWaitAfter=noWaitAfter
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.uncheck"><code class="name flex">
<span>def <span class="ident">uncheck</span></span>(<span>self, timeout: int = None, force: bool = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.uncheck</p>
<p>This method checks the element by performing the following steps:</p>
<p>Ensure that element is a checkbox or a radio input. If not, this method rejects. If the element is already unchecked, this method returns immediately.
Wait for actionability checks on the element, unless <code>force</code> option is set.
Scroll the element into view if needed.
Use page.mouse to click in the center of the element.
Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.
Ensure that the element is now unchecked. If not, this method rejects.</p>
<p>If the element is detached from the DOM at any moment during the action, this method rejects.
When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a TimeoutError. Passing zero timeout disables this.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to bypass the actionability checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uncheck(
    self, timeout: int = None, force: bool = None, noWaitAfter: bool = None
) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.uncheck

    This method checks the element by performing the following steps:

    Ensure that element is a checkbox or a radio input. If not, this method rejects. If the element is already unchecked, this method returns immediately.
    Wait for actionability checks on the element, unless `force` option is set.
    Scroll the element into view if needed.
    Use page.mouse to click in the center of the element.
    Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
    Ensure that the element is now unchecked. If not, this method rejects.

    If the element is detached from the DOM at any moment during the action, this method rejects.
    When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

    Parameters
    ----------
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    force : Optional[bool]
        Whether to bypass the actionability checks. Defaults to `false`.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.uncheck(
                timeout=timeout, force=force, noWaitAfter=noWaitAfter
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.waitForElementState"><code class="name flex">
<span>def <span class="ident">waitForElementState</span></span>(<span>self, state: Literal['disabled', 'enabled', 'hidden', 'stable', 'visible'], timeout: int = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.waitForElementState</p>
<p>Depending on the <code>state</code> parameter, this method waits for one of the actionability checks to pass. This method throws when the element is detached while waiting, unless waiting for the <code>"hidden"</code> state.</p>
<p><code>"visible"</code> Wait until the element is visible.
<code>"hidden"</code> Wait until the element is not visible or not attached. Note that waiting for hidden does not throw when the element detaches.
<code>"stable"</code> Wait until the element is both visible and stable.
<code>"enabled"</code> Wait until the element is enabled.
<code>"disabled"</code> Wait until the element is not enabled.</p>
<p>If the element does not satisfy the condition for the <code>timeout</code> milliseconds, this method will throw.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<code>Literal['disabled', 'enabled', 'hidden', 'stable', 'visible']</code></dt>
<dd>A state to wait for, see below for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def waitForElementState(
    self,
    state: Literal[&#34;disabled&#34;, &#34;enabled&#34;, &#34;hidden&#34;, &#34;stable&#34;, &#34;visible&#34;],
    timeout: int = None,
) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.waitForElementState

    Depending on the `state` parameter, this method waits for one of the actionability checks to pass. This method throws when the element is detached while waiting, unless waiting for the `&#34;hidden&#34;` state.

    `&#34;visible&#34;` Wait until the element is visible.
    `&#34;hidden&#34;` Wait until the element is not visible or not attached. Note that waiting for hidden does not throw when the element detaches.
    `&#34;stable&#34;` Wait until the element is both visible and stable.
    `&#34;enabled&#34;` Wait until the element is enabled.
    `&#34;disabled&#34;` Wait until the element is not enabled.

    If the element does not satisfy the condition for the `timeout` milliseconds, this method will throw.

    Parameters
    ----------
    state : Literal[&#39;disabled&#39;, &#39;enabled&#39;, &#39;hidden&#39;, &#39;stable&#39;, &#39;visible&#39;]
        A state to wait for, see below for more details.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.waitForElementState(state=state, timeout=timeout))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.ElementHandle.waitForSelector"><code class="name flex">
<span>def <span class="ident">waitForSelector</span></span>(<span>self, selector: str, state: Literal['attached', 'detached', 'hidden', 'visible'] = None, timeout: int = None) ‑> Union[<a title="playwright.async_api.ElementHandle" href="async_api.html#playwright.async_api.ElementHandle">ElementHandle</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.waitForSelector</p>
<p>Wait for the <code>selector</code> relative to the element handle to satisfy <code>state</code> option (either appear/disappear from dom, or become visible/hidden). If at the moment of calling the method <code>selector</code> already satisfies the condition, the method will return immediately. If the selector doesn't satisfy the condition for the <code>timeout</code> milliseconds, the function will throw.</p>
<p><strong>NOTE</strong> This method does not work across navigations, use page.waitForSelector(selector[, options]) instead.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector of an element to wait for, relative to the element handle. See working with selectors for more details.</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>Optional[Literal['attached', 'detached', 'hidden', 'visible']]</code></dt>
<dd>Defaults to <code>'visible'</code>. Can be either:
- <code>'attached'</code> - wait for element to be present in DOM.
- <code>'detached'</code> - wait for element to not be present in DOM.
- <code>'visible'</code> - wait for element to have non-empty bounding box and no <code>visibility:hidden</code>. Note that element without any content or with <code>display:none</code> has an empty bounding box and is not considered visible.
- <code>'hidden'</code> - wait for element to be either detached from DOM, or have an empty bounding box or <code>visibility:hidden</code>. This is opposite to the <code>'visible'</code> option.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[<a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a>]</code></dt>
<dd>Promise that resolves when element specified by selector satisfies <code>state</code> option. Resolves to <code>null</code> if waiting for <code>hidden</code> or <code>detached</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def waitForSelector(
    self,
    selector: str,
    state: Literal[&#34;attached&#34;, &#34;detached&#34;, &#34;hidden&#34;, &#34;visible&#34;] = None,
    timeout: int = None,
) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
    &#34;&#34;&#34;ElementHandle.waitForSelector

    Wait for the `selector` relative to the element handle to satisfy `state` option (either appear/disappear from dom, or become visible/hidden). If at the moment of calling the method `selector` already satisfies the condition, the method will return immediately. If the selector doesn&#39;t satisfy the condition for the `timeout` milliseconds, the function will throw.

    **NOTE** This method does not work across navigations, use page.waitForSelector(selector[, options]) instead.

    Parameters
    ----------
    selector : str
        A selector of an element to wait for, relative to the element handle. See working with selectors for more details.
    state : Optional[Literal[&#39;attached&#39;, &#39;detached&#39;, &#39;hidden&#39;, &#39;visible&#39;]]
        Defaults to `&#39;visible&#39;`. Can be either:
         - `&#39;attached&#39;` - wait for element to be present in DOM.
         - `&#39;detached&#39;` - wait for element to not be present in DOM.
         - `&#39;visible&#39;` - wait for element to have non-empty bounding box and no `visibility:hidden`. Note that element without any content or with `display:none` has an empty bounding box and is not considered visible.
         - `&#39;hidden&#39;` - wait for element to be either detached from DOM, or have an empty bounding box or `visibility:hidden`. This is opposite to the `&#39;visible&#39;` option.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

    Returns
    -------
    Optional[ElementHandle]
        Promise that resolves when element specified by selector satisfies `state` option. Resolves to `null` if waiting for `hidden` or `detached`.
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(
        self._sync(
            self._impl_obj.waitForSelector(
                selector=selector, state=state, timeout=timeout
            )
        )
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="playwright.sync_api.JSHandle" href="#playwright.sync_api.JSHandle">JSHandle</a></b></code>:
<ul class="hlist">
<li><code><a title="playwright.sync_api.JSHandle.dispose" href="#playwright.sync_api.JSHandle.dispose">dispose</a></code></li>
<li><code><a title="playwright.sync_api.JSHandle.evaluate" href="#playwright.sync_api.JSHandle.evaluate">evaluate</a></code></li>
<li><code><a title="playwright.sync_api.JSHandle.evaluateHandle" href="#playwright.sync_api.JSHandle.evaluateHandle">evaluateHandle</a></code></li>
<li><code><a title="playwright.sync_api.JSHandle.getProperties" href="#playwright.sync_api.JSHandle.getProperties">getProperties</a></code></li>
<li><code><a title="playwright.sync_api.JSHandle.getProperty" href="#playwright.sync_api.JSHandle.getProperty">getProperty</a></code></li>
<li><code><a title="playwright.sync_api.JSHandle.jsonValue" href="#playwright.sync_api.JSHandle.jsonValue">jsonValue</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="playwright.sync_api.FileChooser"><code class="flex name class">
<span>class <span class="ident">FileChooser</span></span>
<span>(</span><span>obj: playwright.file_chooser.FileChooser)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileChooser(SyncBase):
    def __init__(self, obj: FileChooserImpl):
        super().__init__(obj)

    @property
    def page(self) -&gt; &#34;Page&#34;:
        &#34;&#34;&#34;FileChooser.page

        Returns page this file chooser belongs to.

        Returns
        -------
        Page
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.page)

    @property
    def element(self) -&gt; &#34;ElementHandle&#34;:
        &#34;&#34;&#34;FileChooser.element

        Returns input element associated with this file chooser.

        Returns
        -------
        ElementHandle
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.element)

    @property
    def isMultiple(self) -&gt; bool:
        &#34;&#34;&#34;FileChooser.isMultiple

        Returns whether this file chooser accepts multiple files.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.isMultiple)

    def setFiles(
        self,
        files: typing.Union[
            str, FilePayload, typing.List[str], typing.List[FilePayload]
        ],
        timeout: int = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;FileChooser.setFiles

        Sets the value of the file input this chooser is associated with. If some of the `filePaths` are relative paths, then they are resolved relative to the current working directory. For empty array, clears the selected files.

        Parameters
        ----------
        files : Union[str, {&#34;name&#34;: str, &#34;mimeType&#34;: str, &#34;buffer&#34;: bytes}, List[str], List[{&#34;name&#34;: str, &#34;mimeType&#34;: str, &#34;buffer&#34;: bytes}]]
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.setFiles(
                    files=files, timeout=timeout, noWaitAfter=noWaitAfter
                )
            )
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright.sync_base.SyncBase</li>
<li>playwright.impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.sync_api.FileChooser.element"><code class="name">var <span class="ident">element</span> : <a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a></code></dt>
<dd>
<div class="desc"><p>FileChooser.element</p>
<p>Returns input element associated with this file chooser.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def element(self) -&gt; &#34;ElementHandle&#34;:
    &#34;&#34;&#34;FileChooser.element

    Returns input element associated with this file chooser.

    Returns
    -------
    ElementHandle
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.element)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.FileChooser.isMultiple"><code class="name">var <span class="ident">isMultiple</span> : bool</code></dt>
<dd>
<div class="desc"><p>FileChooser.isMultiple</p>
<p>Returns whether this file chooser accepts multiple files.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def isMultiple(self) -&gt; bool:
    &#34;&#34;&#34;FileChooser.isMultiple

    Returns whether this file chooser accepts multiple files.

    Returns
    -------
    bool
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.isMultiple)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.FileChooser.page"><code class="name">var <span class="ident">page</span> : <a title="playwright.sync_api.Page" href="#playwright.sync_api.Page">Page</a></code></dt>
<dd>
<div class="desc"><p>FileChooser.page</p>
<p>Returns page this file chooser belongs to.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.Page" href="#playwright.sync_api.Page">Page</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def page(self) -&gt; &#34;Page&#34;:
    &#34;&#34;&#34;FileChooser.page

    Returns page this file chooser belongs to.

    Returns
    -------
    Page
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.page)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.sync_api.FileChooser.setFiles"><code class="name flex">
<span>def <span class="ident">setFiles</span></span>(<span>self, files: Union[str, playwright.helper.FilePayload, List[str], List[playwright.helper.FilePayload]], timeout: int = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>FileChooser.setFiles</p>
<p>Sets the value of the file input this chooser is associated with. If some of the <code>filePaths</code> are relative paths, then they are resolved relative to the current working directory. For empty array, clears the selected files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>files</code></strong> :&ensp;<code>Union[str, {"name": str, "mimeType": str, "buffer": bytes}, List[str], List[{"name": str, "mimeType": str, "buffer": bytes}]]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setFiles(
    self,
    files: typing.Union[
        str, FilePayload, typing.List[str], typing.List[FilePayload]
    ],
    timeout: int = None,
    noWaitAfter: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;FileChooser.setFiles

    Sets the value of the file input this chooser is associated with. If some of the `filePaths` are relative paths, then they are resolved relative to the current working directory. For empty array, clears the selected files.

    Parameters
    ----------
    files : Union[str, {&#34;name&#34;: str, &#34;mimeType&#34;: str, &#34;buffer&#34;: bytes}, List[str], List[{&#34;name&#34;: str, &#34;mimeType&#34;: str, &#34;buffer&#34;: bytes}]]
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.setFiles(
                files=files, timeout=timeout, noWaitAfter=noWaitAfter
            )
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.sync_api.Frame"><code class="flex name class">
<span>class <span class="ident">Frame</span></span>
<span>(</span><span>obj: playwright.frame.Frame)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Frame(SyncBase):
    def __init__(self, obj: FrameImpl):
        super().__init__(obj)

    @property
    def page(self) -&gt; &#34;Page&#34;:
        &#34;&#34;&#34;Frame.page

        Returns the page containing this frame.

        Returns
        -------
        Page
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.page)

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Frame.name

        Returns frame&#39;s name attribute as specified in the tag.
        If the name is empty, returns the id attribute instead.

        **NOTE** This value is calculated once when the frame is created, and will not update if the attribute is changed later.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.name)

    @property
    def url(self) -&gt; str:
        &#34;&#34;&#34;Frame.url

        Returns frame&#39;s url.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.url)

    @property
    def parentFrame(self) -&gt; typing.Union[&#34;Frame&#34;, NoneType]:
        &#34;&#34;&#34;Frame.parentFrame

        Returns
        -------
        Optional[Frame]
            Parent frame, if any. Detached frames and main frames return `null`.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._impl_obj.parentFrame)

    @property
    def childFrames(self) -&gt; typing.List[&#34;Frame&#34;]:
        &#34;&#34;&#34;Frame.childFrames

        Returns
        -------
        List[Frame]
        &#34;&#34;&#34;
        return mapping.from_impl_list(self._impl_obj.childFrames)

    def goto(
        self,
        url: str,
        timeout: int = None,
        waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        referer: str = None,
    ) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
        &#34;&#34;&#34;Frame.goto

        `frame.goto` will throw an error if:

        there&#39;s an SSL error (e.g. in case of self-signed certificates).
        target URL is invalid.
        the `timeout` is exceeded during navigation.
        the remote server does not respond or is unreachable.
        the main resource failed to load.

        `frame.goto` will not throw an error when any valid HTTP status code is returned by the remote server, including 404 &#34;Not Found&#34; and 500 &#34;Internal Server Error&#34;.  The status code for such responses can be retrieved by calling response.status().

        **NOTE** `frame.goto` either throws an error or returns a main resource response. The only exceptions are navigation to `about:blank` or navigation to the same URL with a different hash, which would succeed and return `null`.

        **NOTE** Headless mode doesn&#39;t support navigation to a PDF document. See the upstream issue.

        Parameters
        ----------
        url : str
            URL to navigate frame to. The url should include scheme, e.g. `https://`.
        timeout : Optional[int]
            Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        waitUntil : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
            When to consider navigation succeeded, defaults to `load`. Events can be either:
             - `&#39;domcontentloaded&#39;` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
             - `&#39;load&#39;` - consider navigation to be finished when the `load` event is fired.
             - `&#39;networkidle&#39;` - consider navigation to be finished when there are no network connections for at least `500` ms.
        referer : Optional[str]
            Referer header value. If provided it will take preference over the referer header value set by page.setExtraHTTPHeaders().

        Returns
        -------
        Optional[Response]
            Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._sync(
                self._impl_obj.goto(
                    url=url, timeout=timeout, waitUntil=waitUntil, referer=referer
                )
            )
        )

    def waitForNavigation(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
        waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        timeout: int = None,
    ) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
        &#34;&#34;&#34;Frame.waitForNavigation

        This resolves when the frame navigates to a new URL. It is useful for when you run code
        which will indirectly cause the frame to navigate. Consider this example:
        **NOTE** Usage of the History API to change the URL is considered a navigation.

        Parameters
        ----------
        url : Union[str, Pattern, typing.Callable[[str], bool], NoneType]
            URL string, URL regex pattern or predicate receiving URL to match while waiting for the navigation.
        waitUntil : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
            When to consider navigation succeeded, defaults to `load`. Events can be either:
             - `&#39;domcontentloaded&#39;` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
             - `&#39;load&#39;` - consider navigation to be finished when the `load` event is fired.
             - `&#39;networkidle&#39;` - consider navigation to be finished when there are no network connections for at least `500` ms.
        timeout : Optional[int]
            Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

        Returns
        -------
        Optional[Response]
            Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect. In case of navigation to a different anchor or navigation due to History API usage, the navigation will resolve with `null`.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._sync(
                self._impl_obj.waitForNavigation(
                    url=self._wrap_handler(url), waitUntil=waitUntil, timeout=timeout
                )
            )
        )

    def waitForLoadState(
        self,
        state: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        timeout: int = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.waitForLoadState

        This resolves when the frame reaches a required load state, `load` by default. The navigation must have been committed when this method is called. If current document has already reached the required state, resolves immediately.

        Parameters
        ----------
        state : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
            Load state to wait for, defaults to `load`. If the state has been already reached while loading current document, the method resolves immediately.
             - `&#39;load&#39;` - wait for the `load` event to be fired.
             - `&#39;domcontentloaded&#39;` - wait for the `DOMContentLoaded` event to be fired.
             - `&#39;networkidle&#39;` - wait until there are no network connections for at least `500` ms.
        timeout : Optional[int]
            Maximum waiting time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.waitForLoadState(state=state, timeout=timeout))
        )

    def frameElement(self) -&gt; &#34;ElementHandle&#34;:
        &#34;&#34;&#34;Frame.frameElement

        This is an inverse of elementHandle.contentFrame(). Note that returned handle actually belongs to the parent frame.
        This method throws an error if the frame has been detached before `frameElement()` returns.

        Returns
        -------
        ElementHandle
            Promise that resolves with a `frame` or `iframe` element handle which corresponds to this frame.
        &#34;&#34;&#34;
        return mapping.from_impl(self._sync(self._impl_obj.frameElement()))

    def evaluate(
        self, expression: str, arg: typing.Any = None, force_expr: bool = None
    ) -&gt; typing.Any:
        &#34;&#34;&#34;Frame.evaluate

        If the function passed to the `frame.evaluate` returns a Promise, then `frame.evaluate` would wait for the promise to resolve and return its value.
        If the function passed to the `frame.evaluate` returns a non-Serializable value, then `frame.evaluate` resolves to `undefined`. DevTools Protocol also supports transferring some additional values that are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and bigint literals.
        A string can also be passed in instead of a function.
        ElementHandle instances can be passed as an argument to the `frame.evaluate`:

        Parameters
        ----------
        expression : str
            Function to be evaluated in browser context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        Any
            Promise which resolves to the return value of `pageFunction`
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.evaluate(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )

    def evaluateHandle(
        self, expression: str, arg: typing.Any = None, force_expr: bool = None
    ) -&gt; &#34;JSHandle&#34;:
        &#34;&#34;&#34;Frame.evaluateHandle

        The only difference between `frame.evaluate` and `frame.evaluateHandle` is that `frame.evaluateHandle` returns in-page object (JSHandle).
        If the function, passed to the `frame.evaluateHandle`, returns a Promise, then `frame.evaluateHandle` would wait for the promise to resolve and return its value.
        A string can also be passed in instead of a function.
        JSHandle instances can be passed as an argument to the `frame.evaluateHandle`:

        Parameters
        ----------
        expression : str
            Function to be evaluated in the page context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        JSHandle
            Promise which resolves to the return value of `pageFunction` as in-page object (JSHandle)
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.evaluateHandle(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )

    def querySelector(self, selector: str) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
        &#34;&#34;&#34;Frame.querySelector

        The method finds an element matching the specified selector within the frame. See Working with selectors for more details. If no elements match the selector, the return value resolves to `null`.

        Parameters
        ----------
        selector : str
            A selector to query frame for. See working with selectors for more details.

        Returns
        -------
        Optional[ElementHandle]
            Promise which resolves to ElementHandle pointing to the frame element.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._sync(self._impl_obj.querySelector(selector=selector))
        )

    def querySelectorAll(self, selector: str) -&gt; typing.List[&#34;ElementHandle&#34;]:
        &#34;&#34;&#34;Frame.querySelectorAll

        The method finds all elements matching the specified selector within the frame. See Working with selectors for more details. If no elements match the selector, the return value resolves to `[]`.

        Parameters
        ----------
        selector : str
            A selector to query frame for. See working with selectors for more details.

        Returns
        -------
        List[ElementHandle]
            Promise which resolves to ElementHandles pointing to the frame elements.
        &#34;&#34;&#34;
        return mapping.from_impl_list(
            self._sync(self._impl_obj.querySelectorAll(selector=selector))
        )

    def waitForSelector(
        self,
        selector: str,
        timeout: int = None,
        state: Literal[&#34;attached&#34;, &#34;detached&#34;, &#34;hidden&#34;, &#34;visible&#34;] = None,
    ) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
        &#34;&#34;&#34;Frame.waitForSelector

        Wait for the `selector` to satisfy `state` option (either appear/disappear from dom, or become visible/hidden). If at the moment of calling the method `selector` already satisfies the condition, the method will return immediately. If the selector doesn&#39;t satisfy the condition for the `timeout` milliseconds, the function will throw.
        This method works across navigations:

        Parameters
        ----------
        selector : str
            A selector of an element to wait for. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        state : Optional[Literal[&#39;attached&#39;, &#39;detached&#39;, &#39;hidden&#39;, &#39;visible&#39;]]
            Defaults to `&#39;visible&#39;`. Can be either:
             - `&#39;attached&#39;` - wait for element to be present in DOM.
             - `&#39;detached&#39;` - wait for element to not be present in DOM.
             - `&#39;visible&#39;` - wait for element to have non-empty bounding box and no `visibility:hidden`. Note that element without any content or with `display:none` has an empty bounding box and is not considered visible.
             - `&#39;hidden&#39;` - wait for element to be either detached from DOM, or have an empty bounding box or `visibility:hidden`. This is opposite to the `&#39;visible&#39;` option.

        Returns
        -------
        Optional[ElementHandle]
            Promise which resolves when element specified by selector satisfies `state` option. Resolves to `null` if waiting for `hidden` or `detached`.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._sync(
                self._impl_obj.waitForSelector(
                    selector=selector, timeout=timeout, state=state
                )
            )
        )

    def dispatchEvent(
        self,
        selector: str,
        type: str,
        eventInit: typing.Dict = None,
        timeout: int = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.dispatchEvent

        The snippet below dispatches the `click` event on the element. Regardless of the visibility state of the elment, `click` is dispatched. This is equivalend to calling `element.click()`.
        Under the hood, it creates an instance of an event based on the given `type`, initializes it with `eventInit` properties and dispatches it on the element. Events are `composed`, `cancelable` and bubble by default.
        Since `eventInit` is event-specific, please refer to the events documentation for the lists of initial properties:

        DragEvent
        FocusEvent
        KeyboardEvent
        MouseEvent
        PointerEvent
        TouchEvent
        Event

        You can also specify `JSHandle` as the property value if you want live objects to be passed into the event:

        Parameters
        ----------
        selector : str
            A selector to search for element to use. If there are multiple elements satisfying the selector, the first will be double clicked. See working with selectors for more details.
        type : str
            DOM event type: `&#34;click&#34;`, `&#34;dragstart&#34;`, etc.
        eventInit : Optional[Dict]
            event-specific initialization properties.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.dispatchEvent(
                    selector=selector,
                    type=type,
                    eventInit=mapping.to_impl(eventInit),
                    timeout=timeout,
                )
            )
        )

    def evalOnSelector(
        self,
        selector: str,
        expression: str,
        arg: typing.Any = None,
        force_expr: bool = None,
    ) -&gt; typing.Any:
        &#34;&#34;&#34;Frame.evalOnSelector

        The method finds an element matching the specified selector within the frame and passes it as a first argument to `pageFunction`. See Working with selectors for more details. If no elements match the selector, the method throws an error.
        If `pageFunction` returns a Promise, then `frame.$eval` would wait for the promise to resolve and return its value.
        Examples:

        Parameters
        ----------
        selector : str
            A selector to query frame for. See working with selectors for more details.
        expression : str
            Function to be evaluated in browser context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        Any
            Promise which resolves to the return value of `pageFunction`
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.evalOnSelector(
                    selector=selector,
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )

    def evalOnSelectorAll(
        self,
        selector: str,
        expression: str,
        arg: typing.Any = None,
        force_expr: bool = None,
    ) -&gt; typing.Any:
        &#34;&#34;&#34;Frame.evalOnSelectorAll

        The method finds all elements matching the specified selector within the frame and passes an array of matched elements as a first argument to `pageFunction`. See Working with selectors for more details.
        If `pageFunction` returns a Promise, then `frame.$$eval` would wait for the promise to resolve and return its value.
        Examples:

        Parameters
        ----------
        selector : str
            A selector to query frame for. See working with selectors for more details.
        expression : str
            Function to be evaluated in browser context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        Any
            Promise which resolves to the return value of `pageFunction`
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.evalOnSelectorAll(
                    selector=selector,
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )

    def content(self) -&gt; str:
        &#34;&#34;&#34;Frame.content

        Gets the full HTML contents of the frame, including the doctype.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.content()))

    def setContent(
        self,
        html: str,
        timeout: int = None,
        waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.setContent

        Parameters
        ----------
        html : str
            HTML markup to assign to the page.
        timeout : Optional[int]
            Maximum time in milliseconds for resources to load, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        waitUntil : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
            When to consider navigation succeeded, defaults to `load`. Events can be either:
             - `&#39;domcontentloaded&#39;` - consider setting content to be finished when the `DOMContentLoaded` event is fired.
             - `&#39;load&#39;` - consider setting content to be finished when the `load` event is fired.
             - `&#39;networkidle&#39;` - consider setting content to be finished when there are no network connections for at least `500` ms.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.setContent(
                    html=html, timeout=timeout, waitUntil=waitUntil
                )
            )
        )

    def isDetached(self) -&gt; bool:
        &#34;&#34;&#34;Frame.isDetached

        Returns `true` if the frame has been detached, or `false` otherwise.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.isDetached())

    def addScriptTag(
        self,
        url: str = None,
        path: typing.Union[str, pathlib.Path] = None,
        content: str = None,
        type: str = None,
    ) -&gt; &#34;ElementHandle&#34;:
        &#34;&#34;&#34;Frame.addScriptTag

        Adds a `&lt;script&gt;` tag into the page with the desired url or content.

        Parameters
        ----------
        url : Optional[str]
            URL of a script to be added.
        path : Union[str, pathlib.Path, NoneType]
            Path to the JavaScript file to be injected into frame. If `path` is a relative path, then it is resolved relative to current working directory.
        content : Optional[str]
            Raw JavaScript content to be injected into frame.
        type : Optional[str]
            Script type. Use &#39;module&#39; in order to load a Javascript ES6 module. See script for more details.

        Returns
        -------
        ElementHandle
            which resolves to the added tag when the script&#39;s onload fires or when the script content was injected into frame.
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.addScriptTag(
                    url=url, path=path, content=content, type=type
                )
            )
        )

    def addStyleTag(
        self,
        url: str = None,
        path: typing.Union[str, pathlib.Path] = None,
        content: str = None,
    ) -&gt; &#34;ElementHandle&#34;:
        &#34;&#34;&#34;Frame.addStyleTag

        Adds a `&lt;link rel=&#34;stylesheet&#34;&gt;` tag into the page with the desired url or a `&lt;style type=&#34;text/css&#34;&gt;` tag with the content.

        Parameters
        ----------
        url : Optional[str]
            URL of the `&lt;link&gt;` tag.
        path : Union[str, pathlib.Path, NoneType]
            Path to the CSS file to be injected into frame. If `path` is a relative path, then it is resolved relative to current working directory.
        content : Optional[str]
            Raw CSS content to be injected into frame.

        Returns
        -------
        ElementHandle
            which resolves to the added tag when the stylesheet&#39;s onload fires or when the CSS content was injected into frame.
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(self._impl_obj.addStyleTag(url=url, path=path, content=content))
        )

    def click(
        self,
        selector: str,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: MousePosition = None,
        delay: int = None,
        button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
        clickCount: int = None,
        timeout: int = None,
        force: bool = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.click

        This method clicks an element matching `selector` by performing the following steps:

        Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
        Scroll the element into view if needed.
        Use page.mouse to click in the center of the element, or the specified `position`.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        Parameters
        ----------
        selector : str
            A selector to search for element to click. If there are multiple elements satisfying the selector, the first will be clicked. See working with selectors for more details.
        modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
            Modifier keys to press. Ensures that only these modifiers are pressed during the click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
        position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
            A point to click relative to the top-left corner of element padding box. If not specified, clicks to some visible point of the element.
        delay : Optional[int]
            Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
        button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
            Defaults to `left`.
        clickCount : Optional[int]
            defaults to 1. See UIEvent.detail.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.click(
                    selector=selector,
                    modifiers=modifiers,
                    position=position,
                    delay=delay,
                    button=button,
                    clickCount=clickCount,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def dblclick(
        self,
        selector: str,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: MousePosition = None,
        delay: int = None,
        button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
        timeout: int = None,
        force: bool = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.dblclick

        This method double clicks an element matching `selector` by performing the following steps:

        Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
        Scroll the element into view if needed.
        Use page.mouse to double click in the center of the element, or the specified `position`.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set. Note that if the first click of the `dblclick()` triggers a navigation event, this method will reject.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        **NOTE** `frame.dblclick()` dispatches two `click` events and a single `dblclick` event.

        Parameters
        ----------
        selector : str
            A selector to search for element to double click. If there are multiple elements satisfying the selector, the first will be double clicked. See working with selectors for more details.
        modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
            Modifier keys to press. Ensures that only these modifiers are pressed during the double click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
        position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
            A point to double click relative to the top-left corner of element padding box. If not specified, double clicks to some visible point of the element.
        delay : Optional[int]
            Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
        button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
            Defaults to `left`.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.dblclick(
                    selector=selector,
                    modifiers=modifiers,
                    position=position,
                    delay=delay,
                    button=button,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def tap(
        self,
        selector: str,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: MousePosition = None,
        timeout: int = None,
        force: bool = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.tap

        This method taps an element matching `selector` by performing the following steps:

        Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
        Scroll the element into view if needed.
        Use page.touchscreen to tap the center of the element, or the specified `position`.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        **NOTE** `frame.tap()` requires that the `hasTouch` option of the browser context be set to true.

        Parameters
        ----------
        selector : str
            A selector to search for element to tap. If there are multiple elements satisfying the selector, the first will be tapped. See working with selectors for more details.
        modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
            Modifier keys to press. Ensures that only these modifiers are pressed during the tap, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
        position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
            A point to tap relative to the top-left corner of element padding box. If not specified, taps some visible point of the element.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.tap(
                    selector=selector,
                    modifiers=modifiers,
                    position=position,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def fill(
        self, selector: str, value: str, timeout: int = None, noWaitAfter: bool = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.fill

        This method waits for an element matching `selector`, waits for actionability checks, focuses the element, fills it and triggers an `input` event after filling.
        If the element matching `selector` is not an `&lt;input&gt;`, `&lt;textarea&gt;` or `[contenteditable]` element, this method throws an error.
        Note that you can pass an empty string to clear the input field.
        To send fine-grained keyboard events, use `frame.type`.

        Parameters
        ----------
        selector : str
            A selector to query page for. See working with selectors for more details.
        value : str
            Value to fill for the `&lt;input&gt;`, `&lt;textarea&gt;` or `[contenteditable]` element.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.fill(
                    selector=selector,
                    value=value,
                    timeout=timeout,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def focus(self, selector: str, timeout: int = None) -&gt; NoneType:
        &#34;&#34;&#34;Frame.focus

        This method fetches an element with `selector` and focuses it.
        If there&#39;s no element matching `selector`, the method waits until a matching element appears in the DOM.

        Parameters
        ----------
        selector : str
            A selector of an element to focus. If there are multiple elements satisfying the selector, the first will be focused. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.focus(selector=selector, timeout=timeout))
        )

    def textContent(
        self, selector: str, timeout: int = None
    ) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;Frame.textContent

        Resolves to the `element.textContent`.

        Parameters
        ----------
        selector : str
            A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

        Returns
        -------
        Optional[str]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.textContent(selector=selector, timeout=timeout))
        )

    def innerText(self, selector: str, timeout: int = None) -&gt; str:
        &#34;&#34;&#34;Frame.innerText

        Resolves to the `element.innerText`.

        Parameters
        ----------
        selector : str
            A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.innerText(selector=selector, timeout=timeout))
        )

    def innerHTML(self, selector: str, timeout: int = None) -&gt; str:
        &#34;&#34;&#34;Frame.innerHTML

        Resolves to the `element.innerHTML`.

        Parameters
        ----------
        selector : str
            A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.innerHTML(selector=selector, timeout=timeout))
        )

    def getAttribute(
        self, selector: str, name: str, timeout: int = None
    ) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;Frame.getAttribute

        Returns element attribute value.

        Parameters
        ----------
        selector : str
            A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.
        name : str
            Attribute name to get the value for.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

        Returns
        -------
        Optional[str]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.getAttribute(
                    selector=selector, name=name, timeout=timeout
                )
            )
        )

    def hover(
        self,
        selector: str,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: MousePosition = None,
        timeout: int = None,
        force: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.hover

        This method hovers over an element matching `selector` by performing the following steps:

        Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
        Scroll the element into view if needed.
        Use page.mouse to hover over the center of the element, or the specified `position`.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        Parameters
        ----------
        selector : str
            A selector to search for element to hover. If there are multiple elements satisfying the selector, the first will be hovered. See working with selectors for more details.
        modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
            Modifier keys to press. Ensures that only these modifiers are pressed during the hover, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
        position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
            A point to hover relative to the top-left corner of element padding box. If not specified, hovers over some visible point of the element.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.hover(
                    selector=selector,
                    modifiers=modifiers,
                    position=position,
                    timeout=timeout,
                    force=force,
                )
            )
        )

    def selectOption(
        self,
        selector: str,
        values: typing.Union[
            str,
            &#34;ElementHandle&#34;,
            SelectOption,
            typing.List[str],
            typing.List[&#34;ElementHandle&#34;],
            typing.List[SelectOption],
        ] = None,
        timeout: int = None,
        noWaitAfter: bool = None,
    ) -&gt; typing.List[str]:
        &#34;&#34;&#34;Frame.selectOption

        Triggers a `change` and `input` event once all the provided options have been selected.
        If there&#39;s no `&lt;select&gt;` element matching `selector`, the method throws an error.

        Parameters
        ----------
        selector : str
            A selector to query frame for. See working with selectors for more details.
        values : Union[str, ElementHandle, {&#34;value&#34;: Optional[str], &#34;label&#34;: Optional[str], &#34;index&#34;: Optional[str]}, List[str], List[ElementHandle], List[{&#34;value&#34;: Optional[str], &#34;label&#34;: Optional[str], &#34;index&#34;: Optional[str]}], NoneType]
            Options to select. If the `&lt;select&gt;` has the `multiple` attribute, all matching options are selected, otherwise only the first option matching one of the passed options is selected. String values are equivalent to `{value:&#39;string&#39;}`. Option is considered matching if all specified properties match.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.

        Returns
        -------
        List[str]
            An array of option values that have been successfully selected.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.selectOption(
                    selector=selector,
                    values=mapping.to_impl(values),
                    timeout=timeout,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def setInputFiles(
        self,
        selector: str,
        files: typing.Union[
            str,
            pathlib.Path,
            FilePayload,
            typing.List[str],
            typing.List[pathlib.Path],
            typing.List[FilePayload],
        ],
        timeout: int = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.setInputFiles

        This method expects `selector` to point to an input element.
        Sets the value of the file input to these file paths or files. If some of the `filePaths` are relative paths, then they are resolved relative to the current working directory. For empty array, clears the selected files.

        Parameters
        ----------
        selector : str
            A selector to search for element to click. If there are multiple elements satisfying the selector, the first will be clicked. See working with selectors for more details.
        files : Union[str, pathlib.Path, {&#34;name&#34;: str, &#34;mimeType&#34;: str, &#34;buffer&#34;: bytes}, List[str], List[pathlib.Path], List[{&#34;name&#34;: str, &#34;mimeType&#34;: str, &#34;buffer&#34;: bytes}]]
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.setInputFiles(
                    selector=selector,
                    files=files,
                    timeout=timeout,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def type(
        self,
        selector: str,
        text: str,
        delay: int = None,
        timeout: int = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.type

        Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text. `frame.type` can be used to send fine-grained keyboard events. To fill values in form fields, use `frame.fill`.
        To press a special key, like `Control` or `ArrowDown`, use `keyboard.press`.

        Parameters
        ----------
        selector : str
            A selector of an element to type into. If there are multiple elements satisfying the selector, the first will be used. See working with selectors for more details.
        text : str
            A text to type into a focused element.
        delay : Optional[int]
            Time to wait between key presses in milliseconds. Defaults to 0.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.type(
                    selector=selector,
                    text=text,
                    delay=delay,
                    timeout=timeout,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def press(
        self,
        selector: str,
        key: str,
        delay: int = None,
        timeout: int = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.press

        `key` can specify the intended keyboardEvent.key value or a single character to generate the text for. A superset of the `key` values can be found here. Examples of the keys are:
        `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`, `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.
        Following modification shortcuts are also suported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`.
        Holding down `Shift` will type the text that corresponds to the `key` in the upper case.
        If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective texts.
        Shortcuts such as `key: &#34;Control+o&#34;` or `key: &#34;Control+Shift+T&#34;` are supported as well. When speficied with the modifier, modifier is pressed and being held while the subsequent key is being pressed.

        Parameters
        ----------
        selector : str
            A selector of an element to type into. If there are multiple elements satisfying the selector, the first will be used. See working with selectors for more details.
        key : str
            Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
        delay : Optional[int]
            Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.press(
                    selector=selector,
                    key=key,
                    delay=delay,
                    timeout=timeout,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def check(
        self,
        selector: str,
        timeout: int = None,
        force: bool = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.check

        This method checks an element matching `selector` by performing the following steps:

        Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already checked, this method returns immediately.
        Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
        Scroll the element into view if needed.
        Use page.mouse to click in the center of the element.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
        Ensure that the element is now checked. If not, this method rejects.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        Parameters
        ----------
        selector : str
            A selector to search for checkbox to check. If there are multiple elements satisfying the selector, the first will be checked. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.check(
                    selector=selector,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def uncheck(
        self,
        selector: str,
        timeout: int = None,
        force: bool = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.uncheck

        This method checks an element matching `selector` by performing the following steps:

        Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already unchecked, this method returns immediately.
        Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
        Scroll the element into view if needed.
        Use page.mouse to click in the center of the element.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
        Ensure that the element is now unchecked. If not, this method rejects.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        Parameters
        ----------
        selector : str
            A selector to search for uncheckbox to check. If there are multiple elements satisfying the selector, the first will be checked. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.uncheck(
                    selector=selector,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def waitForTimeout(self, timeout: int) -&gt; NoneType:
        &#34;&#34;&#34;Frame.waitForTimeout

        Returns a promise that resolves after the timeout.
        Note that `frame.waitForTimeout()` should only be used for debugging. Tests using the timer in production are going to be flaky. Use signals such as network events, selectors becoming visible and others instead.

        Parameters
        ----------
        timeout : int
            A timeout to wait for
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.waitForTimeout(timeout=timeout))
        )

    def waitForFunction(
        self,
        expression: str,
        arg: typing.Any = None,
        force_expr: bool = None,
        timeout: int = None,
        polling: typing.Union[int, Literal[&#34;raf&#34;]] = None,
    ) -&gt; &#34;JSHandle&#34;:
        &#34;&#34;&#34;Frame.waitForFunction

        The `waitForFunction` can be used to observe viewport size change:

        To pass an argument from Node.js to the predicate of `frame.waitForFunction` function:

        Parameters
        ----------
        expression : str
            Function to be evaluated in browser context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`
        timeout : Optional[int]
            maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        polling : Union[int, &#39;raf&#39;, NoneType]
            If `polling` is `&#39;raf&#39;`, then `pageFunction` is constantly executed in `requestAnimationFrame` callback. If `polling` is a number, then it is treated as an interval in milliseconds at which the function would be executed. Defaults to `raf`.

        Returns
        -------
        JSHandle
            Promise which resolves when the `pageFunction` returns a truthy value. It resolves to a JSHandle of the truthy value.
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.waitForFunction(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                    timeout=timeout,
                    polling=polling,
                )
            )
        )

    def title(self) -&gt; str:
        &#34;&#34;&#34;Frame.title

        Returns
        -------
        str
            The page&#39;s title.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.title()))

    def expect_load_state(
        self,
        state: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        timeout: int = None,
    ) -&gt; EventContextManager[typing.Union[&#34;Response&#34;, NoneType]]:
        return EventContextManager(
            self._loop, self._impl_obj.waitForLoadState(state, timeout)
        )

    def expect_navigation(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
        waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        timeout: int = None,
    ) -&gt; EventContextManager[typing.Union[&#34;Response&#34;, NoneType]]:
        return EventContextManager(
            self._loop, self._impl_obj.waitForNavigation(url, waitUntil, timeout)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright.sync_base.SyncBase</li>
<li>playwright.impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.sync_api.Frame.childFrames"><code class="name">var <span class="ident">childFrames</span> : List[<a title="playwright.async_api.Frame" href="async_api.html#playwright.async_api.Frame">Frame</a>]</code></dt>
<dd>
<div class="desc"><p>Frame.childFrames</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="playwright.sync_api.Frame" href="#playwright.sync_api.Frame">Frame</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def childFrames(self) -&gt; typing.List[&#34;Frame&#34;]:
    &#34;&#34;&#34;Frame.childFrames

    Returns
    -------
    List[Frame]
    &#34;&#34;&#34;
    return mapping.from_impl_list(self._impl_obj.childFrames)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>Frame.name</p>
<p>Returns frame's name attribute as specified in the tag.
If the name is empty, returns the id attribute instead.</p>
<p><strong>NOTE</strong> This value is calculated once when the frame is created, and will not update if the attribute is changed later.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;Frame.name

    Returns frame&#39;s name attribute as specified in the tag.
    If the name is empty, returns the id attribute instead.

    **NOTE** This value is calculated once when the frame is created, and will not update if the attribute is changed later.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.name)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.page"><code class="name">var <span class="ident">page</span> : <a title="playwright.sync_api.Page" href="#playwright.sync_api.Page">Page</a></code></dt>
<dd>
<div class="desc"><p>Frame.page</p>
<p>Returns the page containing this frame.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.Page" href="#playwright.sync_api.Page">Page</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def page(self) -&gt; &#34;Page&#34;:
    &#34;&#34;&#34;Frame.page

    Returns the page containing this frame.

    Returns
    -------
    Page
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.page)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.parentFrame"><code class="name">var <span class="ident">parentFrame</span> : Union[<a title="playwright.async_api.Frame" href="async_api.html#playwright.async_api.Frame">Frame</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Frame.parentFrame</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[<a title="playwright.sync_api.Frame" href="#playwright.sync_api.Frame">Frame</a>]</code></dt>
<dd>Parent frame, if any. Detached frames and main frames return <code>null</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parentFrame(self) -&gt; typing.Union[&#34;Frame&#34;, NoneType]:
    &#34;&#34;&#34;Frame.parentFrame

    Returns
    -------
    Optional[Frame]
        Parent frame, if any. Detached frames and main frames return `null`.
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(self._impl_obj.parentFrame)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.url"><code class="name">var <span class="ident">url</span> : str</code></dt>
<dd>
<div class="desc"><p>Frame.url</p>
<p>Returns frame's url.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def url(self) -&gt; str:
    &#34;&#34;&#34;Frame.url

    Returns frame&#39;s url.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.url)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.sync_api.Frame.addScriptTag"><code class="name flex">
<span>def <span class="ident">addScriptTag</span></span>(<span>self, url: str = None, path: Union[str, pathlib.Path] = None, content: str = None, type: str = None) ‑> <a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a></span>
</code></dt>
<dd>
<div class="desc"><p>Frame.addScriptTag</p>
<p>Adds a <code>&lt;script&gt;</code> tag into the page with the desired url or content.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>URL of a script to be added.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[str, pathlib.Path, NoneType]</code></dt>
<dd>Path to the JavaScript file to be injected into frame. If <code>path</code> is a relative path, then it is resolved relative to current working directory.</dd>
<dt><strong><code>content</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Raw JavaScript content to be injected into frame.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Script type. Use 'module' in order to load a Javascript ES6 module. See script for more details.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a></code></dt>
<dd>which resolves to the added tag when the script's onload fires or when the script content was injected into frame.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addScriptTag(
    self,
    url: str = None,
    path: typing.Union[str, pathlib.Path] = None,
    content: str = None,
    type: str = None,
) -&gt; &#34;ElementHandle&#34;:
    &#34;&#34;&#34;Frame.addScriptTag

    Adds a `&lt;script&gt;` tag into the page with the desired url or content.

    Parameters
    ----------
    url : Optional[str]
        URL of a script to be added.
    path : Union[str, pathlib.Path, NoneType]
        Path to the JavaScript file to be injected into frame. If `path` is a relative path, then it is resolved relative to current working directory.
    content : Optional[str]
        Raw JavaScript content to be injected into frame.
    type : Optional[str]
        Script type. Use &#39;module&#39; in order to load a Javascript ES6 module. See script for more details.

    Returns
    -------
    ElementHandle
        which resolves to the added tag when the script&#39;s onload fires or when the script content was injected into frame.
    &#34;&#34;&#34;
    return mapping.from_impl(
        self._sync(
            self._impl_obj.addScriptTag(
                url=url, path=path, content=content, type=type
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.addStyleTag"><code class="name flex">
<span>def <span class="ident">addStyleTag</span></span>(<span>self, url: str = None, path: Union[str, pathlib.Path] = None, content: str = None) ‑> <a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a></span>
</code></dt>
<dd>
<div class="desc"><p>Frame.addStyleTag</p>
<p>Adds a <code>&lt;link rel="stylesheet"&gt;</code> tag into the page with the desired url or a <code>&lt;style type="text/css"&gt;</code> tag with the content.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>URL of the <code>&lt;link&gt;</code> tag.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[str, pathlib.Path, NoneType]</code></dt>
<dd>Path to the CSS file to be injected into frame. If <code>path</code> is a relative path, then it is resolved relative to current working directory.</dd>
<dt><strong><code>content</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Raw CSS content to be injected into frame.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a></code></dt>
<dd>which resolves to the added tag when the stylesheet's onload fires or when the CSS content was injected into frame.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addStyleTag(
    self,
    url: str = None,
    path: typing.Union[str, pathlib.Path] = None,
    content: str = None,
) -&gt; &#34;ElementHandle&#34;:
    &#34;&#34;&#34;Frame.addStyleTag

    Adds a `&lt;link rel=&#34;stylesheet&#34;&gt;` tag into the page with the desired url or a `&lt;style type=&#34;text/css&#34;&gt;` tag with the content.

    Parameters
    ----------
    url : Optional[str]
        URL of the `&lt;link&gt;` tag.
    path : Union[str, pathlib.Path, NoneType]
        Path to the CSS file to be injected into frame. If `path` is a relative path, then it is resolved relative to current working directory.
    content : Optional[str]
        Raw CSS content to be injected into frame.

    Returns
    -------
    ElementHandle
        which resolves to the added tag when the stylesheet&#39;s onload fires or when the CSS content was injected into frame.
    &#34;&#34;&#34;
    return mapping.from_impl(
        self._sync(self._impl_obj.addStyleTag(url=url, path=path, content=content))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.check"><code class="name flex">
<span>def <span class="ident">check</span></span>(<span>self, selector: str, timeout: int = None, force: bool = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.check</p>
<p>This method checks an element matching <code>selector</code> by performing the following steps:</p>
<p>Find an element match matching <code>selector</code>. If there is none, wait until a matching element is attached to the DOM.
Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already checked, this method returns immediately.
Wait for actionability checks on the matched element, unless <code>force</code> option is set. If the element is detached during the checks, the whole action is retried.
Scroll the element into view if needed.
Use page.mouse to click in the center of the element.
Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.
Ensure that the element is now checked. If not, this method rejects.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a TimeoutError. Passing zero timeout disables this.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for checkbox to check. If there are multiple elements satisfying the selector, the first will be checked. See working with selectors for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to bypass the actionability checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check(
    self,
    selector: str,
    timeout: int = None,
    force: bool = None,
    noWaitAfter: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Frame.check

    This method checks an element matching `selector` by performing the following steps:

    Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
    Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already checked, this method returns immediately.
    Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
    Scroll the element into view if needed.
    Use page.mouse to click in the center of the element.
    Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
    Ensure that the element is now checked. If not, this method rejects.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

    Parameters
    ----------
    selector : str
        A selector to search for checkbox to check. If there are multiple elements satisfying the selector, the first will be checked. See working with selectors for more details.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    force : Optional[bool]
        Whether to bypass the actionability checks. Defaults to `false`.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.check(
                selector=selector,
                timeout=timeout,
                force=force,
                noWaitAfter=noWaitAfter,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.click"><code class="name flex">
<span>def <span class="ident">click</span></span>(<span>self, selector: str, modifiers: List[Literal['Alt', 'Control', 'Meta', 'Shift']] = None, position: playwright.helper.MousePosition = None, delay: int = None, button: Literal['left', 'middle', 'right'] = None, clickCount: int = None, timeout: int = None, force: bool = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.click</p>
<p>This method clicks an element matching <code>selector</code> by performing the following steps:</p>
<p>Find an element match matching <code>selector</code>. If there is none, wait until a matching element is attached to the DOM.
Wait for actionability checks on the matched element, unless <code>force</code> option is set. If the element is detached during the checks, the whole action is retried.
Scroll the element into view if needed.
Use page.mouse to click in the center of the element, or the specified <code>position</code>.
Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a TimeoutError. Passing zero timeout disables this.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element to click. If there are multiple elements satisfying the selector, the first will be clicked. See working with selectors for more details.</dd>
<dt><strong><code>modifiers</code></strong> :&ensp;<code>Optional[List[Literal['Alt', 'Control', 'Meta', 'Shift']]]</code></dt>
<dd>Modifier keys to press. Ensures that only these modifiers are pressed during the click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>Optional[{"x": float, "y": float}]</code></dt>
<dd>A point to click relative to the top-left corner of element padding box. If not specified, clicks to some visible point of the element.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Time to wait between <code>mousedown</code> and <code>mouseup</code> in milliseconds. Defaults to 0.</dd>
<dt><strong><code>button</code></strong> :&ensp;<code>Optional[Literal['left', 'middle', 'right']]</code></dt>
<dd>Defaults to <code>left</code>.</dd>
<dt><strong><code>clickCount</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>defaults to 1. See UIEvent.detail.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to bypass the actionability checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def click(
    self,
    selector: str,
    modifiers: typing.Union[
        typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
    ] = None,
    position: MousePosition = None,
    delay: int = None,
    button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
    clickCount: int = None,
    timeout: int = None,
    force: bool = None,
    noWaitAfter: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Frame.click

    This method clicks an element matching `selector` by performing the following steps:

    Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
    Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
    Scroll the element into view if needed.
    Use page.mouse to click in the center of the element, or the specified `position`.
    Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

    Parameters
    ----------
    selector : str
        A selector to search for element to click. If there are multiple elements satisfying the selector, the first will be clicked. See working with selectors for more details.
    modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
        Modifier keys to press. Ensures that only these modifiers are pressed during the click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
    position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
        A point to click relative to the top-left corner of element padding box. If not specified, clicks to some visible point of the element.
    delay : Optional[int]
        Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
    button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
        Defaults to `left`.
    clickCount : Optional[int]
        defaults to 1. See UIEvent.detail.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    force : Optional[bool]
        Whether to bypass the actionability checks. Defaults to `false`.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.click(
                selector=selector,
                modifiers=modifiers,
                position=position,
                delay=delay,
                button=button,
                clickCount=clickCount,
                timeout=timeout,
                force=force,
                noWaitAfter=noWaitAfter,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.content"><code class="name flex">
<span>def <span class="ident">content</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.content</p>
<p>Gets the full HTML contents of the frame, including the doctype.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def content(self) -&gt; str:
    &#34;&#34;&#34;Frame.content

    Gets the full HTML contents of the frame, including the doctype.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.content()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.dblclick"><code class="name flex">
<span>def <span class="ident">dblclick</span></span>(<span>self, selector: str, modifiers: List[Literal['Alt', 'Control', 'Meta', 'Shift']] = None, position: playwright.helper.MousePosition = None, delay: int = None, button: Literal['left', 'middle', 'right'] = None, timeout: int = None, force: bool = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.dblclick</p>
<p>This method double clicks an element matching <code>selector</code> by performing the following steps:</p>
<p>Find an element match matching <code>selector</code>. If there is none, wait until a matching element is attached to the DOM.
Wait for actionability checks on the matched element, unless <code>force</code> option is set. If the element is detached during the checks, the whole action is retried.
Scroll the element into view if needed.
Use page.mouse to double click in the center of the element, or the specified <code>position</code>.
Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set. Note that if the first click of the <code>dblclick()</code> triggers a navigation event, this method will reject.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a TimeoutError. Passing zero timeout disables this.</p>
<p><strong>NOTE</strong> <code>frame.dblclick()</code> dispatches two <code>click</code> events and a single <code>dblclick</code> event.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element to double click. If there are multiple elements satisfying the selector, the first will be double clicked. See working with selectors for more details.</dd>
<dt><strong><code>modifiers</code></strong> :&ensp;<code>Optional[List[Literal['Alt', 'Control', 'Meta', 'Shift']]]</code></dt>
<dd>Modifier keys to press. Ensures that only these modifiers are pressed during the double click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>Optional[{"x": float, "y": float}]</code></dt>
<dd>A point to double click relative to the top-left corner of element padding box. If not specified, double clicks to some visible point of the element.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Time to wait between <code>mousedown</code> and <code>mouseup</code> in milliseconds. Defaults to 0.</dd>
<dt><strong><code>button</code></strong> :&ensp;<code>Optional[Literal['left', 'middle', 'right']]</code></dt>
<dd>Defaults to <code>left</code>.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to bypass the actionability checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dblclick(
    self,
    selector: str,
    modifiers: typing.Union[
        typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
    ] = None,
    position: MousePosition = None,
    delay: int = None,
    button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
    timeout: int = None,
    force: bool = None,
    noWaitAfter: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Frame.dblclick

    This method double clicks an element matching `selector` by performing the following steps:

    Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
    Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
    Scroll the element into view if needed.
    Use page.mouse to double click in the center of the element, or the specified `position`.
    Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set. Note that if the first click of the `dblclick()` triggers a navigation event, this method will reject.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

    **NOTE** `frame.dblclick()` dispatches two `click` events and a single `dblclick` event.

    Parameters
    ----------
    selector : str
        A selector to search for element to double click. If there are multiple elements satisfying the selector, the first will be double clicked. See working with selectors for more details.
    modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
        Modifier keys to press. Ensures that only these modifiers are pressed during the double click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
    position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
        A point to double click relative to the top-left corner of element padding box. If not specified, double clicks to some visible point of the element.
    delay : Optional[int]
        Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
    button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
        Defaults to `left`.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    force : Optional[bool]
        Whether to bypass the actionability checks. Defaults to `false`.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.dblclick(
                selector=selector,
                modifiers=modifiers,
                position=position,
                delay=delay,
                button=button,
                timeout=timeout,
                force=force,
                noWaitAfter=noWaitAfter,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.dispatchEvent"><code class="name flex">
<span>def <span class="ident">dispatchEvent</span></span>(<span>self, selector: str, type: str, eventInit: Dict = None, timeout: int = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.dispatchEvent</p>
<p>The snippet below dispatches the <code>click</code> event on the element. Regardless of the visibility state of the elment, <code>click</code> is dispatched. This is equivalend to calling <code>element.click()</code>.
Under the hood, it creates an instance of an event based on the given <code>type</code>, initializes it with <code>eventInit</code> properties and dispatches it on the element. Events are <code>composed</code>, <code>cancelable</code> and bubble by default.
Since <code>eventInit</code> is event-specific, please refer to the events documentation for the lists of initial properties:</p>
<p>DragEvent
FocusEvent
KeyboardEvent
MouseEvent
PointerEvent
TouchEvent
Event</p>
<p>You can also specify <code><a title="playwright.sync_api.JSHandle" href="#playwright.sync_api.JSHandle">JSHandle</a></code> as the property value if you want live objects to be passed into the event:</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element to use. If there are multiple elements satisfying the selector, the first will be double clicked. See working with selectors for more details.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code></dt>
<dd>DOM event type: <code>"click"</code>, <code>"dragstart"</code>, etc.</dd>
<dt><strong><code>eventInit</code></strong> :&ensp;<code>Optional[Dict]</code></dt>
<dd>event-specific initialization properties.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dispatchEvent(
    self,
    selector: str,
    type: str,
    eventInit: typing.Dict = None,
    timeout: int = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Frame.dispatchEvent

    The snippet below dispatches the `click` event on the element. Regardless of the visibility state of the elment, `click` is dispatched. This is equivalend to calling `element.click()`.
    Under the hood, it creates an instance of an event based on the given `type`, initializes it with `eventInit` properties and dispatches it on the element. Events are `composed`, `cancelable` and bubble by default.
    Since `eventInit` is event-specific, please refer to the events documentation for the lists of initial properties:

    DragEvent
    FocusEvent
    KeyboardEvent
    MouseEvent
    PointerEvent
    TouchEvent
    Event

    You can also specify `JSHandle` as the property value if you want live objects to be passed into the event:

    Parameters
    ----------
    selector : str
        A selector to search for element to use. If there are multiple elements satisfying the selector, the first will be double clicked. See working with selectors for more details.
    type : str
        DOM event type: `&#34;click&#34;`, `&#34;dragstart&#34;`, etc.
    eventInit : Optional[Dict]
        event-specific initialization properties.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.dispatchEvent(
                selector=selector,
                type=type,
                eventInit=mapping.to_impl(eventInit),
                timeout=timeout,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.evalOnSelector"><code class="name flex">
<span>def <span class="ident">evalOnSelector</span></span>(<span>self, selector: str, expression: str, arg: Any = None, force_expr: bool = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.evalOnSelector</p>
<p>The method finds an element matching the specified selector within the frame and passes it as a first argument to <code>pageFunction</code>. See Working with selectors for more details. If no elements match the selector, the method throws an error.
If <code>pageFunction</code> returns a Promise, then <code>frame.$eval</code> would wait for the promise to resolve and return its value.
Examples:</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query frame for. See working with selectors for more details.</dd>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>Function to be evaluated in browser context</dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Optional[Any]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>Promise which resolves to the return value of <code>pageFunction</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evalOnSelector(
    self,
    selector: str,
    expression: str,
    arg: typing.Any = None,
    force_expr: bool = None,
) -&gt; typing.Any:
    &#34;&#34;&#34;Frame.evalOnSelector

    The method finds an element matching the specified selector within the frame and passes it as a first argument to `pageFunction`. See Working with selectors for more details. If no elements match the selector, the method throws an error.
    If `pageFunction` returns a Promise, then `frame.$eval` would wait for the promise to resolve and return its value.
    Examples:

    Parameters
    ----------
    selector : str
        A selector to query frame for. See working with selectors for more details.
    expression : str
        Function to be evaluated in browser context
    force_expr : bool
        Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
    arg : Optional[Any]
        Optional argument to pass to `pageFunction`

    Returns
    -------
    Any
        Promise which resolves to the return value of `pageFunction`
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.evalOnSelector(
                selector=selector,
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.evalOnSelectorAll"><code class="name flex">
<span>def <span class="ident">evalOnSelectorAll</span></span>(<span>self, selector: str, expression: str, arg: Any = None, force_expr: bool = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.evalOnSelectorAll</p>
<p>The method finds all elements matching the specified selector within the frame and passes an array of matched elements as a first argument to <code>pageFunction</code>. See Working with selectors for more details.
If <code>pageFunction</code> returns a Promise, then <code>frame.$$eval</code> would wait for the promise to resolve and return its value.
Examples:</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query frame for. See working with selectors for more details.</dd>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>Function to be evaluated in browser context</dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Optional[Any]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>Promise which resolves to the return value of <code>pageFunction</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evalOnSelectorAll(
    self,
    selector: str,
    expression: str,
    arg: typing.Any = None,
    force_expr: bool = None,
) -&gt; typing.Any:
    &#34;&#34;&#34;Frame.evalOnSelectorAll

    The method finds all elements matching the specified selector within the frame and passes an array of matched elements as a first argument to `pageFunction`. See Working with selectors for more details.
    If `pageFunction` returns a Promise, then `frame.$$eval` would wait for the promise to resolve and return its value.
    Examples:

    Parameters
    ----------
    selector : str
        A selector to query frame for. See working with selectors for more details.
    expression : str
        Function to be evaluated in browser context
    force_expr : bool
        Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
    arg : Optional[Any]
        Optional argument to pass to `pageFunction`

    Returns
    -------
    Any
        Promise which resolves to the return value of `pageFunction`
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.evalOnSelectorAll(
                selector=selector,
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, expression: str, arg: Any = None, force_expr: bool = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.evaluate</p>
<p>If the function passed to the <code>frame.evaluate</code> returns a Promise, then <code>frame.evaluate</code> would wait for the promise to resolve and return its value.
If the function passed to the <code>frame.evaluate</code> returns a non-Serializable value, then <code>frame.evaluate</code> resolves to <code>undefined</code>. DevTools Protocol also supports transferring some additional values that are not serializable by <code>JSON</code>: <code>-0</code>, <code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code>, and bigint literals.
A string can also be passed in instead of a function.
ElementHandle instances can be passed as an argument to the <code>frame.evaluate</code>:</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>Function to be evaluated in browser context</dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Optional[Any]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>Promise which resolves to the return value of <code>pageFunction</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(
    self, expression: str, arg: typing.Any = None, force_expr: bool = None
) -&gt; typing.Any:
    &#34;&#34;&#34;Frame.evaluate

    If the function passed to the `frame.evaluate` returns a Promise, then `frame.evaluate` would wait for the promise to resolve and return its value.
    If the function passed to the `frame.evaluate` returns a non-Serializable value, then `frame.evaluate` resolves to `undefined`. DevTools Protocol also supports transferring some additional values that are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and bigint literals.
    A string can also be passed in instead of a function.
    ElementHandle instances can be passed as an argument to the `frame.evaluate`:

    Parameters
    ----------
    expression : str
        Function to be evaluated in browser context
    force_expr : bool
        Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
    arg : Optional[Any]
        Optional argument to pass to `pageFunction`

    Returns
    -------
    Any
        Promise which resolves to the return value of `pageFunction`
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.evaluate(
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.evaluateHandle"><code class="name flex">
<span>def <span class="ident">evaluateHandle</span></span>(<span>self, expression: str, arg: Any = None, force_expr: bool = None) ‑> <a title="playwright.sync_api.JSHandle" href="#playwright.sync_api.JSHandle">JSHandle</a></span>
</code></dt>
<dd>
<div class="desc"><p>Frame.evaluateHandle</p>
<p>The only difference between <code>frame.evaluate</code> and <code>frame.evaluateHandle</code> is that <code>frame.evaluateHandle</code> returns in-page object (JSHandle).
If the function, passed to the <code>frame.evaluateHandle</code>, returns a Promise, then <code>frame.evaluateHandle</code> would wait for the promise to resolve and return its value.
A string can also be passed in instead of a function.
JSHandle instances can be passed as an argument to the <code>frame.evaluateHandle</code>:</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>Function to be evaluated in the page context</dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Optional[Any]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.JSHandle" href="#playwright.sync_api.JSHandle">JSHandle</a></code></dt>
<dd>Promise which resolves to the return value of <code>pageFunction</code> as in-page object (JSHandle)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluateHandle(
    self, expression: str, arg: typing.Any = None, force_expr: bool = None
) -&gt; &#34;JSHandle&#34;:
    &#34;&#34;&#34;Frame.evaluateHandle

    The only difference between `frame.evaluate` and `frame.evaluateHandle` is that `frame.evaluateHandle` returns in-page object (JSHandle).
    If the function, passed to the `frame.evaluateHandle`, returns a Promise, then `frame.evaluateHandle` would wait for the promise to resolve and return its value.
    A string can also be passed in instead of a function.
    JSHandle instances can be passed as an argument to the `frame.evaluateHandle`:

    Parameters
    ----------
    expression : str
        Function to be evaluated in the page context
    force_expr : bool
        Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
    arg : Optional[Any]
        Optional argument to pass to `pageFunction`

    Returns
    -------
    JSHandle
        Promise which resolves to the return value of `pageFunction` as in-page object (JSHandle)
    &#34;&#34;&#34;
    return mapping.from_impl(
        self._sync(
            self._impl_obj.evaluateHandle(
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.expect_load_state"><code class="name flex">
<span>def <span class="ident">expect_load_state</span></span>(<span>self, state: Literal['domcontentloaded', 'load', 'networkidle'] = None, timeout: int = None) ‑> playwright.sync_base.EventContextManager[typing.Union[<a title="playwright.async_api.Response" href="async_api.html#playwright.async_api.Response">Response</a>, NoneType]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_load_state(
    self,
    state: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    timeout: int = None,
) -&gt; EventContextManager[typing.Union[&#34;Response&#34;, NoneType]]:
    return EventContextManager(
        self._loop, self._impl_obj.waitForLoadState(state, timeout)
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.expect_navigation"><code class="name flex">
<span>def <span class="ident">expect_navigation</span></span>(<span>self, url: Union[str, Pattern, Callable[[str], bool]] = None, waitUntil: Literal['domcontentloaded', 'load', 'networkidle'] = None, timeout: int = None) ‑> playwright.sync_base.EventContextManager[typing.Union[<a title="playwright.async_api.Response" href="async_api.html#playwright.async_api.Response">Response</a>, NoneType]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_navigation(
    self,
    url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
    waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    timeout: int = None,
) -&gt; EventContextManager[typing.Union[&#34;Response&#34;, NoneType]]:
    return EventContextManager(
        self._loop, self._impl_obj.waitForNavigation(url, waitUntil, timeout)
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.fill"><code class="name flex">
<span>def <span class="ident">fill</span></span>(<span>self, selector: str, value: str, timeout: int = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.fill</p>
<p>This method waits for an element matching <code>selector</code>, waits for actionability checks, focuses the element, fills it and triggers an <code>input</code> event after filling.
If the element matching <code>selector</code> is not an <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> or <code>[contenteditable]</code> element, this method throws an error.
Note that you can pass an empty string to clear the input field.
To send fine-grained keyboard events, use <code>frame.type</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query page for. See working with selectors for more details.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>Value to fill for the <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> or <code>[contenteditable]</code> element.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fill(
    self, selector: str, value: str, timeout: int = None, noWaitAfter: bool = None
) -&gt; NoneType:
    &#34;&#34;&#34;Frame.fill

    This method waits for an element matching `selector`, waits for actionability checks, focuses the element, fills it and triggers an `input` event after filling.
    If the element matching `selector` is not an `&lt;input&gt;`, `&lt;textarea&gt;` or `[contenteditable]` element, this method throws an error.
    Note that you can pass an empty string to clear the input field.
    To send fine-grained keyboard events, use `frame.type`.

    Parameters
    ----------
    selector : str
        A selector to query page for. See working with selectors for more details.
    value : str
        Value to fill for the `&lt;input&gt;`, `&lt;textarea&gt;` or `[contenteditable]` element.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.fill(
                selector=selector,
                value=value,
                timeout=timeout,
                noWaitAfter=noWaitAfter,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.focus"><code class="name flex">
<span>def <span class="ident">focus</span></span>(<span>self, selector: str, timeout: int = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.focus</p>
<p>This method fetches an element with <code>selector</code> and focuses it.
If there's no element matching <code>selector</code>, the method waits until a matching element appears in the DOM.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector of an element to focus. If there are multiple elements satisfying the selector, the first will be focused. See working with selectors for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def focus(self, selector: str, timeout: int = None) -&gt; NoneType:
    &#34;&#34;&#34;Frame.focus

    This method fetches an element with `selector` and focuses it.
    If there&#39;s no element matching `selector`, the method waits until a matching element appears in the DOM.

    Parameters
    ----------
    selector : str
        A selector of an element to focus. If there are multiple elements satisfying the selector, the first will be focused. See working with selectors for more details.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.focus(selector=selector, timeout=timeout))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.frameElement"><code class="name flex">
<span>def <span class="ident">frameElement</span></span>(<span>self) ‑> <a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a></span>
</code></dt>
<dd>
<div class="desc"><p>Frame.frameElement</p>
<p>This is an inverse of elementHandle.contentFrame(). Note that returned handle actually belongs to the parent frame.
This method throws an error if the frame has been detached before <code>frameElement()</code> returns.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a></code></dt>
<dd>Promise that resolves with a <code>frame</code> or <code>iframe</code> element handle which corresponds to this frame.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def frameElement(self) -&gt; &#34;ElementHandle&#34;:
    &#34;&#34;&#34;Frame.frameElement

    This is an inverse of elementHandle.contentFrame(). Note that returned handle actually belongs to the parent frame.
    This method throws an error if the frame has been detached before `frameElement()` returns.

    Returns
    -------
    ElementHandle
        Promise that resolves with a `frame` or `iframe` element handle which corresponds to this frame.
    &#34;&#34;&#34;
    return mapping.from_impl(self._sync(self._impl_obj.frameElement()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.getAttribute"><code class="name flex">
<span>def <span class="ident">getAttribute</span></span>(<span>self, selector: str, name: str, timeout: int = None) ‑> Union[str, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.getAttribute</p>
<p>Returns element attribute value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Attribute name to get the value for.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[str]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAttribute(
    self, selector: str, name: str, timeout: int = None
) -&gt; typing.Union[str, NoneType]:
    &#34;&#34;&#34;Frame.getAttribute

    Returns element attribute value.

    Parameters
    ----------
    selector : str
        A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.
    name : str
        Attribute name to get the value for.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

    Returns
    -------
    Optional[str]
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.getAttribute(
                selector=selector, name=name, timeout=timeout
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.goto"><code class="name flex">
<span>def <span class="ident">goto</span></span>(<span>self, url: str, timeout: int = None, waitUntil: Literal['domcontentloaded', 'load', 'networkidle'] = None, referer: str = None) ‑> Union[<a title="playwright.async_api.Response" href="async_api.html#playwright.async_api.Response">Response</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.goto</p>
<p><code>frame.goto</code> will throw an error if:</p>
<p>there's an SSL error (e.g. in case of self-signed certificates).
target URL is invalid.
the <code>timeout</code> is exceeded during navigation.
the remote server does not respond or is unreachable.
the main resource failed to load.</p>
<p><code>frame.goto</code> will not throw an error when any valid HTTP status code is returned by the remote server, including 404 "Not Found" and 500 "Internal Server Error".
The status code for such responses can be retrieved by calling response.status().</p>
<p><strong>NOTE</strong> <code>frame.goto</code> either throws an error or returns a main resource response. The only exceptions are navigation to <code>about:blank</code> or navigation to the same URL with a different hash, which would succeed and return <code>null</code>.</p>
<p><strong>NOTE</strong> Headless mode doesn't support navigation to a PDF document. See the upstream issue.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>URL to navigate frame to. The url should include scheme, e.g. <code>https://</code>.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum navigation time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>waitUntil</code></strong> :&ensp;<code>Optional[Literal['domcontentloaded', 'load', 'networkidle']]</code></dt>
<dd>When to consider navigation succeeded, defaults to <code>load</code>. Events can be either:
- <code>'domcontentloaded'</code> - consider navigation to be finished when the <code>DOMContentLoaded</code> event is fired.
- <code>'load'</code> - consider navigation to be finished when the <code>load</code> event is fired.
- <code>'networkidle'</code> - consider navigation to be finished when there are no network connections for at least <code>500</code> ms.</dd>
<dt><strong><code>referer</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Referer header value. If provided it will take preference over the referer header value set by page.setExtraHTTPHeaders().</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[<a title="playwright.sync_api.Response" href="#playwright.sync_api.Response">Response</a>]</code></dt>
<dd>Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def goto(
    self,
    url: str,
    timeout: int = None,
    waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    referer: str = None,
) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
    &#34;&#34;&#34;Frame.goto

    `frame.goto` will throw an error if:

    there&#39;s an SSL error (e.g. in case of self-signed certificates).
    target URL is invalid.
    the `timeout` is exceeded during navigation.
    the remote server does not respond or is unreachable.
    the main resource failed to load.

    `frame.goto` will not throw an error when any valid HTTP status code is returned by the remote server, including 404 &#34;Not Found&#34; and 500 &#34;Internal Server Error&#34;.  The status code for such responses can be retrieved by calling response.status().

    **NOTE** `frame.goto` either throws an error or returns a main resource response. The only exceptions are navigation to `about:blank` or navigation to the same URL with a different hash, which would succeed and return `null`.

    **NOTE** Headless mode doesn&#39;t support navigation to a PDF document. See the upstream issue.

    Parameters
    ----------
    url : str
        URL to navigate frame to. The url should include scheme, e.g. `https://`.
    timeout : Optional[int]
        Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    waitUntil : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
        When to consider navigation succeeded, defaults to `load`. Events can be either:
         - `&#39;domcontentloaded&#39;` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
         - `&#39;load&#39;` - consider navigation to be finished when the `load` event is fired.
         - `&#39;networkidle&#39;` - consider navigation to be finished when there are no network connections for at least `500` ms.
    referer : Optional[str]
        Referer header value. If provided it will take preference over the referer header value set by page.setExtraHTTPHeaders().

    Returns
    -------
    Optional[Response]
        Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect.
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(
        self._sync(
            self._impl_obj.goto(
                url=url, timeout=timeout, waitUntil=waitUntil, referer=referer
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.hover"><code class="name flex">
<span>def <span class="ident">hover</span></span>(<span>self, selector: str, modifiers: List[Literal['Alt', 'Control', 'Meta', 'Shift']] = None, position: playwright.helper.MousePosition = None, timeout: int = None, force: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.hover</p>
<p>This method hovers over an element matching <code>selector</code> by performing the following steps:</p>
<p>Find an element match matching <code>selector</code>. If there is none, wait until a matching element is attached to the DOM.
Wait for actionability checks on the matched element, unless <code>force</code> option is set. If the element is detached during the checks, the whole action is retried.
Scroll the element into view if needed.
Use page.mouse to hover over the center of the element, or the specified <code>position</code>.
Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a TimeoutError. Passing zero timeout disables this.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element to hover. If there are multiple elements satisfying the selector, the first will be hovered. See working with selectors for more details.</dd>
<dt><strong><code>modifiers</code></strong> :&ensp;<code>Optional[List[Literal['Alt', 'Control', 'Meta', 'Shift']]]</code></dt>
<dd>Modifier keys to press. Ensures that only these modifiers are pressed during the hover, and then restores current modifiers back. If not specified, currently pressed modifiers are used.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>Optional[{"x": float, "y": float}]</code></dt>
<dd>A point to hover relative to the top-left corner of element padding box. If not specified, hovers over some visible point of the element.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to bypass the actionability checks. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hover(
    self,
    selector: str,
    modifiers: typing.Union[
        typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
    ] = None,
    position: MousePosition = None,
    timeout: int = None,
    force: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Frame.hover

    This method hovers over an element matching `selector` by performing the following steps:

    Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
    Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
    Scroll the element into view if needed.
    Use page.mouse to hover over the center of the element, or the specified `position`.
    Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

    Parameters
    ----------
    selector : str
        A selector to search for element to hover. If there are multiple elements satisfying the selector, the first will be hovered. See working with selectors for more details.
    modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
        Modifier keys to press. Ensures that only these modifiers are pressed during the hover, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
    position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
        A point to hover relative to the top-left corner of element padding box. If not specified, hovers over some visible point of the element.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    force : Optional[bool]
        Whether to bypass the actionability checks. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.hover(
                selector=selector,
                modifiers=modifiers,
                position=position,
                timeout=timeout,
                force=force,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.innerHTML"><code class="name flex">
<span>def <span class="ident">innerHTML</span></span>(<span>self, selector: str, timeout: int = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.innerHTML</p>
<p>Resolves to the <code>element.innerHTML</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def innerHTML(self, selector: str, timeout: int = None) -&gt; str:
    &#34;&#34;&#34;Frame.innerHTML

    Resolves to the `element.innerHTML`.

    Parameters
    ----------
    selector : str
        A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.innerHTML(selector=selector, timeout=timeout))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.innerText"><code class="name flex">
<span>def <span class="ident">innerText</span></span>(<span>self, selector: str, timeout: int = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.innerText</p>
<p>Resolves to the <code>element.innerText</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def innerText(self, selector: str, timeout: int = None) -&gt; str:
    &#34;&#34;&#34;Frame.innerText

    Resolves to the `element.innerText`.

    Parameters
    ----------
    selector : str
        A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.innerText(selector=selector, timeout=timeout))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.isDetached"><code class="name flex">
<span>def <span class="ident">isDetached</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.isDetached</p>
<p>Returns <code>true</code> if the frame has been detached, or <code>false</code> otherwise.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isDetached(self) -&gt; bool:
    &#34;&#34;&#34;Frame.isDetached

    Returns `true` if the frame has been detached, or `false` otherwise.

    Returns
    -------
    bool
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.isDetached())</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.press"><code class="name flex">
<span>def <span class="ident">press</span></span>(<span>self, selector: str, key: str, delay: int = None, timeout: int = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.press</p>
<p><code>key</code> can specify the intended keyboardEvent.key value or a single character to generate the text for. A superset of the <code>key</code> values can be found here. Examples of the keys are:
<code>F1</code> - <code>F12</code>, <code>Digit0</code>- <code>Digit9</code>, <code>KeyA</code>- <code>KeyZ</code>, <code>Backquote</code>, <code>Minus</code>, <code>Equal</code>, <code>Backslash</code>, <code>Backspace</code>, <code>Tab</code>, <code>Delete</code>, <code>Escape</code>, <code>ArrowDown</code>, <code>End</code>, <code>Enter</code>, <code>Home</code>, <code>Insert</code>, <code>PageDown</code>, <code>PageUp</code>, <code>ArrowRight</code>, <code>ArrowUp</code>, etc.
Following modification shortcuts are also suported: <code>Shift</code>, <code>Control</code>, <code>Alt</code>, <code>Meta</code>, <code>ShiftLeft</code>.
Holding down <code>Shift</code> will type the text that corresponds to the <code>key</code> in the upper case.
If <code>key</code> is a single character, it is case-sensitive, so the values <code>a</code> and <code>A</code> will generate different respective texts.
Shortcuts such as <code>key: "Control+o"</code> or <code>key: "Control+Shift+T"</code> are supported as well. When speficied with the modifier, modifier is pressed and being held while the subsequent key is being pressed.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector of an element to type into. If there are multiple elements satisfying the selector, the first will be used. See working with selectors for more details.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the key to press or a character to generate, such as <code>ArrowLeft</code> or <code>a</code>.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Time to wait between <code>keydown</code> and <code>keyup</code> in milliseconds. Defaults to 0.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def press(
    self,
    selector: str,
    key: str,
    delay: int = None,
    timeout: int = None,
    noWaitAfter: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Frame.press

    `key` can specify the intended keyboardEvent.key value or a single character to generate the text for. A superset of the `key` values can be found here. Examples of the keys are:
    `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`, `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.
    Following modification shortcuts are also suported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`.
    Holding down `Shift` will type the text that corresponds to the `key` in the upper case.
    If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective texts.
    Shortcuts such as `key: &#34;Control+o&#34;` or `key: &#34;Control+Shift+T&#34;` are supported as well. When speficied with the modifier, modifier is pressed and being held while the subsequent key is being pressed.

    Parameters
    ----------
    selector : str
        A selector of an element to type into. If there are multiple elements satisfying the selector, the first will be used. See working with selectors for more details.
    key : str
        Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
    delay : Optional[int]
        Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.press(
                selector=selector,
                key=key,
                delay=delay,
                timeout=timeout,
                noWaitAfter=noWaitAfter,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.querySelector"><code class="name flex">
<span>def <span class="ident">querySelector</span></span>(<span>self, selector: str) ‑> Union[<a title="playwright.async_api.ElementHandle" href="async_api.html#playwright.async_api.ElementHandle">ElementHandle</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.querySelector</p>
<p>The method finds an element matching the specified selector within the frame. See Working with selectors for more details. If no elements match the selector, the return value resolves to <code>null</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query frame for. See working with selectors for more details.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[<a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a>]</code></dt>
<dd>Promise which resolves to ElementHandle pointing to the frame element.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def querySelector(self, selector: str) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
    &#34;&#34;&#34;Frame.querySelector

    The method finds an element matching the specified selector within the frame. See Working with selectors for more details. If no elements match the selector, the return value resolves to `null`.

    Parameters
    ----------
    selector : str
        A selector to query frame for. See working with selectors for more details.

    Returns
    -------
    Optional[ElementHandle]
        Promise which resolves to ElementHandle pointing to the frame element.
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(
        self._sync(self._impl_obj.querySelector(selector=selector))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.querySelectorAll"><code class="name flex">
<span>def <span class="ident">querySelectorAll</span></span>(<span>self, selector: str) ‑> List[<a title="playwright.async_api.ElementHandle" href="async_api.html#playwright.async_api.ElementHandle">ElementHandle</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.querySelectorAll</p>
<p>The method finds all elements matching the specified selector within the frame. See Working with selectors for more details. If no elements match the selector, the return value resolves to <code>[]</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query frame for. See working with selectors for more details.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a>]</code></dt>
<dd>Promise which resolves to ElementHandles pointing to the frame elements.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def querySelectorAll(self, selector: str) -&gt; typing.List[&#34;ElementHandle&#34;]:
    &#34;&#34;&#34;Frame.querySelectorAll

    The method finds all elements matching the specified selector within the frame. See Working with selectors for more details. If no elements match the selector, the return value resolves to `[]`.

    Parameters
    ----------
    selector : str
        A selector to query frame for. See working with selectors for more details.

    Returns
    -------
    List[ElementHandle]
        Promise which resolves to ElementHandles pointing to the frame elements.
    &#34;&#34;&#34;
    return mapping.from_impl_list(
        self._sync(self._impl_obj.querySelectorAll(selector=selector))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.selectOption"><code class="name flex">
<span>def <span class="ident">selectOption</span></span>(<span>self, selector: str, values: Union[str, ForwardRef('<a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a>'), playwright.helper.SelectOption, List[str], List[ForwardRef('<a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a>')], List[playwright.helper.SelectOption]] = None, timeout: int = None, noWaitAfter: bool = None) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.selectOption</p>
<p>Triggers a <code>change</code> and <code>input</code> event once all the provided options have been selected.
If there's no <code>&lt;select&gt;</code> element matching <code>selector</code>, the method throws an error.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query frame for. See working with selectors for more details.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>Union[str, ElementHandle, {"value": Optional[str], "label": Optional[str], "index": Optional[str]}, List[str], List[ElementHandle], List[{"value": Optional[str], "label": Optional[str], "index": Optional[str]}], NoneType]</code></dt>
<dd>Options to select. If the <code>&lt;select&gt;</code> has the <code>multiple</code> attribute, all matching options are selected, otherwise only the first option matching one of the passed options is selected. String values are equivalent to <code>{value:'string'}</code>. Option is considered matching if all specified properties match.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[str]</code></dt>
<dd>An array of option values that have been successfully selected.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selectOption(
    self,
    selector: str,
    values: typing.Union[
        str,
        &#34;ElementHandle&#34;,
        SelectOption,
        typing.List[str],
        typing.List[&#34;ElementHandle&#34;],
        typing.List[SelectOption],
    ] = None,
    timeout: int = None,
    noWaitAfter: bool = None,
) -&gt; typing.List[str]:
    &#34;&#34;&#34;Frame.selectOption

    Triggers a `change` and `input` event once all the provided options have been selected.
    If there&#39;s no `&lt;select&gt;` element matching `selector`, the method throws an error.

    Parameters
    ----------
    selector : str
        A selector to query frame for. See working with selectors for more details.
    values : Union[str, ElementHandle, {&#34;value&#34;: Optional[str], &#34;label&#34;: Optional[str], &#34;index&#34;: Optional[str]}, List[str], List[ElementHandle], List[{&#34;value&#34;: Optional[str], &#34;label&#34;: Optional[str], &#34;index&#34;: Optional[str]}], NoneType]
        Options to select. If the `&lt;select&gt;` has the `multiple` attribute, all matching options are selected, otherwise only the first option matching one of the passed options is selected. String values are equivalent to `{value:&#39;string&#39;}`. Option is considered matching if all specified properties match.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.

    Returns
    -------
    List[str]
        An array of option values that have been successfully selected.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.selectOption(
                selector=selector,
                values=mapping.to_impl(values),
                timeout=timeout,
                noWaitAfter=noWaitAfter,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.setContent"><code class="name flex">
<span>def <span class="ident">setContent</span></span>(<span>self, html: str, timeout: int = None, waitUntil: Literal['domcontentloaded', 'load', 'networkidle'] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.setContent</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>html</code></strong> :&ensp;<code>str</code></dt>
<dd>HTML markup to assign to the page.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds for resources to load, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>waitUntil</code></strong> :&ensp;<code>Optional[Literal['domcontentloaded', 'load', 'networkidle']]</code></dt>
<dd>When to consider navigation succeeded, defaults to <code>load</code>. Events can be either:
- <code>'domcontentloaded'</code> - consider setting content to be finished when the <code>DOMContentLoaded</code> event is fired.
- <code>'load'</code> - consider setting content to be finished when the <code>load</code> event is fired.
- <code>'networkidle'</code> - consider setting content to be finished when there are no network connections for at least <code>500</code> ms.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setContent(
    self,
    html: str,
    timeout: int = None,
    waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Frame.setContent

    Parameters
    ----------
    html : str
        HTML markup to assign to the page.
    timeout : Optional[int]
        Maximum time in milliseconds for resources to load, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    waitUntil : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
        When to consider navigation succeeded, defaults to `load`. Events can be either:
         - `&#39;domcontentloaded&#39;` - consider setting content to be finished when the `DOMContentLoaded` event is fired.
         - `&#39;load&#39;` - consider setting content to be finished when the `load` event is fired.
         - `&#39;networkidle&#39;` - consider setting content to be finished when there are no network connections for at least `500` ms.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.setContent(
                html=html, timeout=timeout, waitUntil=waitUntil
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.setInputFiles"><code class="name flex">
<span>def <span class="ident">setInputFiles</span></span>(<span>self, selector: str, files: Union[str, pathlib.Path, playwright.helper.FilePayload, List[str], List[pathlib.Path], List[playwright.helper.FilePayload]], timeout: int = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.setInputFiles</p>
<p>This method expects <code>selector</code> to point to an input element.
Sets the value of the file input to these file paths or files. If some of the <code>filePaths</code> are relative paths, then they are resolved relative to the current working directory. For empty array, clears the selected files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element to click. If there are multiple elements satisfying the selector, the first will be clicked. See working with selectors for more details.</dd>
<dt><strong><code>files</code></strong> :&ensp;<code>Union[str, pathlib.Path, {"name": str, "mimeType": str, "buffer": bytes}, List[str], List[pathlib.Path], List[{"name": str, "mimeType": str, "buffer": bytes}]]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setInputFiles(
    self,
    selector: str,
    files: typing.Union[
        str,
        pathlib.Path,
        FilePayload,
        typing.List[str],
        typing.List[pathlib.Path],
        typing.List[FilePayload],
    ],
    timeout: int = None,
    noWaitAfter: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Frame.setInputFiles

    This method expects `selector` to point to an input element.
    Sets the value of the file input to these file paths or files. If some of the `filePaths` are relative paths, then they are resolved relative to the current working directory. For empty array, clears the selected files.

    Parameters
    ----------
    selector : str
        A selector to search for element to click. If there are multiple elements satisfying the selector, the first will be clicked. See working with selectors for more details.
    files : Union[str, pathlib.Path, {&#34;name&#34;: str, &#34;mimeType&#34;: str, &#34;buffer&#34;: bytes}, List[str], List[pathlib.Path], List[{&#34;name&#34;: str, &#34;mimeType&#34;: str, &#34;buffer&#34;: bytes}]]
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.setInputFiles(
                selector=selector,
                files=files,
                timeout=timeout,
                noWaitAfter=noWaitAfter,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.tap"><code class="name flex">
<span>def <span class="ident">tap</span></span>(<span>self, selector: str, modifiers: List[Literal['Alt', 'Control', 'Meta', 'Shift']] = None, position: playwright.helper.MousePosition = None, timeout: int = None, force: bool = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.tap</p>
<p>This method taps an element matching <code>selector</code> by performing the following steps:</p>
<p>Find an element match matching <code>selector</code>. If there is none, wait until a matching element is attached to the DOM.
Wait for actionability checks on the matched element, unless <code>force</code> option is set. If the element is detached during the checks, the whole action is retried.
Scroll the element into view if needed.
Use page.touchscreen to tap the center of the element, or the specified <code>position</code>.
Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a TimeoutError. Passing zero timeout disables this.</p>
<p><strong>NOTE</strong> <code>frame.tap()</code> requires that the <code>hasTouch</code> option of the browser context be set to true.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element to tap. If there are multiple elements satisfying the selector, the first will be tapped. See working with selectors for more details.</dd>
<dt><strong><code>modifiers</code></strong> :&ensp;<code>Optional[List[Literal['Alt', 'Control', 'Meta', 'Shift']]]</code></dt>
<dd>Modifier keys to press. Ensures that only these modifiers are pressed during the tap, and then restores current modifiers back. If not specified, currently pressed modifiers are used.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>Optional[{"x": float, "y": float}]</code></dt>
<dd>A point to tap relative to the top-left corner of element padding box. If not specified, taps some visible point of the element.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to bypass the actionability checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tap(
    self,
    selector: str,
    modifiers: typing.Union[
        typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
    ] = None,
    position: MousePosition = None,
    timeout: int = None,
    force: bool = None,
    noWaitAfter: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Frame.tap

    This method taps an element matching `selector` by performing the following steps:

    Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
    Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
    Scroll the element into view if needed.
    Use page.touchscreen to tap the center of the element, or the specified `position`.
    Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

    **NOTE** `frame.tap()` requires that the `hasTouch` option of the browser context be set to true.

    Parameters
    ----------
    selector : str
        A selector to search for element to tap. If there are multiple elements satisfying the selector, the first will be tapped. See working with selectors for more details.
    modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
        Modifier keys to press. Ensures that only these modifiers are pressed during the tap, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
    position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
        A point to tap relative to the top-left corner of element padding box. If not specified, taps some visible point of the element.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    force : Optional[bool]
        Whether to bypass the actionability checks. Defaults to `false`.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.tap(
                selector=selector,
                modifiers=modifiers,
                position=position,
                timeout=timeout,
                force=force,
                noWaitAfter=noWaitAfter,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.textContent"><code class="name flex">
<span>def <span class="ident">textContent</span></span>(<span>self, selector: str, timeout: int = None) ‑> Union[str, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.textContent</p>
<p>Resolves to the <code>element.textContent</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[str]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def textContent(
    self, selector: str, timeout: int = None
) -&gt; typing.Union[str, NoneType]:
    &#34;&#34;&#34;Frame.textContent

    Resolves to the `element.textContent`.

    Parameters
    ----------
    selector : str
        A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

    Returns
    -------
    Optional[str]
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.textContent(selector=selector, timeout=timeout))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.title"><code class="name flex">
<span>def <span class="ident">title</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.title</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The page's title.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def title(self) -&gt; str:
    &#34;&#34;&#34;Frame.title

    Returns
    -------
    str
        The page&#39;s title.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.title()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.type"><code class="name flex">
<span>def <span class="ident">type</span></span>(<span>self, selector: str, text: str, delay: int = None, timeout: int = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.type</p>
<p>Sends a <code>keydown</code>, <code>keypress</code>/<code>input</code>, and <code>keyup</code> event for each character in the text. <code>frame.type</code> can be used to send fine-grained keyboard events. To fill values in form fields, use <code>frame.fill</code>.
To press a special key, like <code>Control</code> or <code>ArrowDown</code>, use <code>keyboard.press</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector of an element to type into. If there are multiple elements satisfying the selector, the first will be used. See working with selectors for more details.</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>A text to type into a focused element.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Time to wait between key presses in milliseconds. Defaults to 0.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def type(
    self,
    selector: str,
    text: str,
    delay: int = None,
    timeout: int = None,
    noWaitAfter: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Frame.type

    Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text. `frame.type` can be used to send fine-grained keyboard events. To fill values in form fields, use `frame.fill`.
    To press a special key, like `Control` or `ArrowDown`, use `keyboard.press`.

    Parameters
    ----------
    selector : str
        A selector of an element to type into. If there are multiple elements satisfying the selector, the first will be used. See working with selectors for more details.
    text : str
        A text to type into a focused element.
    delay : Optional[int]
        Time to wait between key presses in milliseconds. Defaults to 0.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.type(
                selector=selector,
                text=text,
                delay=delay,
                timeout=timeout,
                noWaitAfter=noWaitAfter,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.uncheck"><code class="name flex">
<span>def <span class="ident">uncheck</span></span>(<span>self, selector: str, timeout: int = None, force: bool = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.uncheck</p>
<p>This method checks an element matching <code>selector</code> by performing the following steps:</p>
<p>Find an element match matching <code>selector</code>. If there is none, wait until a matching element is attached to the DOM.
Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already unchecked, this method returns immediately.
Wait for actionability checks on the matched element, unless <code>force</code> option is set. If the element is detached during the checks, the whole action is retried.
Scroll the element into view if needed.
Use page.mouse to click in the center of the element.
Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.
Ensure that the element is now unchecked. If not, this method rejects.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a TimeoutError. Passing zero timeout disables this.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for uncheckbox to check. If there are multiple elements satisfying the selector, the first will be checked. See working with selectors for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to bypass the actionability checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uncheck(
    self,
    selector: str,
    timeout: int = None,
    force: bool = None,
    noWaitAfter: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Frame.uncheck

    This method checks an element matching `selector` by performing the following steps:

    Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
    Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already unchecked, this method returns immediately.
    Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
    Scroll the element into view if needed.
    Use page.mouse to click in the center of the element.
    Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
    Ensure that the element is now unchecked. If not, this method rejects.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

    Parameters
    ----------
    selector : str
        A selector to search for uncheckbox to check. If there are multiple elements satisfying the selector, the first will be checked. See working with selectors for more details.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    force : Optional[bool]
        Whether to bypass the actionability checks. Defaults to `false`.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.uncheck(
                selector=selector,
                timeout=timeout,
                force=force,
                noWaitAfter=noWaitAfter,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.waitForFunction"><code class="name flex">
<span>def <span class="ident">waitForFunction</span></span>(<span>self, expression: str, arg: Any = None, force_expr: bool = None, timeout: int = None, polling: Union[int, Literal['raf']] = None) ‑> <a title="playwright.sync_api.JSHandle" href="#playwright.sync_api.JSHandle">JSHandle</a></span>
</code></dt>
<dd>
<div class="desc"><p>Frame.waitForFunction</p>
<p>The <code>waitForFunction</code> can be used to observe viewport size change:</p>
<p>To pass an argument from Node.js to the predicate of <code>frame.waitForFunction</code> function:</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>Function to be evaluated in browser context</dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Optional[Any]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>maximum time to wait for in milliseconds. Defaults to <code>30000</code> (30 seconds). Pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>polling</code></strong> :&ensp;<code>Union[int, 'raf', NoneType]</code></dt>
<dd>If <code>polling</code> is <code>'raf'</code>, then <code>pageFunction</code> is constantly executed in <code>requestAnimationFrame</code> callback. If <code>polling</code> is a number, then it is treated as an interval in milliseconds at which the function would be executed. Defaults to <code>raf</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.JSHandle" href="#playwright.sync_api.JSHandle">JSHandle</a></code></dt>
<dd>Promise which resolves when the <code>pageFunction</code> returns a truthy value. It resolves to a JSHandle of the truthy value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def waitForFunction(
    self,
    expression: str,
    arg: typing.Any = None,
    force_expr: bool = None,
    timeout: int = None,
    polling: typing.Union[int, Literal[&#34;raf&#34;]] = None,
) -&gt; &#34;JSHandle&#34;:
    &#34;&#34;&#34;Frame.waitForFunction

    The `waitForFunction` can be used to observe viewport size change:

    To pass an argument from Node.js to the predicate of `frame.waitForFunction` function:

    Parameters
    ----------
    expression : str
        Function to be evaluated in browser context
    force_expr : bool
        Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
    arg : Optional[Any]
        Optional argument to pass to `pageFunction`
    timeout : Optional[int]
        maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    polling : Union[int, &#39;raf&#39;, NoneType]
        If `polling` is `&#39;raf&#39;`, then `pageFunction` is constantly executed in `requestAnimationFrame` callback. If `polling` is a number, then it is treated as an interval in milliseconds at which the function would be executed. Defaults to `raf`.

    Returns
    -------
    JSHandle
        Promise which resolves when the `pageFunction` returns a truthy value. It resolves to a JSHandle of the truthy value.
    &#34;&#34;&#34;
    return mapping.from_impl(
        self._sync(
            self._impl_obj.waitForFunction(
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
                timeout=timeout,
                polling=polling,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.waitForLoadState"><code class="name flex">
<span>def <span class="ident">waitForLoadState</span></span>(<span>self, state: Literal['domcontentloaded', 'load', 'networkidle'] = None, timeout: int = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.waitForLoadState</p>
<p>This resolves when the frame reaches a required load state, <code>load</code> by default. The navigation must have been committed when this method is called. If current document has already reached the required state, resolves immediately.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<code>Optional[Literal['domcontentloaded', 'load', 'networkidle']]</code></dt>
<dd>Load state to wait for, defaults to <code>load</code>. If the state has been already reached while loading current document, the method resolves immediately.
- <code>'load'</code> - wait for the <code>load</code> event to be fired.
- <code>'domcontentloaded'</code> - wait for the <code>DOMContentLoaded</code> event to be fired.
- <code>'networkidle'</code> - wait until there are no network connections for at least <code>500</code> ms.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum waiting time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def waitForLoadState(
    self,
    state: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    timeout: int = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Frame.waitForLoadState

    This resolves when the frame reaches a required load state, `load` by default. The navigation must have been committed when this method is called. If current document has already reached the required state, resolves immediately.

    Parameters
    ----------
    state : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
        Load state to wait for, defaults to `load`. If the state has been already reached while loading current document, the method resolves immediately.
         - `&#39;load&#39;` - wait for the `load` event to be fired.
         - `&#39;domcontentloaded&#39;` - wait for the `DOMContentLoaded` event to be fired.
         - `&#39;networkidle&#39;` - wait until there are no network connections for at least `500` ms.
    timeout : Optional[int]
        Maximum waiting time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.waitForLoadState(state=state, timeout=timeout))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.waitForNavigation"><code class="name flex">
<span>def <span class="ident">waitForNavigation</span></span>(<span>self, url: Union[str, Pattern, Callable[[str], bool]] = None, waitUntil: Literal['domcontentloaded', 'load', 'networkidle'] = None, timeout: int = None) ‑> Union[<a title="playwright.async_api.Response" href="async_api.html#playwright.async_api.Response">Response</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.waitForNavigation</p>
<p>This resolves when the frame navigates to a new URL. It is useful for when you run code
which will indirectly cause the frame to navigate. Consider this example:
<strong>NOTE</strong> Usage of the History API to change the URL is considered a navigation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>Union[str, Pattern, typing.Callable[[str], bool], NoneType]</code></dt>
<dd>URL string, URL regex pattern or predicate receiving URL to match while waiting for the navigation.</dd>
<dt><strong><code>waitUntil</code></strong> :&ensp;<code>Optional[Literal['domcontentloaded', 'load', 'networkidle']]</code></dt>
<dd>When to consider navigation succeeded, defaults to <code>load</code>. Events can be either:
- <code>'domcontentloaded'</code> - consider navigation to be finished when the <code>DOMContentLoaded</code> event is fired.
- <code>'load'</code> - consider navigation to be finished when the <code>load</code> event is fired.
- <code>'networkidle'</code> - consider navigation to be finished when there are no network connections for at least <code>500</code> ms.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum navigation time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[<a title="playwright.sync_api.Response" href="#playwright.sync_api.Response">Response</a>]</code></dt>
<dd>Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect. In case of navigation to a different anchor or navigation due to History API usage, the navigation will resolve with <code>null</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def waitForNavigation(
    self,
    url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
    waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    timeout: int = None,
) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
    &#34;&#34;&#34;Frame.waitForNavigation

    This resolves when the frame navigates to a new URL. It is useful for when you run code
    which will indirectly cause the frame to navigate. Consider this example:
    **NOTE** Usage of the History API to change the URL is considered a navigation.

    Parameters
    ----------
    url : Union[str, Pattern, typing.Callable[[str], bool], NoneType]
        URL string, URL regex pattern or predicate receiving URL to match while waiting for the navigation.
    waitUntil : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
        When to consider navigation succeeded, defaults to `load`. Events can be either:
         - `&#39;domcontentloaded&#39;` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
         - `&#39;load&#39;` - consider navigation to be finished when the `load` event is fired.
         - `&#39;networkidle&#39;` - consider navigation to be finished when there are no network connections for at least `500` ms.
    timeout : Optional[int]
        Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

    Returns
    -------
    Optional[Response]
        Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect. In case of navigation to a different anchor or navigation due to History API usage, the navigation will resolve with `null`.
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(
        self._sync(
            self._impl_obj.waitForNavigation(
                url=self._wrap_handler(url), waitUntil=waitUntil, timeout=timeout
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.waitForSelector"><code class="name flex">
<span>def <span class="ident">waitForSelector</span></span>(<span>self, selector: str, timeout: int = None, state: Literal['attached', 'detached', 'hidden', 'visible'] = None) ‑> Union[<a title="playwright.async_api.ElementHandle" href="async_api.html#playwright.async_api.ElementHandle">ElementHandle</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.waitForSelector</p>
<p>Wait for the <code>selector</code> to satisfy <code>state</code> option (either appear/disappear from dom, or become visible/hidden). If at the moment of calling the method <code>selector</code> already satisfies the condition, the method will return immediately. If the selector doesn't satisfy the condition for the <code>timeout</code> milliseconds, the function will throw.
This method works across navigations:</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector of an element to wait for. See working with selectors for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>Optional[Literal['attached', 'detached', 'hidden', 'visible']]</code></dt>
<dd>Defaults to <code>'visible'</code>. Can be either:
- <code>'attached'</code> - wait for element to be present in DOM.
- <code>'detached'</code> - wait for element to not be present in DOM.
- <code>'visible'</code> - wait for element to have non-empty bounding box and no <code>visibility:hidden</code>. Note that element without any content or with <code>display:none</code> has an empty bounding box and is not considered visible.
- <code>'hidden'</code> - wait for element to be either detached from DOM, or have an empty bounding box or <code>visibility:hidden</code>. This is opposite to the <code>'visible'</code> option.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[<a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a>]</code></dt>
<dd>Promise which resolves when element specified by selector satisfies <code>state</code> option. Resolves to <code>null</code> if waiting for <code>hidden</code> or <code>detached</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def waitForSelector(
    self,
    selector: str,
    timeout: int = None,
    state: Literal[&#34;attached&#34;, &#34;detached&#34;, &#34;hidden&#34;, &#34;visible&#34;] = None,
) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
    &#34;&#34;&#34;Frame.waitForSelector

    Wait for the `selector` to satisfy `state` option (either appear/disappear from dom, or become visible/hidden). If at the moment of calling the method `selector` already satisfies the condition, the method will return immediately. If the selector doesn&#39;t satisfy the condition for the `timeout` milliseconds, the function will throw.
    This method works across navigations:

    Parameters
    ----------
    selector : str
        A selector of an element to wait for. See working with selectors for more details.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    state : Optional[Literal[&#39;attached&#39;, &#39;detached&#39;, &#39;hidden&#39;, &#39;visible&#39;]]
        Defaults to `&#39;visible&#39;`. Can be either:
         - `&#39;attached&#39;` - wait for element to be present in DOM.
         - `&#39;detached&#39;` - wait for element to not be present in DOM.
         - `&#39;visible&#39;` - wait for element to have non-empty bounding box and no `visibility:hidden`. Note that element without any content or with `display:none` has an empty bounding box and is not considered visible.
         - `&#39;hidden&#39;` - wait for element to be either detached from DOM, or have an empty bounding box or `visibility:hidden`. This is opposite to the `&#39;visible&#39;` option.

    Returns
    -------
    Optional[ElementHandle]
        Promise which resolves when element specified by selector satisfies `state` option. Resolves to `null` if waiting for `hidden` or `detached`.
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(
        self._sync(
            self._impl_obj.waitForSelector(
                selector=selector, timeout=timeout, state=state
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Frame.waitForTimeout"><code class="name flex">
<span>def <span class="ident">waitForTimeout</span></span>(<span>self, timeout: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.waitForTimeout</p>
<p>Returns a promise that resolves after the timeout.
Note that <code>frame.waitForTimeout()</code> should only be used for debugging. Tests using the timer in production are going to be flaky. Use signals such as network events, selectors becoming visible and others instead.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>A timeout to wait for</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def waitForTimeout(self, timeout: int) -&gt; NoneType:
    &#34;&#34;&#34;Frame.waitForTimeout

    Returns a promise that resolves after the timeout.
    Note that `frame.waitForTimeout()` should only be used for debugging. Tests using the timer in production are going to be flaky. Use signals such as network events, selectors becoming visible and others instead.

    Parameters
    ----------
    timeout : int
        A timeout to wait for
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.waitForTimeout(timeout=timeout))
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.sync_api.JSHandle"><code class="flex name class">
<span>class <span class="ident">JSHandle</span></span>
<span>(</span><span>obj: playwright.js_handle.JSHandle)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JSHandle(SyncBase):
    def __init__(self, obj: JSHandleImpl):
        super().__init__(obj)

    def evaluate(
        self, expression: str, arg: typing.Any = None, force_expr: bool = None
    ) -&gt; typing.Any:
        &#34;&#34;&#34;JSHandle.evaluate

        This method passes this handle as the first argument to `pageFunction`.
        If `pageFunction` returns a Promise, then `handle.evaluate` would wait for the promise to resolve and return its value.
        Examples:

        Parameters
        ----------
        expression : str
            Function to be evaluated in browser context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        Any
            Promise which resolves to the return value of `pageFunction`
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.evaluate(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )

    def evaluateHandle(
        self, expression: str, arg: typing.Any = None, force_expr: bool = None
    ) -&gt; &#34;JSHandle&#34;:
        &#34;&#34;&#34;JSHandle.evaluateHandle

        This method passes this handle as the first argument to `pageFunction`.
        The only difference between `jsHandle.evaluate` and `jsHandle.evaluateHandle` is that `jsHandle.evaluateHandle` returns in-page object (JSHandle).
        If the function passed to the `jsHandle.evaluateHandle` returns a Promise, then `jsHandle.evaluateHandle` would wait for the promise to resolve and return its value.
        See page.evaluateHandle() for more details.

        Parameters
        ----------
        expression : str
            Function to be evaluated
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        JSHandle
            Promise which resolves to the return value of `pageFunction` as in-page object (JSHandle)
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.evaluateHandle(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )

    def getProperty(self, propertyName: str) -&gt; &#34;JSHandle&#34;:
        &#34;&#34;&#34;JSHandle.getProperty

        Fetches a single property from the referenced object.

        Parameters
        ----------
        propertyName : str
            property to get

        Returns
        -------
        JSHandle
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(self._impl_obj.getProperty(propertyName=propertyName))
        )

    def getProperties(self) -&gt; typing.Dict[str, &#34;JSHandle&#34;]:
        &#34;&#34;&#34;JSHandle.getProperties

        The method returns a map with **own property names** as keys and JSHandle instances for the property values.

        Returns
        -------
        Dict[str, JSHandle]
        &#34;&#34;&#34;
        return mapping.from_impl_dict(self._sync(self._impl_obj.getProperties()))

    def asElement(self) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
        &#34;&#34;&#34;JSHandle.asElement

        Returns either `null` or the object handle itself, if the object handle is an instance of ElementHandle.

        Returns
        -------
        Optional[ElementHandle]
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._impl_obj.asElement())

    def dispose(self) -&gt; NoneType:
        &#34;&#34;&#34;JSHandle.dispose

        The `jsHandle.dispose` method stops referencing the element handle.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.dispose()))

    def jsonValue(self) -&gt; typing.Any:
        &#34;&#34;&#34;JSHandle.jsonValue

        Returns a JSON representation of the object. If the object has a
        `toJSON`
        function, it **will not be called**.

        **NOTE** The method will return an empty JSON object if the referenced object is not stringifiable. It will throw an error if the object has circular references.

        Returns
        -------
        Any
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.jsonValue()))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright.sync_base.SyncBase</li>
<li>playwright.impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="playwright.sync_api.JSHandle.asElement"><code class="name flex">
<span>def <span class="ident">asElement</span></span>(<span>self) ‑> Union[<a title="playwright.async_api.ElementHandle" href="async_api.html#playwright.async_api.ElementHandle">ElementHandle</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>JSHandle.asElement</p>
<p>Returns either <code>null</code> or the object handle itself, if the object handle is an instance of ElementHandle.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[<a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def asElement(self) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
    &#34;&#34;&#34;JSHandle.asElement

    Returns either `null` or the object handle itself, if the object handle is an instance of ElementHandle.

    Returns
    -------
    Optional[ElementHandle]
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(self._impl_obj.asElement())</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.JSHandle.dispose"><code class="name flex">
<span>def <span class="ident">dispose</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>JSHandle.dispose</p>
<p>The <code>jsHandle.dispose</code> method stops referencing the element handle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dispose(self) -&gt; NoneType:
    &#34;&#34;&#34;JSHandle.dispose

    The `jsHandle.dispose` method stops referencing the element handle.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.dispose()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.JSHandle.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, expression: str, arg: Any = None, force_expr: bool = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>JSHandle.evaluate</p>
<p>This method passes this handle as the first argument to <code>pageFunction</code>.
If <code>pageFunction</code> returns a Promise, then <code>handle.evaluate</code> would wait for the promise to resolve and return its value.
Examples:</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>Function to be evaluated in browser context</dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Optional[Any]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>Promise which resolves to the return value of <code>pageFunction</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(
    self, expression: str, arg: typing.Any = None, force_expr: bool = None
) -&gt; typing.Any:
    &#34;&#34;&#34;JSHandle.evaluate

    This method passes this handle as the first argument to `pageFunction`.
    If `pageFunction` returns a Promise, then `handle.evaluate` would wait for the promise to resolve and return its value.
    Examples:

    Parameters
    ----------
    expression : str
        Function to be evaluated in browser context
    force_expr : bool
        Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
    arg : Optional[Any]
        Optional argument to pass to `pageFunction`

    Returns
    -------
    Any
        Promise which resolves to the return value of `pageFunction`
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.evaluate(
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.JSHandle.evaluateHandle"><code class="name flex">
<span>def <span class="ident">evaluateHandle</span></span>(<span>self, expression: str, arg: Any = None, force_expr: bool = None) ‑> <a title="playwright.sync_api.JSHandle" href="#playwright.sync_api.JSHandle">JSHandle</a></span>
</code></dt>
<dd>
<div class="desc"><p>JSHandle.evaluateHandle</p>
<p>This method passes this handle as the first argument to <code>pageFunction</code>.
The only difference between <code>jsHandle.evaluate</code> and <code>jsHandle.evaluateHandle</code> is that <code>jsHandle.evaluateHandle</code> returns in-page object (JSHandle).
If the function passed to the <code>jsHandle.evaluateHandle</code> returns a Promise, then <code>jsHandle.evaluateHandle</code> would wait for the promise to resolve and return its value.
See page.evaluateHandle() for more details.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>Function to be evaluated</dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Optional[Any]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.JSHandle" href="#playwright.sync_api.JSHandle">JSHandle</a></code></dt>
<dd>Promise which resolves to the return value of <code>pageFunction</code> as in-page object (JSHandle)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluateHandle(
    self, expression: str, arg: typing.Any = None, force_expr: bool = None
) -&gt; &#34;JSHandle&#34;:
    &#34;&#34;&#34;JSHandle.evaluateHandle

    This method passes this handle as the first argument to `pageFunction`.
    The only difference between `jsHandle.evaluate` and `jsHandle.evaluateHandle` is that `jsHandle.evaluateHandle` returns in-page object (JSHandle).
    If the function passed to the `jsHandle.evaluateHandle` returns a Promise, then `jsHandle.evaluateHandle` would wait for the promise to resolve and return its value.
    See page.evaluateHandle() for more details.

    Parameters
    ----------
    expression : str
        Function to be evaluated
    force_expr : bool
        Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
    arg : Optional[Any]
        Optional argument to pass to `pageFunction`

    Returns
    -------
    JSHandle
        Promise which resolves to the return value of `pageFunction` as in-page object (JSHandle)
    &#34;&#34;&#34;
    return mapping.from_impl(
        self._sync(
            self._impl_obj.evaluateHandle(
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.JSHandle.getProperties"><code class="name flex">
<span>def <span class="ident">getProperties</span></span>(<span>self) ‑> Dict[str, <a title="playwright.async_api.JSHandle" href="async_api.html#playwright.async_api.JSHandle">JSHandle</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>JSHandle.getProperties</p>
<p>The method returns a map with <strong>own property names</strong> as keys and JSHandle instances for the property values.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, <a title="playwright.sync_api.JSHandle" href="#playwright.sync_api.JSHandle">JSHandle</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getProperties(self) -&gt; typing.Dict[str, &#34;JSHandle&#34;]:
    &#34;&#34;&#34;JSHandle.getProperties

    The method returns a map with **own property names** as keys and JSHandle instances for the property values.

    Returns
    -------
    Dict[str, JSHandle]
    &#34;&#34;&#34;
    return mapping.from_impl_dict(self._sync(self._impl_obj.getProperties()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.JSHandle.getProperty"><code class="name flex">
<span>def <span class="ident">getProperty</span></span>(<span>self, propertyName: str) ‑> <a title="playwright.sync_api.JSHandle" href="#playwright.sync_api.JSHandle">JSHandle</a></span>
</code></dt>
<dd>
<div class="desc"><p>JSHandle.getProperty</p>
<p>Fetches a single property from the referenced object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>propertyName</code></strong> :&ensp;<code>str</code></dt>
<dd>property to get</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.JSHandle" href="#playwright.sync_api.JSHandle">JSHandle</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getProperty(self, propertyName: str) -&gt; &#34;JSHandle&#34;:
    &#34;&#34;&#34;JSHandle.getProperty

    Fetches a single property from the referenced object.

    Parameters
    ----------
    propertyName : str
        property to get

    Returns
    -------
    JSHandle
    &#34;&#34;&#34;
    return mapping.from_impl(
        self._sync(self._impl_obj.getProperty(propertyName=propertyName))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.JSHandle.jsonValue"><code class="name flex">
<span>def <span class="ident">jsonValue</span></span>(<span>self) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>JSHandle.jsonValue</p>
<p>Returns a JSON representation of the object. If the object has a
<code>toJSON</code>
function, it <strong>will not be called</strong>.</p>
<p><strong>NOTE</strong> The method will return an empty JSON object if the referenced object is not stringifiable. It will throw an error if the object has circular references.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jsonValue(self) -&gt; typing.Any:
    &#34;&#34;&#34;JSHandle.jsonValue

    Returns a JSON representation of the object. If the object has a
    `toJSON`
    function, it **will not be called**.

    **NOTE** The method will return an empty JSON object if the referenced object is not stringifiable. It will throw an error if the object has circular references.

    Returns
    -------
    Any
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.jsonValue()))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.sync_api.Keyboard"><code class="flex name class">
<span>class <span class="ident">Keyboard</span></span>
<span>(</span><span>obj: playwright.input.Keyboard)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Keyboard(SyncBase):
    def __init__(self, obj: KeyboardImpl):
        super().__init__(obj)

    def down(self, key: str) -&gt; NoneType:
        &#34;&#34;&#34;Keyboard.down

        Dispatches a `keydown` event.
        `key` can specify the intended keyboardEvent.key value or a single character to generate the text for. A superset of the `key` values can be found here. Examples of the keys are:
        `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`, `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.
        Following modification shortcuts are also suported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`.
        Holding down `Shift` will type the text that corresponds to the `key` in the upper case.
        If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective texts.
        If `key` is a modifier key, `Shift`, `Meta`, `Control`, or `Alt`, subsequent key presses will be sent with that modifier active. To release the modifier key, use `keyboard.up`.
        After the key is pressed once, subsequent calls to `keyboard.down` will have repeat set to true. To release the key, use `keyboard.up`.

        **NOTE** Modifier keys DO influence `keyboard.down`. Holding down `Shift` will type the text in upper case.

        Parameters
        ----------
        key : str
            Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.down(key=key)))

    def up(self, key: str) -&gt; NoneType:
        &#34;&#34;&#34;Keyboard.up

        Dispatches a `keyup` event.

        Parameters
        ----------
        key : str
            Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.up(key=key)))

    def insertText(self, text: str) -&gt; NoneType:
        &#34;&#34;&#34;Keyboard.insertText

        Dispatches only `input` event, does not emit the `keydown`, `keyup` or `keypress` events.

        **NOTE** Modifier keys DO NOT effect `keyboard.insertText`. Holding down `Shift` will not type the text in upper case.

        Parameters
        ----------
        text : str
            Sets input to the specified text value.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.insertText(text=text)))

    def type(self, text: str, delay: int = None) -&gt; NoneType:
        &#34;&#34;&#34;Keyboard.type

        Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text.
        To press a special key, like `Control` or `ArrowDown`, use `keyboard.press`.

        **NOTE** Modifier keys DO NOT effect `keyboard.type`. Holding down `Shift` will not type the text in upper case.

        Parameters
        ----------
        text : str
            A text to type into a focused element.
        delay : Optional[int]
            Time to wait between key presses in milliseconds. Defaults to 0.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.type(text=text, delay=delay))
        )

    def press(self, key: str, delay: int = None) -&gt; NoneType:
        &#34;&#34;&#34;Keyboard.press

        `key` can specify the intended keyboardEvent.key value or a single character to generate the text for. A superset of the `key` values can be found here. Examples of the keys are:
        `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`, `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.
        Following modification shortcuts are also suported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`.
        Holding down `Shift` will type the text that corresponds to the `key` in the upper case.
        If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective texts.
        Shortcuts such as `key: &#34;Control+o&#34;` or `key: &#34;Control+Shift+T&#34;` are supported as well. When speficied with the modifier, modifier is pressed and being held while the subsequent key is being pressed.
        Shortcut for `keyboard.down` and `keyboard.up`.

        Parameters
        ----------
        key : str
            Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
        delay : Optional[int]
            Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.press(key=key, delay=delay))
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright.sync_base.SyncBase</li>
<li>playwright.impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="playwright.sync_api.Keyboard.down"><code class="name flex">
<span>def <span class="ident">down</span></span>(<span>self, key: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Keyboard.down</p>
<p>Dispatches a <code>keydown</code> event.
<code>key</code> can specify the intended keyboardEvent.key value or a single character to generate the text for. A superset of the <code>key</code> values can be found here. Examples of the keys are:
<code>F1</code> - <code>F12</code>, <code>Digit0</code>- <code>Digit9</code>, <code>KeyA</code>- <code>KeyZ</code>, <code>Backquote</code>, <code>Minus</code>, <code>Equal</code>, <code>Backslash</code>, <code>Backspace</code>, <code>Tab</code>, <code>Delete</code>, <code>Escape</code>, <code>ArrowDown</code>, <code>End</code>, <code>Enter</code>, <code>Home</code>, <code>Insert</code>, <code>PageDown</code>, <code>PageUp</code>, <code>ArrowRight</code>, <code>ArrowUp</code>, etc.
Following modification shortcuts are also suported: <code>Shift</code>, <code>Control</code>, <code>Alt</code>, <code>Meta</code>, <code>ShiftLeft</code>.
Holding down <code>Shift</code> will type the text that corresponds to the <code>key</code> in the upper case.
If <code>key</code> is a single character, it is case-sensitive, so the values <code>a</code> and <code>A</code> will generate different respective texts.
If <code>key</code> is a modifier key, <code>Shift</code>, <code>Meta</code>, <code>Control</code>, or <code>Alt</code>, subsequent key presses will be sent with that modifier active. To release the modifier key, use <code>keyboard.up</code>.
After the key is pressed once, subsequent calls to <code>keyboard.down</code> will have repeat set to true. To release the key, use <code>keyboard.up</code>.</p>
<p><strong>NOTE</strong> Modifier keys DO influence <code>keyboard.down</code>. Holding down <code>Shift</code> will type the text in upper case.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the key to press or a character to generate, such as <code>ArrowLeft</code> or <code>a</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def down(self, key: str) -&gt; NoneType:
    &#34;&#34;&#34;Keyboard.down

    Dispatches a `keydown` event.
    `key` can specify the intended keyboardEvent.key value or a single character to generate the text for. A superset of the `key` values can be found here. Examples of the keys are:
    `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`, `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.
    Following modification shortcuts are also suported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`.
    Holding down `Shift` will type the text that corresponds to the `key` in the upper case.
    If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective texts.
    If `key` is a modifier key, `Shift`, `Meta`, `Control`, or `Alt`, subsequent key presses will be sent with that modifier active. To release the modifier key, use `keyboard.up`.
    After the key is pressed once, subsequent calls to `keyboard.down` will have repeat set to true. To release the key, use `keyboard.up`.

    **NOTE** Modifier keys DO influence `keyboard.down`. Holding down `Shift` will type the text in upper case.

    Parameters
    ----------
    key : str
        Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.down(key=key)))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Keyboard.insertText"><code class="name flex">
<span>def <span class="ident">insertText</span></span>(<span>self, text: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Keyboard.insertText</p>
<p>Dispatches only <code>input</code> event, does not emit the <code>keydown</code>, <code>keyup</code> or <code>keypress</code> events.</p>
<p><strong>NOTE</strong> Modifier keys DO NOT effect <code>keyboard.insertText</code>. Holding down <code>Shift</code> will not type the text in upper case.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>Sets input to the specified text value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insertText(self, text: str) -&gt; NoneType:
    &#34;&#34;&#34;Keyboard.insertText

    Dispatches only `input` event, does not emit the `keydown`, `keyup` or `keypress` events.

    **NOTE** Modifier keys DO NOT effect `keyboard.insertText`. Holding down `Shift` will not type the text in upper case.

    Parameters
    ----------
    text : str
        Sets input to the specified text value.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.insertText(text=text)))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Keyboard.press"><code class="name flex">
<span>def <span class="ident">press</span></span>(<span>self, key: str, delay: int = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Keyboard.press</p>
<p><code>key</code> can specify the intended keyboardEvent.key value or a single character to generate the text for. A superset of the <code>key</code> values can be found here. Examples of the keys are:
<code>F1</code> - <code>F12</code>, <code>Digit0</code>- <code>Digit9</code>, <code>KeyA</code>- <code>KeyZ</code>, <code>Backquote</code>, <code>Minus</code>, <code>Equal</code>, <code>Backslash</code>, <code>Backspace</code>, <code>Tab</code>, <code>Delete</code>, <code>Escape</code>, <code>ArrowDown</code>, <code>End</code>, <code>Enter</code>, <code>Home</code>, <code>Insert</code>, <code>PageDown</code>, <code>PageUp</code>, <code>ArrowRight</code>, <code>ArrowUp</code>, etc.
Following modification shortcuts are also suported: <code>Shift</code>, <code>Control</code>, <code>Alt</code>, <code>Meta</code>, <code>ShiftLeft</code>.
Holding down <code>Shift</code> will type the text that corresponds to the <code>key</code> in the upper case.
If <code>key</code> is a single character, it is case-sensitive, so the values <code>a</code> and <code>A</code> will generate different respective texts.
Shortcuts such as <code>key: "Control+o"</code> or <code>key: "Control+Shift+T"</code> are supported as well. When speficied with the modifier, modifier is pressed and being held while the subsequent key is being pressed.
Shortcut for <code>keyboard.down</code> and <code>keyboard.up</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the key to press or a character to generate, such as <code>ArrowLeft</code> or <code>a</code>.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Time to wait between <code>keydown</code> and <code>keyup</code> in milliseconds. Defaults to 0.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def press(self, key: str, delay: int = None) -&gt; NoneType:
    &#34;&#34;&#34;Keyboard.press

    `key` can specify the intended keyboardEvent.key value or a single character to generate the text for. A superset of the `key` values can be found here. Examples of the keys are:
    `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`, `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.
    Following modification shortcuts are also suported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`.
    Holding down `Shift` will type the text that corresponds to the `key` in the upper case.
    If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective texts.
    Shortcuts such as `key: &#34;Control+o&#34;` or `key: &#34;Control+Shift+T&#34;` are supported as well. When speficied with the modifier, modifier is pressed and being held while the subsequent key is being pressed.
    Shortcut for `keyboard.down` and `keyboard.up`.

    Parameters
    ----------
    key : str
        Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
    delay : Optional[int]
        Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.press(key=key, delay=delay))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Keyboard.type"><code class="name flex">
<span>def <span class="ident">type</span></span>(<span>self, text: str, delay: int = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Keyboard.type</p>
<p>Sends a <code>keydown</code>, <code>keypress</code>/<code>input</code>, and <code>keyup</code> event for each character in the text.
To press a special key, like <code>Control</code> or <code>ArrowDown</code>, use <code>keyboard.press</code>.</p>
<p><strong>NOTE</strong> Modifier keys DO NOT effect <code>keyboard.type</code>. Holding down <code>Shift</code> will not type the text in upper case.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>A text to type into a focused element.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Time to wait between key presses in milliseconds. Defaults to 0.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def type(self, text: str, delay: int = None) -&gt; NoneType:
    &#34;&#34;&#34;Keyboard.type

    Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text.
    To press a special key, like `Control` or `ArrowDown`, use `keyboard.press`.

    **NOTE** Modifier keys DO NOT effect `keyboard.type`. Holding down `Shift` will not type the text in upper case.

    Parameters
    ----------
    text : str
        A text to type into a focused element.
    delay : Optional[int]
        Time to wait between key presses in milliseconds. Defaults to 0.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.type(text=text, delay=delay))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Keyboard.up"><code class="name flex">
<span>def <span class="ident">up</span></span>(<span>self, key: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Keyboard.up</p>
<p>Dispatches a <code>keyup</code> event.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the key to press or a character to generate, such as <code>ArrowLeft</code> or <code>a</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def up(self, key: str) -&gt; NoneType:
    &#34;&#34;&#34;Keyboard.up

    Dispatches a `keyup` event.

    Parameters
    ----------
    key : str
        Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.up(key=key)))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.sync_api.Mouse"><code class="flex name class">
<span>class <span class="ident">Mouse</span></span>
<span>(</span><span>obj: playwright.input.Mouse)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Mouse(SyncBase):
    def __init__(self, obj: MouseImpl):
        super().__init__(obj)

    def move(self, x: float, y: float, steps: int = None) -&gt; NoneType:
        &#34;&#34;&#34;Mouse.move

        Dispatches a `mousemove` event.

        Parameters
        ----------
        x : float
        y : float
        steps : Optional[int]
            defaults to 1. Sends intermediate `mousemove` events.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.move(x=x, y=y, steps=steps))
        )

    def down(
        self, button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None, clickCount: int = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;Mouse.down

        Dispatches a `mousedown` event.

        Parameters
        ----------
        button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
            Defaults to `left`.
        clickCount : Optional[int]
            defaults to 1. See UIEvent.detail.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.down(button=button, clickCount=clickCount))
        )

    def up(
        self, button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None, clickCount: int = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;Mouse.up

        Dispatches a `mouseup` event.

        Parameters
        ----------
        button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
            Defaults to `left`.
        clickCount : Optional[int]
            defaults to 1. See UIEvent.detail.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.up(button=button, clickCount=clickCount))
        )

    def click(
        self,
        x: float,
        y: float,
        delay: int = None,
        button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
        clickCount: int = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Mouse.click

        Shortcut for `mouse.move`, `mouse.down` and `mouse.up`.

        Parameters
        ----------
        x : float
        y : float
        delay : Optional[int]
            Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
        button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
            Defaults to `left`.
        clickCount : Optional[int]
            defaults to 1. See UIEvent.detail.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.click(
                    x=x, y=y, delay=delay, button=button, clickCount=clickCount
                )
            )
        )

    def dblclick(
        self,
        x: float,
        y: float,
        delay: int = None,
        button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Mouse.dblclick

        Shortcut for `mouse.move`, `mouse.down`, `mouse.up`, `mouse.down` and `mouse.up`.

        Parameters
        ----------
        x : float
        y : float
        delay : Optional[int]
            Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
        button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
            Defaults to `left`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.dblclick(x=x, y=y, delay=delay, button=button))
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright.sync_base.SyncBase</li>
<li>playwright.impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="playwright.sync_api.Mouse.click"><code class="name flex">
<span>def <span class="ident">click</span></span>(<span>self, x: float, y: float, delay: int = None, button: Literal['left', 'middle', 'right'] = None, clickCount: int = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Mouse.click</p>
<p>Shortcut for <code>mouse.move</code>, <code>mouse.down</code> and <code>mouse.up</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Time to wait between <code>mousedown</code> and <code>mouseup</code> in milliseconds. Defaults to 0.</dd>
<dt><strong><code>button</code></strong> :&ensp;<code>Optional[Literal['left', 'middle', 'right']]</code></dt>
<dd>Defaults to <code>left</code>.</dd>
<dt><strong><code>clickCount</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>defaults to 1. See UIEvent.detail.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def click(
    self,
    x: float,
    y: float,
    delay: int = None,
    button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
    clickCount: int = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Mouse.click

    Shortcut for `mouse.move`, `mouse.down` and `mouse.up`.

    Parameters
    ----------
    x : float
    y : float
    delay : Optional[int]
        Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
    button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
        Defaults to `left`.
    clickCount : Optional[int]
        defaults to 1. See UIEvent.detail.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.click(
                x=x, y=y, delay=delay, button=button, clickCount=clickCount
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Mouse.dblclick"><code class="name flex">
<span>def <span class="ident">dblclick</span></span>(<span>self, x: float, y: float, delay: int = None, button: Literal['left', 'middle', 'right'] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Mouse.dblclick</p>
<p>Shortcut for <code>mouse.move</code>, <code>mouse.down</code>, <code>mouse.up</code>, <code>mouse.down</code> and <code>mouse.up</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Time to wait between <code>mousedown</code> and <code>mouseup</code> in milliseconds. Defaults to 0.</dd>
<dt><strong><code>button</code></strong> :&ensp;<code>Optional[Literal['left', 'middle', 'right']]</code></dt>
<dd>Defaults to <code>left</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dblclick(
    self,
    x: float,
    y: float,
    delay: int = None,
    button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Mouse.dblclick

    Shortcut for `mouse.move`, `mouse.down`, `mouse.up`, `mouse.down` and `mouse.up`.

    Parameters
    ----------
    x : float
    y : float
    delay : Optional[int]
        Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
    button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
        Defaults to `left`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.dblclick(x=x, y=y, delay=delay, button=button))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Mouse.down"><code class="name flex">
<span>def <span class="ident">down</span></span>(<span>self, button: Literal['left', 'middle', 'right'] = None, clickCount: int = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Mouse.down</p>
<p>Dispatches a <code>mousedown</code> event.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>button</code></strong> :&ensp;<code>Optional[Literal['left', 'middle', 'right']]</code></dt>
<dd>Defaults to <code>left</code>.</dd>
<dt><strong><code>clickCount</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>defaults to 1. See UIEvent.detail.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def down(
    self, button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None, clickCount: int = None
) -&gt; NoneType:
    &#34;&#34;&#34;Mouse.down

    Dispatches a `mousedown` event.

    Parameters
    ----------
    button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
        Defaults to `left`.
    clickCount : Optional[int]
        defaults to 1. See UIEvent.detail.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.down(button=button, clickCount=clickCount))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Mouse.move"><code class="name flex">
<span>def <span class="ident">move</span></span>(<span>self, x: float, y: float, steps: int = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Mouse.move</p>
<p>Dispatches a <code>mousemove</code> event.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>steps</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>defaults to 1. Sends intermediate <code>mousemove</code> events.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move(self, x: float, y: float, steps: int = None) -&gt; NoneType:
    &#34;&#34;&#34;Mouse.move

    Dispatches a `mousemove` event.

    Parameters
    ----------
    x : float
    y : float
    steps : Optional[int]
        defaults to 1. Sends intermediate `mousemove` events.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.move(x=x, y=y, steps=steps))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Mouse.up"><code class="name flex">
<span>def <span class="ident">up</span></span>(<span>self, button: Literal['left', 'middle', 'right'] = None, clickCount: int = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Mouse.up</p>
<p>Dispatches a <code>mouseup</code> event.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>button</code></strong> :&ensp;<code>Optional[Literal['left', 'middle', 'right']]</code></dt>
<dd>Defaults to <code>left</code>.</dd>
<dt><strong><code>clickCount</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>defaults to 1. See UIEvent.detail.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def up(
    self, button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None, clickCount: int = None
) -&gt; NoneType:
    &#34;&#34;&#34;Mouse.up

    Dispatches a `mouseup` event.

    Parameters
    ----------
    button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
        Defaults to `left`.
    clickCount : Optional[int]
        defaults to 1. See UIEvent.detail.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.up(button=button, clickCount=clickCount))
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.sync_api.Page"><code class="flex name class">
<span>class <span class="ident">Page</span></span>
<span>(</span><span>obj: playwright.page.Page)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Page(SyncBase):
    def __init__(self, obj: PageImpl):
        super().__init__(obj)

    @property
    def accessibility(self) -&gt; &#34;Accessibility&#34;:
        &#34;&#34;&#34;Page.accessibility

        Returns
        -------
        Accessibility
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.accessibility)

    @property
    def keyboard(self) -&gt; &#34;Keyboard&#34;:
        &#34;&#34;&#34;Page.keyboard

        Returns
        -------
        Keyboard
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.keyboard)

    @property
    def mouse(self) -&gt; &#34;Mouse&#34;:
        &#34;&#34;&#34;Page.mouse

        Returns
        -------
        Mouse
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.mouse)

    @property
    def touchscreen(self) -&gt; &#34;Touchscreen&#34;:
        &#34;&#34;&#34;Page.touchscreen

        Returns
        -------
        Touchscreen
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.touchscreen)

    @property
    def context(self) -&gt; &#34;BrowserContext&#34;:
        &#34;&#34;&#34;Page.context

        Get the browser context that the page belongs to.

        Returns
        -------
        BrowserContext
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.context)

    @property
    def mainFrame(self) -&gt; &#34;Frame&#34;:
        &#34;&#34;&#34;Page.mainFrame

        Page is guaranteed to have a main frame which persists during navigations.

        Returns
        -------
        Frame
            The page&#39;s main frame.
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.mainFrame)

    @property
    def frames(self) -&gt; typing.List[&#34;Frame&#34;]:
        &#34;&#34;&#34;Page.frames

        Returns
        -------
        List[Frame]
            An array of all frames attached to the page.
        &#34;&#34;&#34;
        return mapping.from_impl_list(self._impl_obj.frames)

    @property
    def url(self) -&gt; str:
        &#34;&#34;&#34;Page.url

        This is a shortcut for page.mainFrame().url()

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.url)

    @property
    def workers(self) -&gt; typing.List[&#34;Worker&#34;]:
        &#34;&#34;&#34;Page.workers

        **NOTE** This does not contain ServiceWorkers

        Returns
        -------
        List[Worker]
            This method returns all of the dedicated WebWorkers associated with the page.
        &#34;&#34;&#34;
        return mapping.from_impl_list(self._impl_obj.workers)

    @property
    def video(self) -&gt; typing.Union[&#34;Video&#34;, NoneType]:
        &#34;&#34;&#34;Page.video

        Video object associated with this page.

        Returns
        -------
        Optional[Video]
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._impl_obj.video)

    def opener(self) -&gt; typing.Union[&#34;Page&#34;, NoneType]:
        &#34;&#34;&#34;Page.opener

        Returns
        -------
        Optional[Page]
            Promise which resolves to the opener for popup pages and `null` for others. If the opener has been closed already the promise may resolve to `null`.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._sync(self._impl_obj.opener()))

    def frame(
        self,
        name: str = None,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
    ) -&gt; typing.Union[&#34;Frame&#34;, NoneType]:
        &#34;&#34;&#34;Page.frame

        Returns frame matching the specified criteria. Either `name` or `url` must be specified.

        Parameters
        ----------
        name : Optional[str]
            frame name specified in the `iframe`&#39;s `name` attribute
        url : Union[str, Pattern, typing.Callable[[str], bool], NoneType]
            A glob pattern, regex pattern or predicate receiving frame&#39;s `url` as a URL object.

        Returns
        -------
        Optional[Frame]
            frame matching the criteria. Returns `null` if no frame matches.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._impl_obj.frame(name=name, url=self._wrap_handler(url))
        )

    def setDefaultNavigationTimeout(self, timeout: int) -&gt; NoneType:
        &#34;&#34;&#34;Page.setDefaultNavigationTimeout

        This setting will change the default maximum navigation time for the following methods and related shortcuts:

        page.goBack([options])
        page.goForward([options])
        page.goto(url[, options])
        page.reload([options])
        page.setContent(html[, options])
        page.waitForNavigation([options])

        **NOTE** `page.setDefaultNavigationTimeout` takes priority over `page.setDefaultTimeout`, `browserContext.setDefaultTimeout` and `browserContext.setDefaultNavigationTimeout`.

        Parameters
        ----------
        timeout : int
            Maximum navigation time in milliseconds
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._impl_obj.setDefaultNavigationTimeout(timeout=timeout)
        )

    def setDefaultTimeout(self, timeout: int) -&gt; NoneType:
        &#34;&#34;&#34;Page.setDefaultTimeout

        This setting will change the default maximum time for all the methods accepting `timeout` option.

        **NOTE** `page.setDefaultNavigationTimeout` takes priority over `page.setDefaultTimeout`.

        Parameters
        ----------
        timeout : int
            Maximum time in milliseconds
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._impl_obj.setDefaultTimeout(timeout=timeout)
        )

    def querySelector(self, selector: str) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
        &#34;&#34;&#34;Page.querySelector

        The method finds an element matching the specified selector within the page. If no elements match the selector, the return value resolves to `null`.
        Shortcut for page.mainFrame().$(selector).

        Parameters
        ----------
        selector : str
            A selector to query page for. See working with selectors for more details.

        Returns
        -------
        Optional[ElementHandle]
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._sync(self._impl_obj.querySelector(selector=selector))
        )

    def querySelectorAll(self, selector: str) -&gt; typing.List[&#34;ElementHandle&#34;]:
        &#34;&#34;&#34;Page.querySelectorAll

        The method finds all elements matching the specified selector within the page. If no elements match the selector, the return value resolves to `[]`.
        Shortcut for page.mainFrame().$$(selector).

        Parameters
        ----------
        selector : str
            A selector to query page for. See working with selectors for more details.

        Returns
        -------
        List[ElementHandle]
        &#34;&#34;&#34;
        return mapping.from_impl_list(
            self._sync(self._impl_obj.querySelectorAll(selector=selector))
        )

    def waitForSelector(
        self,
        selector: str,
        timeout: int = None,
        state: Literal[&#34;attached&#34;, &#34;detached&#34;, &#34;hidden&#34;, &#34;visible&#34;] = None,
    ) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
        &#34;&#34;&#34;Page.waitForSelector

        Wait for the `selector` to satisfy `state` option (either appear/disappear from dom, or become visible/hidden). If at the moment of calling the method `selector` already satisfies the condition, the method will return immediately. If the selector doesn&#39;t satisfy the condition for the `timeout` milliseconds, the function will throw.
        This method works across navigations:

        Shortcut for page.mainFrame().waitForSelector(selector[, options]).

        Parameters
        ----------
        selector : str
            A selector of an element to wait for. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        state : Optional[Literal[&#39;attached&#39;, &#39;detached&#39;, &#39;hidden&#39;, &#39;visible&#39;]]
            Defaults to `&#39;visible&#39;`. Can be either:
             - `&#39;attached&#39;` - wait for element to be present in DOM.
             - `&#39;detached&#39;` - wait for element to not be present in DOM.
             - `&#39;visible&#39;` - wait for element to have non-empty bounding box and no `visibility:hidden`. Note that element without any content or with `display:none` has an empty bounding box and is not considered visible.
             - `&#39;hidden&#39;` - wait for element to be either detached from DOM, or have an empty bounding box or `visibility:hidden`. This is opposite to the `&#39;visible&#39;` option.

        Returns
        -------
        Optional[ElementHandle]
            Promise which resolves when element specified by selector satisfies `state` option. Resolves to `null` if waiting for `hidden` or `detached`.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._sync(
                self._impl_obj.waitForSelector(
                    selector=selector, timeout=timeout, state=state
                )
            )
        )

    def dispatchEvent(
        self,
        selector: str,
        type: str,
        eventInit: typing.Dict = None,
        timeout: int = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.dispatchEvent

        The snippet below dispatches the `click` event on the element. Regardless of the visibility state of the elment, `click` is dispatched. This is equivalend to calling `element.click()`.
        Under the hood, it creates an instance of an event based on the given `type`, initializes it with `eventInit` properties and dispatches it on the element. Events are `composed`, `cancelable` and bubble by default.
        Since `eventInit` is event-specific, please refer to the events documentation for the lists of initial properties:

        DragEvent
        FocusEvent
        KeyboardEvent
        MouseEvent
        PointerEvent
        TouchEvent
        Event

        You can also specify `JSHandle` as the property value if you want live objects to be passed into the event:

        Parameters
        ----------
        selector : str
            A selector to search for element to use. If there are multiple elements satisfying the selector, the first will be used. See working with selectors for more details.
        type : str
            DOM event type: `&#34;click&#34;`, `&#34;dragstart&#34;`, etc.
        eventInit : Optional[Dict]
            event-specific initialization properties.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.dispatchEvent(
                    selector=selector,
                    type=type,
                    eventInit=mapping.to_impl(eventInit),
                    timeout=timeout,
                )
            )
        )

    def evaluate(
        self, expression: str, arg: typing.Any = None, force_expr: bool = None
    ) -&gt; typing.Any:
        &#34;&#34;&#34;Page.evaluate

        If the function passed to the `page.evaluate` returns a Promise, then `page.evaluate` would wait for the promise to resolve and return its value.
        If the function passed to the `page.evaluate` returns a non-Serializable value, then `page.evaluate` resolves to `undefined`. DevTools Protocol also supports transferring some additional values that are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and bigint literals.
        Passing argument to `pageFunction`:
        A string can also be passed in instead of a function:
        ElementHandle instances can be passed as an argument to the `page.evaluate`:
        Shortcut for page.mainFrame().evaluate(pageFunction[, arg]).

        Parameters
        ----------
        expression : str
            Function to be evaluated in the page context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        Any
            Promise which resolves to the return value of `pageFunction`
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.evaluate(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )

    def evaluateHandle(
        self, expression: str, arg: typing.Any = None, force_expr: bool = None
    ) -&gt; &#34;JSHandle&#34;:
        &#34;&#34;&#34;Page.evaluateHandle

        The only difference between `page.evaluate` and `page.evaluateHandle` is that `page.evaluateHandle` returns in-page object (JSHandle).
        If the function passed to the `page.evaluateHandle` returns a Promise, then `page.evaluateHandle` would wait for the promise to resolve and return its value.
        A string can also be passed in instead of a function:
        JSHandle instances can be passed as an argument to the `page.evaluateHandle`:

        Parameters
        ----------
        expression : str
            Function to be evaluated in the page context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        JSHandle
            Promise which resolves to the return value of `pageFunction` as in-page object (JSHandle)
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.evaluateHandle(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )

    def evalOnSelector(
        self,
        selector: str,
        expression: str,
        arg: typing.Any = None,
        force_expr: bool = None,
    ) -&gt; typing.Any:
        &#34;&#34;&#34;Page.evalOnSelector

        The method finds an element matching the specified selector within the page and passes it as a first argument to `pageFunction`. If no elements match the selector, the method throws an error.
        If `pageFunction` returns a Promise, then `page.$eval` would wait for the promise to resolve and return its value.
        Examples:
        Shortcut for page.mainFrame().$eval(selector, pageFunction).

        Parameters
        ----------
        selector : str
            A selector to query page for. See working with selectors for more details.
        expression : str
            Function to be evaluated in browser context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        Any
            Promise which resolves to the return value of `pageFunction`
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.evalOnSelector(
                    selector=selector,
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )

    def evalOnSelectorAll(
        self,
        selector: str,
        expression: str,
        arg: typing.Any = None,
        force_expr: bool = None,
    ) -&gt; typing.Any:
        &#34;&#34;&#34;Page.evalOnSelectorAll

        The method finds all elements matching the specified selector within the page and passes an array of matched elements as a first argument to `pageFunction`.
        If `pageFunction` returns a Promise, then `page.$$eval` would wait for the promise to resolve and return its value.
        Examples:

        Parameters
        ----------
        selector : str
            A selector to query page for. See working with selectors for more details.
        expression : str
            Function to be evaluated in browser context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        Any
            Promise which resolves to the return value of `pageFunction`
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.evalOnSelectorAll(
                    selector=selector,
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )

    def addScriptTag(
        self,
        url: str = None,
        path: typing.Union[str, pathlib.Path] = None,
        content: str = None,
        type: str = None,
    ) -&gt; &#34;ElementHandle&#34;:
        &#34;&#34;&#34;Page.addScriptTag

        Adds a `&lt;script&gt;` tag into the page with the desired url or content.
        Shortcut for page.mainFrame().addScriptTag(options).

        Parameters
        ----------
        url : Optional[str]
            URL of a script to be added.
        path : Union[str, pathlib.Path, NoneType]
            Path to the JavaScript file to be injected into frame. If `path` is a relative path, then it is resolved relative to current working directory.
        content : Optional[str]
            Raw JavaScript content to be injected into frame.
        type : Optional[str]
            Script type. Use &#39;module&#39; in order to load a Javascript ES6 module. See script for more details.

        Returns
        -------
        ElementHandle
            which resolves to the added tag when the script&#39;s onload fires or when the script content was injected into frame.
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.addScriptTag(
                    url=url, path=path, content=content, type=type
                )
            )
        )

    def addStyleTag(
        self,
        url: str = None,
        path: typing.Union[str, pathlib.Path] = None,
        content: str = None,
    ) -&gt; &#34;ElementHandle&#34;:
        &#34;&#34;&#34;Page.addStyleTag

        Adds a `&lt;link rel=&#34;stylesheet&#34;&gt;` tag into the page with the desired url or a `&lt;style type=&#34;text/css&#34;&gt;` tag with the content.
        Shortcut for page.mainFrame().addStyleTag(options).

        Parameters
        ----------
        url : Optional[str]
            URL of the `&lt;link&gt;` tag.
        path : Union[str, pathlib.Path, NoneType]
            Path to the CSS file to be injected into frame. If `path` is a relative path, then it is resolved relative to current working directory.
        content : Optional[str]
            Raw CSS content to be injected into frame.

        Returns
        -------
        ElementHandle
            which resolves to the added tag when the stylesheet&#39;s onload fires or when the CSS content was injected into frame.
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(self._impl_obj.addStyleTag(url=url, path=path, content=content))
        )

    def exposeFunction(self, name: str, binding: typing.Callable) -&gt; NoneType:
        &#34;&#34;&#34;Page.exposeFunction

        The method adds a function called `name` on the `window` object of every frame in the page.
        When called, the function executes `playwrightFunction` in Node.js and returns a Promise which resolves to the return value of `playwrightFunction`.
        If the `playwrightFunction` returns a Promise, it will be awaited.
        See browserContext.exposeFunction(name, playwrightFunction) for context-wide exposed function.

        **NOTE** Functions installed via `page.exposeFunction` survive navigations.

        An example of adding an `md5` function to the page:

        An example of adding a `window.readfile` function to the page:

        Parameters
        ----------
        name : str
            Name of the function on the window object
        binding : Callable
            Callback function which will be called in Playwright&#39;s context.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.exposeFunction(
                    name=name, binding=self._wrap_handler(binding)
                )
            )
        )

    def exposeBinding(
        self, name: str, binding: typing.Callable, handle: bool = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.exposeBinding

        The method adds a function called `name` on the `window` object of every frame in this page.
        When called, the function executes `playwrightBinding` in Node.js and returns a Promise which resolves to the return value of `playwrightBinding`.
        If the `playwrightBinding` returns a Promise, it will be awaited.
        The first argument of the `playwrightBinding` function contains information about the caller:
        `{ browserContext: BrowserContext, page: Page, frame: Frame }`.
        See browserContext.exposeBinding(name, playwrightBinding) for the context-wide version.

        **NOTE** Functions installed via `page.exposeBinding` survive navigations.

        An example of exposing page URL to all frames in a page:

        An example of passing an element handle:

        Parameters
        ----------
        name : str
            Name of the function on the window object.
        binding : Callable
            Callback function that will be called in the Playwright&#39;s context.
        handle : Optional[bool]
            Whether to pass the argument as a handle, instead of passing by value. When passing a handle, only one argument is supported. When passing by value, multiple arguments are supported.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.exposeBinding(
                    name=name, binding=self._wrap_handler(binding), handle=handle
                )
            )
        )

    def setExtraHTTPHeaders(self, headers: typing.Dict[str, str]) -&gt; NoneType:
        &#34;&#34;&#34;Page.setExtraHTTPHeaders

        The extra HTTP headers will be sent with every request the page initiates.

        **NOTE** page.setExtraHTTPHeaders does not guarantee the order of headers in the outgoing requests.

        Parameters
        ----------
        headers : Dict[str, str]
            An object containing additional HTTP headers to be sent with every request. All header values must be strings.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.setExtraHTTPHeaders(headers=mapping.to_impl(headers))
            )
        )

    def content(self) -&gt; str:
        &#34;&#34;&#34;Page.content

        Gets the full HTML contents of the page, including the doctype.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.content()))

    def setContent(
        self,
        html: str,
        timeout: int = None,
        waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.setContent

        Parameters
        ----------
        html : str
            HTML markup to assign to the page.
        timeout : Optional[int]
            Maximum time in milliseconds for resources to load, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        waitUntil : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
            When to consider setting markup succeeded, defaults to `load`. Given an array of event strings, setting content is considered to be successful after all events have been fired. Events can be either:
             - `&#39;load&#39;` - consider setting content to be finished when the `load` event is fired.
             - `&#39;domcontentloaded&#39;` - consider setting content to be finished when the `DOMContentLoaded` event is fired.
             - `&#39;networkidle&#39;` - consider setting content to be finished when there are no network connections for at least `500` ms.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.setContent(
                    html=html, timeout=timeout, waitUntil=waitUntil
                )
            )
        )

    def goto(
        self,
        url: str,
        timeout: int = None,
        waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        referer: str = None,
    ) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
        &#34;&#34;&#34;Page.goto

        `page.goto` will throw an error if:

        there&#39;s an SSL error (e.g. in case of self-signed certificates).
        target URL is invalid.
        the `timeout` is exceeded during navigation.
        the remote server does not respond or is unreachable.
        the main resource failed to load.

        `page.goto` will not throw an error when any valid HTTP status code is returned by the remote server, including 404 &#34;Not Found&#34; and 500 &#34;Internal Server Error&#34;.  The status code for such responses can be retrieved by calling response.status().

        **NOTE** `page.goto` either throws an error or returns a main resource response. The only exceptions are navigation to `about:blank` or navigation to the same URL with a different hash, which would succeed and return `null`.

        **NOTE** Headless mode doesn&#39;t support navigation to a PDF document. See the upstream issue.

        Shortcut for page.mainFrame().goto(url[, options])

        Parameters
        ----------
        url : str
            URL to navigate page to. The url should include scheme, e.g. `https://`.
        timeout : Optional[int]
            Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        waitUntil : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
            When to consider navigation succeeded, defaults to `load`. Events can be either:
             - `&#39;domcontentloaded&#39;` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
             - `&#39;load&#39;` - consider navigation to be finished when the `load` event is fired.
             - `&#39;networkidle&#39;` - consider navigation to be finished when there are no network connections for at least `500` ms.
        referer : Optional[str]
            Referer header value. If provided it will take preference over the referer header value set by page.setExtraHTTPHeaders().

        Returns
        -------
        Optional[Response]
            Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._sync(
                self._impl_obj.goto(
                    url=url, timeout=timeout, waitUntil=waitUntil, referer=referer
                )
            )
        )

    def reload(
        self,
        timeout: int = None,
        waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    ) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
        &#34;&#34;&#34;Page.reload

        Parameters
        ----------
        timeout : Optional[int]
            Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        waitUntil : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
            When to consider navigation succeeded, defaults to `load`. Events can be either:
             - `&#39;domcontentloaded&#39;` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
             - `&#39;load&#39;` - consider navigation to be finished when the `load` event is fired.
             - `&#39;networkidle&#39;` - consider navigation to be finished when there are no network connections for at least `500` ms.

        Returns
        -------
        Optional[Response]
            Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._sync(self._impl_obj.reload(timeout=timeout, waitUntil=waitUntil))
        )

    def waitForLoadState(
        self,
        state: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        timeout: int = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.waitForLoadState

        This resolves when the page reaches a required load state, `load` by default. The navigation must have been committed when this method is called. If current document has already reached the required state, resolves immediately.
        Shortcut for page.mainFrame().waitForLoadState([options]).

        Parameters
        ----------
        state : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
            Load state to wait for, defaults to `load`. If the state has been already reached while loading current document, the method resolves immediately.
             - `&#39;load&#39;` - wait for the `load` event to be fired.
             - `&#39;domcontentloaded&#39;` - wait for the `DOMContentLoaded` event to be fired.
             - `&#39;networkidle&#39;` - wait until there are no network connections for at least `500` ms.
        timeout : Optional[int]
            Maximum waiting time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.waitForLoadState(state=state, timeout=timeout))
        )

    def waitForNavigation(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
        waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        timeout: int = None,
    ) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
        &#34;&#34;&#34;Page.waitForNavigation

        This resolves when the page navigates to a new URL or reloads. It is useful for when you run code
        which will indirectly cause the page to navigate. e.g. The click target has an `onclick` handler that triggers navigation from a `setTimeout`. Consider this example:
        **NOTE** Usage of the History API to change the URL is considered a navigation.
        Shortcut for page.mainFrame().waitForNavigation(options).

        Parameters
        ----------
        url : Union[str, Pattern, typing.Callable[[str], bool], NoneType]
            A glob pattern, regex pattern or predicate receiving URL to match while waiting for the navigation.
        waitUntil : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
            When to consider navigation succeeded, defaults to `load`. Events can be either:
             - `&#39;domcontentloaded&#39;` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
             - `&#39;load&#39;` - consider navigation to be finished when the `load` event is fired.
             - `&#39;networkidle&#39;` - consider navigation to be finished when there are no network connections for at least `500` ms.
        timeout : Optional[int]
            Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

        Returns
        -------
        Optional[Response]
            Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect. In case of navigation to a different anchor or navigation due to History API usage, the navigation will resolve with `null`.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._sync(
                self._impl_obj.waitForNavigation(
                    url=self._wrap_handler(url), waitUntil=waitUntil, timeout=timeout
                )
            )
        )

    def waitForRequest(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
        predicate: typing.Union[typing.Callable[[&#34;Request&#34;], bool]] = None,
        timeout: int = None,
    ) -&gt; &#34;Request&#34;:
        &#34;&#34;&#34;Page.waitForRequest


        Parameters
        ----------
        url : Union[str, Pattern, typing.Callable[[str], bool], NoneType]
            Request URL string, regex or predicate receiving Request object.
        timeout : Optional[int]
            Maximum wait time in milliseconds, defaults to 30 seconds, pass `0` to disable the timeout. The default value can be changed by using the page.setDefaultTimeout(timeout) method.

        Returns
        -------
        Request
            Promise which resolves to the matched request.
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.waitForRequest(
                    url=self._wrap_handler(url),
                    predicate=self._wrap_handler(predicate),
                    timeout=timeout,
                )
            )
        )

    def waitForResponse(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
        predicate: typing.Union[typing.Callable[[&#34;Response&#34;], bool]] = None,
        timeout: int = None,
    ) -&gt; &#34;Response&#34;:
        &#34;&#34;&#34;Page.waitForResponse


        Parameters
        ----------
        url : Union[str, Pattern, typing.Callable[[str], bool], NoneType]
            Request URL string, regex or predicate receiving Response object.
        timeout : Optional[int]
            Maximum wait time in milliseconds, defaults to 30 seconds, pass `0` to disable the timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

        Returns
        -------
        Response
            Promise which resolves to the matched response.
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.waitForResponse(
                    url=self._wrap_handler(url),
                    predicate=self._wrap_handler(predicate),
                    timeout=timeout,
                )
            )
        )

    def waitForEvent(
        self,
        event: str,
        predicate: typing.Union[typing.Callable[[typing.Any], bool]] = None,
        timeout: int = None,
    ) -&gt; typing.Any:
        &#34;&#34;&#34;Page.waitForEvent

        Waits for event to fire and passes its value into the predicate function. Resolves when the predicate returns truthy value. Will throw an error if the page is closed before the event
        is fired.

        Parameters
        ----------
        event : str
            Event name, same one would pass into `page.on(event)`.

        Returns
        -------
        Any
            Promise which resolves to the event data value.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.waitForEvent(
                    event=event,
                    predicate=self._wrap_handler(predicate),
                    timeout=timeout,
                )
            )
        )

    def goBack(
        self,
        timeout: int = None,
        waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    ) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
        &#34;&#34;&#34;Page.goBack

        Navigate to the previous page in history.

        Parameters
        ----------
        timeout : Optional[int]
            Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        waitUntil : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
            When to consider navigation succeeded, defaults to `load`. Events can be either:
             - `&#39;domcontentloaded&#39;` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
             - `&#39;load&#39;` - consider navigation to be finished when the `load` event is fired.
             - `&#39;networkidle&#39;` - consider navigation to be finished when there are no network connections for at least `500` ms.

        Returns
        -------
        Optional[Response]
            Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect. If
              can not go back, resolves to `null`.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._sync(self._impl_obj.goBack(timeout=timeout, waitUntil=waitUntil))
        )

    def goForward(
        self,
        timeout: int = None,
        waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    ) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
        &#34;&#34;&#34;Page.goForward

        Navigate to the next page in history.

        Parameters
        ----------
        timeout : Optional[int]
            Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        waitUntil : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
            When to consider navigation succeeded, defaults to `load`. Events can be either:
             - `&#39;domcontentloaded&#39;` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
             - `&#39;load&#39;` - consider navigation to be finished when the `load` event is fired.
             - `&#39;networkidle&#39;` - consider navigation to be finished when there are no network connections for at least `500` ms.

        Returns
        -------
        Optional[Response]
            Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect. If
              can not go forward, resolves to `null`.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(
            self._sync(self._impl_obj.goForward(timeout=timeout, waitUntil=waitUntil))
        )

    def emulateMedia(
        self,
        media: Literal[&#34;print&#34;, &#34;screen&#34;] = None,
        colorScheme: Literal[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;] = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.emulateMedia


        Parameters
        ----------
        media : Optional[Literal[&#39;print&#39;, &#39;screen&#39;]]
            Changes the CSS media type of the page. The only allowed values are `&#39;screen&#39;`, `&#39;print&#39;` and `null`. Passing `null` disables CSS media emulation. Omitting `media` or passing `undefined` does not change the emulated value.
        colorScheme : Optional[Literal[&#39;dark&#39;, &#39;light&#39;, &#39;no-preference&#39;]]
            Emulates `&#39;prefers-colors-scheme&#39;` media feature, supported values are `&#39;light&#39;`, `&#39;dark&#39;`, `&#39;no-preference&#39;`. Passing `null` disables color scheme emulation. Omitting `colorScheme` or passing `undefined` does not change the emulated value.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.emulateMedia(media=media, colorScheme=colorScheme)
            )
        )

    def setViewportSize(self, width: int, height: int) -&gt; NoneType:
        &#34;&#34;&#34;Page.setViewportSize

        In the case of multiple pages in a single browser, each page can have its own viewport size. However, browser.newContext([options]) allows to set viewport size (and more) for all pages in the context at once.
        `page.setViewportSize` will resize the page. A lot of websites don&#39;t expect phones to change size, so you should set the viewport size before navigating to the page.

        Parameters
        ----------
        width : int
            page width in pixels. **required**
        height : int
            page height in pixels. **required**
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.setViewportSize(width=width, height=height))
        )

    def viewportSize(self) -&gt; typing.Union[Viewport, NoneType]:
        &#34;&#34;&#34;Page.viewportSize

        Returns
        -------
        Optional[{&#34;width&#34;: int, &#34;height&#34;: int}]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.viewportSize())

    def bringToFront(self) -&gt; NoneType:
        &#34;&#34;&#34;Page.bringToFront

        Brings page to front (activates tab).
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.bringToFront()))

    def addInitScript(
        self, source: str = None, path: typing.Union[str, pathlib.Path] = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.addInitScript

        Adds a script which would be evaluated in one of the following scenarios:

        Whenever the page is navigated.
        Whenever the child frame is attached or navigated. In this case, the script is evaluated in the context of the newly attached frame.

        The script is evaluated after the document was created but before any of its scripts were run. This is useful to amend  the JavaScript environment, e.g. to seed `Math.random`.
        An example of overriding `Math.random` before the page loads:

        **NOTE** The order of evaluation of multiple scripts installed via browserContext.addInitScript(script[, arg]) and page.addInitScript(script[, arg]) is not defined.

        Parameters
        ----------
        source : Optional[str]
            Script to be evaluated in the page.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.addInitScript(source=source, path=path))
        )

    def route(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]],
        handler: typing.Callable[[&#34;Route&#34;, &#34;Request&#34;], typing.Any],
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.route

        Routing provides the capability to modify network requests that are made by a page.
        Once routing is enabled, every request matching the url pattern will stall unless it&#39;s continued, fulfilled or aborted.

        **NOTE** The handler will only be called for the first url if the response is a redirect.

        An example of a naïve handler that aborts all image requests:
        or the same snippet using a regex pattern instead:
        Page routes take precedence over browser context routes (set up with browserContext.route(url, handler)) when request matches both handlers.

        **NOTE** Enabling routing disables http cache.

        Parameters
        ----------
        url : Union[str, Pattern, typing.Callable[[str], bool]]
            A glob pattern, regex pattern or predicate receiving URL to match while routing.
        handler : typing.Callable[[playwright.network.Route, playwright.network.Request], typing.Any]
            handler function to route the request.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.route(
                    url=self._wrap_handler(url), handler=self._wrap_handler(handler)
                )
            )
        )

    def unroute(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]],
        handler: typing.Union[typing.Callable[[&#34;Route&#34;, &#34;Request&#34;], typing.Any]] = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.unroute

        Removes a route created with page.route(url, handler). When `handler` is not specified, removes all routes for the `url`.

        Parameters
        ----------
        url : Union[str, Pattern, typing.Callable[[str], bool]]
            A glob pattern, regex pattern or predicate receiving URL to match while routing.
        handler : Optional[typing.Callable[[playwright.network.Route, playwright.network.Request], typing.Any]]
            Handler function to route the request.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.unroute(
                    url=self._wrap_handler(url), handler=self._wrap_handler(handler)
                )
            )
        )

    def screenshot(
        self,
        timeout: int = None,
        type: Literal[&#34;jpeg&#34;, &#34;png&#34;] = None,
        path: typing.Union[str, pathlib.Path] = None,
        quality: int = None,
        omitBackground: bool = None,
        fullPage: bool = None,
        clip: FloatRect = None,
    ) -&gt; bytes:
        &#34;&#34;&#34;Page.screenshot

        **NOTE** Screenshots take at least 1/6 second on Chromium OS X and Chromium Windows. See https://crbug.com/741689 for discussion.

        Parameters
        ----------
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        type : Optional[Literal[&#39;jpeg&#39;, &#39;png&#39;]]
            Specify screenshot type, defaults to `png`.
        path : Union[str, pathlib.Path, NoneType]
            The file path to save the image to. The screenshot type will be inferred from file extension. If `path` is a relative path, then it is resolved relative to current working directory. If no path is provided, the image won&#39;t be saved to the disk.
        quality : Optional[int]
            The quality of the image, between 0-100. Not applicable to `png` images.
        omitBackground : Optional[bool]
            Hides default white background and allows capturing screenshots with transparency. Not applicable to `jpeg` images. Defaults to `false`.
        fullPage : Optional[bool]
            When true, takes a screenshot of the full scrollable page, instead of the currently visible viewport. Defaults to `false`.
        clip : Optional[{&#34;x&#34;: float, &#34;y&#34;: float, &#34;width&#34;: float, &#34;height&#34;: float}]
            An object which specifies clipping of the resulting image. Should have the following fields:

        Returns
        -------
        bytes
            Promise which resolves to buffer with the captured screenshot.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.screenshot(
                    timeout=timeout,
                    type=type,
                    path=path,
                    quality=quality,
                    omitBackground=omitBackground,
                    fullPage=fullPage,
                    clip=clip,
                )
            )
        )

    def title(self) -&gt; str:
        &#34;&#34;&#34;Page.title

        Shortcut for page.mainFrame().title().

        Returns
        -------
        str
            The page&#39;s title.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.title()))

    def close(self, runBeforeUnload: bool = None) -&gt; NoneType:
        &#34;&#34;&#34;Page.close

        If `runBeforeUnload` is `false` the result will resolve only after the page has been closed.
        If `runBeforeUnload` is `true` the method will **not** wait for the page to close.
        By default, `page.close()` **does not** run beforeunload handlers.

        **NOTE** if `runBeforeUnload` is passed as true, a `beforeunload` dialog might be summoned
        and should be handled manually via page&#39;s &#39;dialog&#39; event.

        Parameters
        ----------
        runBeforeUnload : Optional[bool]
            Defaults to `false`. Whether to run the
            before unload
            page handlers.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.close(runBeforeUnload=runBeforeUnload))
        )

    def isClosed(self) -&gt; bool:
        &#34;&#34;&#34;Page.isClosed

        Indicates that the page has been closed.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.isClosed())

    def click(
        self,
        selector: str,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: MousePosition = None,
        delay: int = None,
        button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
        clickCount: int = None,
        timeout: int = None,
        force: bool = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.click

        This method clicks an element matching `selector` by performing the following steps:

        Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
        Scroll the element into view if needed.
        Use page.mouse to click in the center of the element, or the specified `position`.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.
        Shortcut for page.mainFrame().click(selector[, options]).

        Parameters
        ----------
        selector : str
            A selector to search for element to click. If there are multiple elements satisfying the selector, the first will be clicked. See working with selectors for more details.
        modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
            Modifier keys to press. Ensures that only these modifiers are pressed during the click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
        position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
            A point to click relative to the top-left corner of element padding box. If not specified, clicks to some visible point of the element.
        delay : Optional[int]
            Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
        button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
            Defaults to `left`.
        clickCount : Optional[int]
            defaults to 1. See UIEvent.detail.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.click(
                    selector=selector,
                    modifiers=modifiers,
                    position=position,
                    delay=delay,
                    button=button,
                    clickCount=clickCount,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def dblclick(
        self,
        selector: str,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: MousePosition = None,
        delay: int = None,
        button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
        timeout: int = None,
        force: bool = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.dblclick

        This method double clicks an element matching `selector` by performing the following steps:

        Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
        Scroll the element into view if needed.
        Use page.mouse to double click in the center of the element, or the specified `position`.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set. Note that if the first click of the `dblclick()` triggers a navigation event, this method will reject.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        **NOTE** `page.dblclick()` dispatches two `click` events and a single `dblclick` event.

        Shortcut for page.mainFrame().dblclick(selector[, options]).

        Parameters
        ----------
        selector : str
            A selector to search for element to double click. If there are multiple elements satisfying the selector, the first will be double clicked. See working with selectors for more details.
        modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
            Modifier keys to press. Ensures that only these modifiers are pressed during the double click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
        position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
            A point to double click relative to the top-left corner of element padding box. If not specified, double clicks to some visible point of the element.
        delay : Optional[int]
            Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
        button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
            Defaults to `left`.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.dblclick(
                    selector=selector,
                    modifiers=modifiers,
                    position=position,
                    delay=delay,
                    button=button,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def tap(
        self,
        selector: str,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: MousePosition = None,
        timeout: int = None,
        force: bool = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.tap

        This method taps an element matching `selector` by performing the following steps:

        Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
        Scroll the element into view if needed.
        Use page.touchscreen to tap the center of the element, or the specified `position`.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

        **NOTE** `page.tap()` requires that the `hasTouch` option of the browser context be set to true.

        Shortcut for page.mainFrame().tap().

        Parameters
        ----------
        selector : str
            A selector to search for element to tap. If there are multiple elements satisfying the selector, the first will be tapped. See working with selectors for more details.
        modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
            Modifier keys to press. Ensures that only these modifiers are pressed during the tap, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
        position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
            A point to tap relative to the top-left corner of element padding box. If not specified, taps some visible point of the element.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.tap(
                    selector=selector,
                    modifiers=modifiers,
                    position=position,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def fill(
        self, selector: str, value: str, timeout: int = None, noWaitAfter: bool = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.fill

        This method waits for an element matching `selector`, waits for actionability checks, focuses the element, fills it and triggers an `input` event after filling.
        If the element matching `selector` is not an `&lt;input&gt;`, `&lt;textarea&gt;` or `[contenteditable]` element, this method throws an error.
        Note that you can pass an empty string to clear the input field.
        To send fine-grained keyboard events, use `page.type`.
        Shortcut for page.mainFrame().fill()

        Parameters
        ----------
        selector : str
            A selector to query page for. See working with selectors for more details.
        value : str
            Value to fill for the `&lt;input&gt;`, `&lt;textarea&gt;` or `[contenteditable]` element.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.fill(
                    selector=selector,
                    value=value,
                    timeout=timeout,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def focus(self, selector: str, timeout: int = None) -&gt; NoneType:
        &#34;&#34;&#34;Page.focus

        This method fetches an element with `selector` and focuses it.
        If there&#39;s no element matching `selector`, the method waits until a matching element appears in the DOM.
        Shortcut for page.mainFrame().focus(selector).

        Parameters
        ----------
        selector : str
            A selector of an element to focus. If there are multiple elements satisfying the selector, the first will be focused. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.focus(selector=selector, timeout=timeout))
        )

    def textContent(
        self, selector: str, timeout: int = None
    ) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;Page.textContent

        Resolves to the `element.textContent`.

        Parameters
        ----------
        selector : str
            A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

        Returns
        -------
        Optional[str]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.textContent(selector=selector, timeout=timeout))
        )

    def innerText(self, selector: str, timeout: int = None) -&gt; str:
        &#34;&#34;&#34;Page.innerText

        Resolves to the `element.innerText`.

        Parameters
        ----------
        selector : str
            A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.innerText(selector=selector, timeout=timeout))
        )

    def innerHTML(self, selector: str, timeout: int = None) -&gt; str:
        &#34;&#34;&#34;Page.innerHTML

        Resolves to the `element.innerHTML`.

        Parameters
        ----------
        selector : str
            A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.innerHTML(selector=selector, timeout=timeout))
        )

    def getAttribute(
        self, selector: str, name: str, timeout: int = None
    ) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;Page.getAttribute

        Returns element attribute value.

        Parameters
        ----------
        selector : str
            A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.
        name : str
            Attribute name to get the value for.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

        Returns
        -------
        Optional[str]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.getAttribute(
                    selector=selector, name=name, timeout=timeout
                )
            )
        )

    def hover(
        self,
        selector: str,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: MousePosition = None,
        timeout: int = None,
        force: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.hover

        This method hovers over an element matching `selector` by performing the following steps:

        Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
        Scroll the element into view if needed.
        Use page.mouse to hover over the center of the element, or the specified `position`.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.
        Shortcut for page.mainFrame().hover(selector[, options]).

        Parameters
        ----------
        selector : str
            A selector to search for element to hover. If there are multiple elements satisfying the selector, the first will be hovered. See working with selectors for more details.
        modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
            Modifier keys to press. Ensures that only these modifiers are pressed during the hover, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
        position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
            A point to hover relative to the top-left corner of element padding box. If not specified, hovers over some visible point of the element.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.hover(
                    selector=selector,
                    modifiers=modifiers,
                    position=position,
                    timeout=timeout,
                    force=force,
                )
            )
        )

    def selectOption(
        self,
        selector: str,
        values: typing.Union[
            str,
            &#34;ElementHandle&#34;,
            SelectOption,
            typing.List[str],
            typing.List[&#34;ElementHandle&#34;],
            typing.List[SelectOption],
        ] = None,
        timeout: int = None,
        noWaitAfter: bool = None,
    ) -&gt; typing.List[str]:
        &#34;&#34;&#34;Page.selectOption

        Triggers a `change` and `input` event once all the provided options have been selected.
        If there&#39;s no `&lt;select&gt;` element matching `selector`, the method throws an error.

        Shortcut for page.mainFrame().selectOption()

        Parameters
        ----------
        selector : str
            A selector to query page for. See working with selectors for more details.
        values : Union[str, ElementHandle, {&#34;value&#34;: Optional[str], &#34;label&#34;: Optional[str], &#34;index&#34;: Optional[str]}, List[str], List[ElementHandle], List[{&#34;value&#34;: Optional[str], &#34;label&#34;: Optional[str], &#34;index&#34;: Optional[str]}], NoneType]
            Options to select. If the `&lt;select&gt;` has the `multiple` attribute, all matching options are selected, otherwise only the first option matching one of the passed options is selected. String values are equivalent to `{value:&#39;string&#39;}`. Option is considered matching if all specified properties match.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.

        Returns
        -------
        List[str]
            An array of option values that have been successfully selected.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.selectOption(
                    selector=selector,
                    values=mapping.to_impl(values),
                    timeout=timeout,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def setInputFiles(
        self,
        selector: str,
        files: typing.Union[
            str, FilePayload, typing.List[str], typing.List[FilePayload]
        ],
        timeout: int = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.setInputFiles

        This method expects `selector` to point to an input element.
        Sets the value of the file input to these file paths or files. If some of the `filePaths` are relative paths, then they are resolved relative to the current working directory. For empty array, clears the selected files.

        Parameters
        ----------
        selector : str
            A selector to search for element to click. If there are multiple elements satisfying the selector, the first will be clicked. See working with selectors for more details.
        files : Union[str, {&#34;name&#34;: str, &#34;mimeType&#34;: str, &#34;buffer&#34;: bytes}, List[str], List[{&#34;name&#34;: str, &#34;mimeType&#34;: str, &#34;buffer&#34;: bytes}]]
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.setInputFiles(
                    selector=selector,
                    files=files,
                    timeout=timeout,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def type(
        self,
        selector: str,
        text: str,
        delay: int = None,
        timeout: int = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.type

        Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text. `page.type` can be used to send fine-grained keyboard events. To fill values in form fields, use `page.fill`.
        To press a special key, like `Control` or `ArrowDown`, use `keyboard.press`.
        Shortcut for page.mainFrame().type(selector, text[, options]).

        Parameters
        ----------
        selector : str
            A selector of an element to type into. If there are multiple elements satisfying the selector, the first will be used. See working with selectors for more details.
        text : str
            A text to type into a focused element.
        delay : Optional[int]
            Time to wait between key presses in milliseconds. Defaults to 0.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.type(
                    selector=selector,
                    text=text,
                    delay=delay,
                    timeout=timeout,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def press(
        self,
        selector: str,
        key: str,
        delay: int = None,
        timeout: int = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.press

        Focuses the element, and then uses `keyboard.down` and `keyboard.up`.
        `key` can specify the intended keyboardEvent.key value or a single character to generate the text for. A superset of the `key` values can be found here. Examples of the keys are:
        `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`, `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.
        Following modification shortcuts are also suported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`.
        Holding down `Shift` will type the text that corresponds to the `key` in the upper case.
        If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective texts.
        Shortcuts such as `key: &#34;Control+o&#34;` or `key: &#34;Control+Shift+T&#34;` are supported as well. When speficied with the modifier, modifier is pressed and being held while the subsequent key is being pressed.

        Parameters
        ----------
        selector : str
            A selector of an element to type into. If there are multiple elements satisfying the selector, the first will be used. See working with selectors for more details.
        key : str
            Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
        delay : Optional[int]
            Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.press(
                    selector=selector,
                    key=key,
                    delay=delay,
                    timeout=timeout,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def check(
        self,
        selector: str,
        timeout: int = None,
        force: bool = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.check

        This method checks an element matching `selector` by performing the following steps:

        Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already checked, this method returns immediately.
        Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
        Scroll the element into view if needed.
        Use page.mouse to click in the center of the element.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
        Ensure that the element is now checked. If not, this method rejects.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.
        Shortcut for page.mainFrame().check(selector[, options]).

        Parameters
        ----------
        selector : str
            A selector to search for checkbox or radio button to check. If there are multiple elements satisfying the selector, the first will be checked. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.check(
                    selector=selector,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def uncheck(
        self,
        selector: str,
        timeout: int = None,
        force: bool = None,
        noWaitAfter: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.uncheck

        This method unchecks an element matching `selector` by performing the following steps:

        Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already unchecked, this method returns immediately.
        Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
        Scroll the element into view if needed.
        Use page.mouse to click in the center of the element.
        Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
        Ensure that the element is now unchecked. If not, this method rejects.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.
        Shortcut for page.mainFrame().uncheck(selector[, options]).

        Parameters
        ----------
        selector : str
            A selector to search for uncheckbox to check. If there are multiple elements satisfying the selector, the first will be checked. See working with selectors for more details.
        timeout : Optional[int]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
        force : Optional[bool]
            Whether to bypass the actionability checks. Defaults to `false`.
        noWaitAfter : Optional[bool]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.uncheck(
                    selector=selector,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=noWaitAfter,
                )
            )
        )

    def waitForTimeout(self, timeout: int) -&gt; NoneType:
        &#34;&#34;&#34;Page.waitForTimeout

        Returns a promise that resolves after the timeout.
        Note that `page.waitForTimeout()` should only be used for debugging. Tests using the timer in production are going to be flaky. Use signals such as network events, selectors becoming visible and others instead.
        Shortcut for page.mainFrame().waitForTimeout(timeout).

        Parameters
        ----------
        timeout : int
            A timeout to wait for
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.waitForTimeout(timeout=timeout))
        )

    def waitForFunction(
        self,
        expression: str,
        arg: typing.Any = None,
        force_expr: bool = None,
        timeout: int = None,
        polling: typing.Union[int, Literal[&#34;raf&#34;]] = None,
    ) -&gt; &#34;JSHandle&#34;:
        &#34;&#34;&#34;Page.waitForFunction

        The `waitForFunction` can be used to observe viewport size change:

        To pass an argument from Node.js to the predicate of `page.waitForFunction` function:
        Shortcut for page.mainFrame().waitForFunction(pageFunction[, arg, options]).

        Parameters
        ----------
        expression : str
            Function to be evaluated in browser context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`
        timeout : Optional[int]
            maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can be changed by using the page.setDefaultTimeout(timeout) method.
        polling : Union[int, &#39;raf&#39;, NoneType]
            If `polling` is `&#39;raf&#39;`, then `pageFunction` is constantly executed in `requestAnimationFrame` callback. If `polling` is a number, then it is treated as an interval in milliseconds at which the function would be executed. Defaults to `raf`.

        Returns
        -------
        JSHandle
            Promise which resolves when the `pageFunction` returns a truthy value. It resolves to a JSHandle of the truthy value.
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.waitForFunction(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                    timeout=timeout,
                    polling=polling,
                )
            )
        )

    def pdf(
        self,
        scale: int = None,
        displayHeaderFooter: bool = None,
        headerTemplate: str = None,
        footerTemplate: str = None,
        printBackground: bool = None,
        landscape: bool = None,
        pageRanges: str = None,
        format: str = None,
        width: typing.Union[str, float] = None,
        height: typing.Union[str, float] = None,
        preferCSSPageSize: bool = None,
        margin: PdfMargins = None,
        path: typing.Union[str, pathlib.Path] = None,
    ) -&gt; bytes:
        &#34;&#34;&#34;Page.pdf

        **NOTE** Generating a pdf is currently only supported in Chromium headless.

        `page.pdf()` generates a pdf of the page with `print` css media. To generate a pdf with `screen` media, call page.emulateMedia({ media: &#39;screen&#39; }) before calling `page.pdf()`:

        **NOTE** By default, `page.pdf()` generates a pdf with modified colors for printing. Use the `-webkit-print-color-adjust` property to force rendering of exact colors.

        The `width`, `height`, and `margin` options accept values labeled with units. Unlabeled values are treated as pixels.
        A few examples:

        `page.pdf({width: 100})` - prints with width set to 100 pixels
        `page.pdf({width: &#39;100px&#39;})` - prints with width set to 100 pixels
        `page.pdf({width: &#39;10cm&#39;})` - prints with width set to 10 centimeters.

        All possible units are:

        `px` - pixel
        `in` - inch
        `cm` - centimeter
        `mm` - millimeter

        The `format` options are:

        `Letter`: 8.5in x 11in
        `Legal`: 8.5in x 14in
        `Tabloid`: 11in x 17in
        `Ledger`: 17in x 11in
        `A0`: 33.1in x 46.8in
        `A1`: 23.4in x 33.1in
        `A2`: 16.54in x 23.4in
        `A3`: 11.7in x 16.54in
        `A4`: 8.27in x 11.7in
        `A5`: 5.83in x 8.27in
        `A6`: 4.13in x 5.83in

        **NOTE** `headerTemplate` and `footerTemplate` markup have the following limitations:

        Script tags inside templates are not evaluated.
        Page styles are not visible inside templates.

        Parameters
        ----------
        scale : Optional[int]
            Scale of the webpage rendering. Defaults to `1`. Scale amount must be between 0.1 and 2.
        displayHeaderFooter : Optional[bool]
            Display header and footer. Defaults to `false`.
        headerTemplate : Optional[str]
            HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them:
             - `&#39;date&#39;` formatted print date
             - `&#39;title&#39;` document title
             - `&#39;url&#39;` document location
             - `&#39;pageNumber&#39;` current page number
             - `&#39;totalPages&#39;` total pages in the document
        footerTemplate : Optional[str]
            HTML template for the print footer. Should use the same format as the `headerTemplate`.
        printBackground : Optional[bool]
            Print background graphics. Defaults to `false`.
        landscape : Optional[bool]
            Paper orientation. Defaults to `false`.
        pageRanges : Optional[str]
            Paper ranges to print, e.g., &#39;1-5, 8, 11-13&#39;. Defaults to the empty string, which means print all pages.
        format : Optional[str]
            Paper format. If set, takes priority over `width` or `height` options. Defaults to &#39;Letter&#39;.
        width : Union[str, float, NoneType]
            Paper width, accepts values labeled with units.
        height : Union[str, float, NoneType]
            Paper height, accepts values labeled with units.
        preferCSSPageSize : Optional[bool]
            Give any CSS `@page` size declared in the page priority over what is declared in `width` and `height` or `format` options. Defaults to `false`, which will scale the content to fit the paper size.
        margin : Optional[{&#34;top&#34;: Union[str, int, NoneType], &#34;right&#34;: Union[str, int, NoneType], &#34;bottom&#34;: Union[str, int, NoneType], &#34;left&#34;: Union[str, int, NoneType]}]
            Paper margins, defaults to none.
        path : Union[str, pathlib.Path, NoneType]
            The file path to save the PDF to. If `path` is a relative path, then it is resolved relative to current working directory. If no path is provided, the PDF won&#39;t be saved to the disk.

        Returns
        -------
        bytes
            Promise which resolves with PDF buffer.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.pdf(
                    scale=scale,
                    displayHeaderFooter=displayHeaderFooter,
                    headerTemplate=headerTemplate,
                    footerTemplate=footerTemplate,
                    printBackground=printBackground,
                    landscape=landscape,
                    pageRanges=pageRanges,
                    format=format,
                    width=width,
                    height=height,
                    preferCSSPageSize=preferCSSPageSize,
                    margin=margin,
                    path=path,
                )
            )
        )

    def expect_event(
        self,
        event: str,
        predicate: typing.Union[typing.Callable[[typing.Any], bool]] = None,
        timeout: int = None,
    ) -&gt; EventContextManager:
        return EventContextManager(
            self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
        )

    def expect_console_message(
        self,
        predicate: typing.Union[typing.Callable[[&#34;ConsoleMessage&#34;], bool]] = None,
        timeout: int = None,
    ) -&gt; EventContextManager[&#34;ConsoleMessage&#34;]:
        event = &#34;console&#34;
        return EventContextManager(
            self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
        )

    def expect_dialog(
        self,
        predicate: typing.Union[typing.Callable[[&#34;Dialog&#34;], bool]] = None,
        timeout: int = None,
    ) -&gt; EventContextManager[&#34;Dialog&#34;]:
        event = &#34;dialog&#34;
        return EventContextManager(
            self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
        )

    def expect_download(
        self,
        predicate: typing.Union[typing.Callable[[&#34;Download&#34;], bool]] = None,
        timeout: int = None,
    ) -&gt; EventContextManager[&#34;Download&#34;]:
        event = &#34;download&#34;
        return EventContextManager(
            self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
        )

    def expect_file_chooser(
        self,
        predicate: typing.Union[typing.Callable[[&#34;FileChooser&#34;], bool]] = None,
        timeout: int = None,
    ) -&gt; EventContextManager[&#34;FileChooser&#34;]:
        event = &#34;filechooser&#34;
        return EventContextManager(
            self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
        )

    def expect_load_state(
        self,
        state: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        timeout: int = None,
    ) -&gt; EventContextManager[typing.Union[&#34;Response&#34;, NoneType]]:
        return EventContextManager(
            self._loop, self._impl_obj.waitForLoadState(state, timeout)
        )

    def expect_navigation(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
        waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        timeout: int = None,
    ) -&gt; EventContextManager[typing.Union[&#34;Response&#34;, NoneType]]:
        return EventContextManager(
            self._loop, self._impl_obj.waitForNavigation(url, waitUntil, timeout)
        )

    def expect_popup(
        self,
        predicate: typing.Union[typing.Callable[[&#34;Page&#34;], bool]] = None,
        timeout: int = None,
    ) -&gt; EventContextManager[&#34;Page&#34;]:
        event = &#34;popup&#34;
        return EventContextManager(
            self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
        )

    def expect_request(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
        predicate: typing.Union[typing.Callable[[&#34;Request&#34;], bool]] = None,
        timeout: int = None,
    ) -&gt; EventContextManager[&#34;Request&#34;]:
        return EventContextManager(
            self._loop, self._impl_obj.waitForRequest(url, predicate, timeout)
        )

    def expect_response(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
        predicate: typing.Union[typing.Callable[[&#34;Request&#34;], bool]] = None,
        timeout: int = None,
    ) -&gt; EventContextManager[&#34;Response&#34;]:
        return EventContextManager(
            self._loop, self._impl_obj.waitForResponse(url, predicate, timeout)
        )

    def expect_worker(
        self,
        predicate: typing.Union[typing.Callable[[&#34;Worker&#34;], bool]] = None,
        timeout: int = None,
    ) -&gt; EventContextManager[&#34;Worker&#34;]:
        event = &#34;worker&#34;
        return EventContextManager(
            self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright.sync_base.SyncBase</li>
<li>playwright.impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.sync_api.Page.accessibility"><code class="name">var <span class="ident">accessibility</span> : <a title="playwright.sync_api.Accessibility" href="#playwright.sync_api.Accessibility">Accessibility</a></code></dt>
<dd>
<div class="desc"><p>Page.accessibility</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.Accessibility" href="#playwright.sync_api.Accessibility">Accessibility</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def accessibility(self) -&gt; &#34;Accessibility&#34;:
    &#34;&#34;&#34;Page.accessibility

    Returns
    -------
    Accessibility
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.accessibility)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.context"><code class="name">var <span class="ident">context</span> : <a title="playwright.sync_api.BrowserContext" href="#playwright.sync_api.BrowserContext">BrowserContext</a></code></dt>
<dd>
<div class="desc"><p>Page.context</p>
<p>Get the browser context that the page belongs to.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.BrowserContext" href="#playwright.sync_api.BrowserContext">BrowserContext</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def context(self) -&gt; &#34;BrowserContext&#34;:
    &#34;&#34;&#34;Page.context

    Get the browser context that the page belongs to.

    Returns
    -------
    BrowserContext
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.context)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.frames"><code class="name">var <span class="ident">frames</span> : List[<a title="playwright.async_api.Frame" href="async_api.html#playwright.async_api.Frame">Frame</a>]</code></dt>
<dd>
<div class="desc"><p>Page.frames</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="playwright.sync_api.Frame" href="#playwright.sync_api.Frame">Frame</a>]</code></dt>
<dd>An array of all frames attached to the page.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frames(self) -&gt; typing.List[&#34;Frame&#34;]:
    &#34;&#34;&#34;Page.frames

    Returns
    -------
    List[Frame]
        An array of all frames attached to the page.
    &#34;&#34;&#34;
    return mapping.from_impl_list(self._impl_obj.frames)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.keyboard"><code class="name">var <span class="ident">keyboard</span> : <a title="playwright.sync_api.Keyboard" href="#playwright.sync_api.Keyboard">Keyboard</a></code></dt>
<dd>
<div class="desc"><p>Page.keyboard</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.Keyboard" href="#playwright.sync_api.Keyboard">Keyboard</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def keyboard(self) -&gt; &#34;Keyboard&#34;:
    &#34;&#34;&#34;Page.keyboard

    Returns
    -------
    Keyboard
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.keyboard)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.mainFrame"><code class="name">var <span class="ident">mainFrame</span> : <a title="playwright.sync_api.Frame" href="#playwright.sync_api.Frame">Frame</a></code></dt>
<dd>
<div class="desc"><p>Page.mainFrame</p>
<p>Page is guaranteed to have a main frame which persists during navigations.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.Frame" href="#playwright.sync_api.Frame">Frame</a></code></dt>
<dd>The page's main frame.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mainFrame(self) -&gt; &#34;Frame&#34;:
    &#34;&#34;&#34;Page.mainFrame

    Page is guaranteed to have a main frame which persists during navigations.

    Returns
    -------
    Frame
        The page&#39;s main frame.
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.mainFrame)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.mouse"><code class="name">var <span class="ident">mouse</span> : <a title="playwright.sync_api.Mouse" href="#playwright.sync_api.Mouse">Mouse</a></code></dt>
<dd>
<div class="desc"><p>Page.mouse</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.Mouse" href="#playwright.sync_api.Mouse">Mouse</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mouse(self) -&gt; &#34;Mouse&#34;:
    &#34;&#34;&#34;Page.mouse

    Returns
    -------
    Mouse
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.mouse)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.touchscreen"><code class="name">var <span class="ident">touchscreen</span> : <a title="playwright.sync_api.Touchscreen" href="#playwright.sync_api.Touchscreen">Touchscreen</a></code></dt>
<dd>
<div class="desc"><p>Page.touchscreen</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.Touchscreen" href="#playwright.sync_api.Touchscreen">Touchscreen</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def touchscreen(self) -&gt; &#34;Touchscreen&#34;:
    &#34;&#34;&#34;Page.touchscreen

    Returns
    -------
    Touchscreen
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.touchscreen)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.url"><code class="name">var <span class="ident">url</span> : str</code></dt>
<dd>
<div class="desc"><p>Page.url</p>
<p>This is a shortcut for page.mainFrame().url()</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def url(self) -&gt; str:
    &#34;&#34;&#34;Page.url

    This is a shortcut for page.mainFrame().url()

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.url)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.video"><code class="name">var <span class="ident">video</span> : Union[<a title="playwright.async_api.Video" href="async_api.html#playwright.async_api.Video">Video</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Page.video</p>
<p>Video object associated with this page.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[<a title="playwright.sync_api.Video" href="#playwright.sync_api.Video">Video</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def video(self) -&gt; typing.Union[&#34;Video&#34;, NoneType]:
    &#34;&#34;&#34;Page.video

    Video object associated with this page.

    Returns
    -------
    Optional[Video]
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(self._impl_obj.video)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.workers"><code class="name">var <span class="ident">workers</span> : List[<a title="playwright.async_api.Worker" href="async_api.html#playwright.async_api.Worker">Worker</a>]</code></dt>
<dd>
<div class="desc"><p>Page.workers</p>
<p><strong>NOTE</strong> This does not contain ServiceWorkers</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="playwright.sync_api.Worker" href="#playwright.sync_api.Worker">Worker</a>]</code></dt>
<dd>This method returns all of the dedicated WebWorkers associated with the page.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def workers(self) -&gt; typing.List[&#34;Worker&#34;]:
    &#34;&#34;&#34;Page.workers

    **NOTE** This does not contain ServiceWorkers

    Returns
    -------
    List[Worker]
        This method returns all of the dedicated WebWorkers associated with the page.
    &#34;&#34;&#34;
    return mapping.from_impl_list(self._impl_obj.workers)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.sync_api.Page.addInitScript"><code class="name flex">
<span>def <span class="ident">addInitScript</span></span>(<span>self, source: str = None, path: Union[str, pathlib.Path] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.addInitScript</p>
<p>Adds a script which would be evaluated in one of the following scenarios:</p>
<p>Whenever the page is navigated.
Whenever the child frame is attached or navigated. In this case, the script is evaluated in the context of the newly attached frame.</p>
<p>The script is evaluated after the document was created but before any of its scripts were run. This is useful to amend
the JavaScript environment, e.g. to seed <code>Math.random</code>.
An example of overriding <code>Math.random</code> before the page loads:</p>
<p><strong>NOTE</strong> The order of evaluation of multiple scripts installed via browserContext.addInitScript(script[, arg]) and page.addInitScript(script[, arg]) is not defined.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>source</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Script to be evaluated in the page.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addInitScript(
    self, source: str = None, path: typing.Union[str, pathlib.Path] = None
) -&gt; NoneType:
    &#34;&#34;&#34;Page.addInitScript

    Adds a script which would be evaluated in one of the following scenarios:

    Whenever the page is navigated.
    Whenever the child frame is attached or navigated. In this case, the script is evaluated in the context of the newly attached frame.

    The script is evaluated after the document was created but before any of its scripts were run. This is useful to amend  the JavaScript environment, e.g. to seed `Math.random`.
    An example of overriding `Math.random` before the page loads:

    **NOTE** The order of evaluation of multiple scripts installed via browserContext.addInitScript(script[, arg]) and page.addInitScript(script[, arg]) is not defined.

    Parameters
    ----------
    source : Optional[str]
        Script to be evaluated in the page.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.addInitScript(source=source, path=path))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.addScriptTag"><code class="name flex">
<span>def <span class="ident">addScriptTag</span></span>(<span>self, url: str = None, path: Union[str, pathlib.Path] = None, content: str = None, type: str = None) ‑> <a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a></span>
</code></dt>
<dd>
<div class="desc"><p>Page.addScriptTag</p>
<p>Adds a <code>&lt;script&gt;</code> tag into the page with the desired url or content.
Shortcut for page.mainFrame().addScriptTag(options).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>URL of a script to be added.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[str, pathlib.Path, NoneType]</code></dt>
<dd>Path to the JavaScript file to be injected into frame. If <code>path</code> is a relative path, then it is resolved relative to current working directory.</dd>
<dt><strong><code>content</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Raw JavaScript content to be injected into frame.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Script type. Use 'module' in order to load a Javascript ES6 module. See script for more details.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a></code></dt>
<dd>which resolves to the added tag when the script's onload fires or when the script content was injected into frame.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addScriptTag(
    self,
    url: str = None,
    path: typing.Union[str, pathlib.Path] = None,
    content: str = None,
    type: str = None,
) -&gt; &#34;ElementHandle&#34;:
    &#34;&#34;&#34;Page.addScriptTag

    Adds a `&lt;script&gt;` tag into the page with the desired url or content.
    Shortcut for page.mainFrame().addScriptTag(options).

    Parameters
    ----------
    url : Optional[str]
        URL of a script to be added.
    path : Union[str, pathlib.Path, NoneType]
        Path to the JavaScript file to be injected into frame. If `path` is a relative path, then it is resolved relative to current working directory.
    content : Optional[str]
        Raw JavaScript content to be injected into frame.
    type : Optional[str]
        Script type. Use &#39;module&#39; in order to load a Javascript ES6 module. See script for more details.

    Returns
    -------
    ElementHandle
        which resolves to the added tag when the script&#39;s onload fires or when the script content was injected into frame.
    &#34;&#34;&#34;
    return mapping.from_impl(
        self._sync(
            self._impl_obj.addScriptTag(
                url=url, path=path, content=content, type=type
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.addStyleTag"><code class="name flex">
<span>def <span class="ident">addStyleTag</span></span>(<span>self, url: str = None, path: Union[str, pathlib.Path] = None, content: str = None) ‑> <a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a></span>
</code></dt>
<dd>
<div class="desc"><p>Page.addStyleTag</p>
<p>Adds a <code>&lt;link rel="stylesheet"&gt;</code> tag into the page with the desired url or a <code>&lt;style type="text/css"&gt;</code> tag with the content.
Shortcut for page.mainFrame().addStyleTag(options).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>URL of the <code>&lt;link&gt;</code> tag.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[str, pathlib.Path, NoneType]</code></dt>
<dd>Path to the CSS file to be injected into frame. If <code>path</code> is a relative path, then it is resolved relative to current working directory.</dd>
<dt><strong><code>content</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Raw CSS content to be injected into frame.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a></code></dt>
<dd>which resolves to the added tag when the stylesheet's onload fires or when the CSS content was injected into frame.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addStyleTag(
    self,
    url: str = None,
    path: typing.Union[str, pathlib.Path] = None,
    content: str = None,
) -&gt; &#34;ElementHandle&#34;:
    &#34;&#34;&#34;Page.addStyleTag

    Adds a `&lt;link rel=&#34;stylesheet&#34;&gt;` tag into the page with the desired url or a `&lt;style type=&#34;text/css&#34;&gt;` tag with the content.
    Shortcut for page.mainFrame().addStyleTag(options).

    Parameters
    ----------
    url : Optional[str]
        URL of the `&lt;link&gt;` tag.
    path : Union[str, pathlib.Path, NoneType]
        Path to the CSS file to be injected into frame. If `path` is a relative path, then it is resolved relative to current working directory.
    content : Optional[str]
        Raw CSS content to be injected into frame.

    Returns
    -------
    ElementHandle
        which resolves to the added tag when the stylesheet&#39;s onload fires or when the CSS content was injected into frame.
    &#34;&#34;&#34;
    return mapping.from_impl(
        self._sync(self._impl_obj.addStyleTag(url=url, path=path, content=content))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.bringToFront"><code class="name flex">
<span>def <span class="ident">bringToFront</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.bringToFront</p>
<p>Brings page to front (activates tab).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bringToFront(self) -&gt; NoneType:
    &#34;&#34;&#34;Page.bringToFront

    Brings page to front (activates tab).
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.bringToFront()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.check"><code class="name flex">
<span>def <span class="ident">check</span></span>(<span>self, selector: str, timeout: int = None, force: bool = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.check</p>
<p>This method checks an element matching <code>selector</code> by performing the following steps:</p>
<p>Find an element match matching <code>selector</code>. If there is none, wait until a matching element is attached to the DOM.
Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already checked, this method returns immediately.
Wait for actionability checks on the matched element, unless <code>force</code> option is set. If the element is detached during the checks, the whole action is retried.
Scroll the element into view if needed.
Use page.mouse to click in the center of the element.
Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.
Ensure that the element is now checked. If not, this method rejects.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a TimeoutError. Passing zero timeout disables this.
Shortcut for page.mainFrame().check(selector[, options]).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for checkbox or radio button to check. If there are multiple elements satisfying the selector, the first will be checked. See working with selectors for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to bypass the actionability checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check(
    self,
    selector: str,
    timeout: int = None,
    force: bool = None,
    noWaitAfter: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.check

    This method checks an element matching `selector` by performing the following steps:

    Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
    Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already checked, this method returns immediately.
    Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
    Scroll the element into view if needed.
    Use page.mouse to click in the center of the element.
    Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
    Ensure that the element is now checked. If not, this method rejects.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.
    Shortcut for page.mainFrame().check(selector[, options]).

    Parameters
    ----------
    selector : str
        A selector to search for checkbox or radio button to check. If there are multiple elements satisfying the selector, the first will be checked. See working with selectors for more details.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    force : Optional[bool]
        Whether to bypass the actionability checks. Defaults to `false`.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.check(
                selector=selector,
                timeout=timeout,
                force=force,
                noWaitAfter=noWaitAfter,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.click"><code class="name flex">
<span>def <span class="ident">click</span></span>(<span>self, selector: str, modifiers: List[Literal['Alt', 'Control', 'Meta', 'Shift']] = None, position: playwright.helper.MousePosition = None, delay: int = None, button: Literal['left', 'middle', 'right'] = None, clickCount: int = None, timeout: int = None, force: bool = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.click</p>
<p>This method clicks an element matching <code>selector</code> by performing the following steps:</p>
<p>Find an element match matching <code>selector</code>. If there is none, wait until a matching element is attached to the DOM.
Wait for actionability checks on the matched element, unless <code>force</code> option is set. If the element is detached during the checks, the whole action is retried.
Scroll the element into view if needed.
Use page.mouse to click in the center of the element, or the specified <code>position</code>.
Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a TimeoutError. Passing zero timeout disables this.
Shortcut for page.mainFrame().click(selector[, options]).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element to click. If there are multiple elements satisfying the selector, the first will be clicked. See working with selectors for more details.</dd>
<dt><strong><code>modifiers</code></strong> :&ensp;<code>Optional[List[Literal['Alt', 'Control', 'Meta', 'Shift']]]</code></dt>
<dd>Modifier keys to press. Ensures that only these modifiers are pressed during the click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>Optional[{"x": float, "y": float}]</code></dt>
<dd>A point to click relative to the top-left corner of element padding box. If not specified, clicks to some visible point of the element.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Time to wait between <code>mousedown</code> and <code>mouseup</code> in milliseconds. Defaults to 0.</dd>
<dt><strong><code>button</code></strong> :&ensp;<code>Optional[Literal['left', 'middle', 'right']]</code></dt>
<dd>Defaults to <code>left</code>.</dd>
<dt><strong><code>clickCount</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>defaults to 1. See UIEvent.detail.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to bypass the actionability checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def click(
    self,
    selector: str,
    modifiers: typing.Union[
        typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
    ] = None,
    position: MousePosition = None,
    delay: int = None,
    button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
    clickCount: int = None,
    timeout: int = None,
    force: bool = None,
    noWaitAfter: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.click

    This method clicks an element matching `selector` by performing the following steps:

    Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
    Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
    Scroll the element into view if needed.
    Use page.mouse to click in the center of the element, or the specified `position`.
    Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.
    Shortcut for page.mainFrame().click(selector[, options]).

    Parameters
    ----------
    selector : str
        A selector to search for element to click. If there are multiple elements satisfying the selector, the first will be clicked. See working with selectors for more details.
    modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
        Modifier keys to press. Ensures that only these modifiers are pressed during the click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
    position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
        A point to click relative to the top-left corner of element padding box. If not specified, clicks to some visible point of the element.
    delay : Optional[int]
        Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
    button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
        Defaults to `left`.
    clickCount : Optional[int]
        defaults to 1. See UIEvent.detail.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    force : Optional[bool]
        Whether to bypass the actionability checks. Defaults to `false`.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.click(
                selector=selector,
                modifiers=modifiers,
                position=position,
                delay=delay,
                button=button,
                clickCount=clickCount,
                timeout=timeout,
                force=force,
                noWaitAfter=noWaitAfter,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self, runBeforeUnload: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.close</p>
<p>If <code>runBeforeUnload</code> is <code>false</code> the result will resolve only after the page has been closed.
If <code>runBeforeUnload</code> is <code>true</code> the method will <strong>not</strong> wait for the page to close.
By default, <code>page.close()</code> <strong>does not</strong> run beforeunload handlers.</p>
<p><strong>NOTE</strong> if <code>runBeforeUnload</code> is passed as true, a <code>beforeunload</code> dialog might be summoned
and should be handled manually via page's 'dialog' event.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>runBeforeUnload</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Defaults to <code>false</code>. Whether to run the
before unload
page handlers.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self, runBeforeUnload: bool = None) -&gt; NoneType:
    &#34;&#34;&#34;Page.close

    If `runBeforeUnload` is `false` the result will resolve only after the page has been closed.
    If `runBeforeUnload` is `true` the method will **not** wait for the page to close.
    By default, `page.close()` **does not** run beforeunload handlers.

    **NOTE** if `runBeforeUnload` is passed as true, a `beforeunload` dialog might be summoned
    and should be handled manually via page&#39;s &#39;dialog&#39; event.

    Parameters
    ----------
    runBeforeUnload : Optional[bool]
        Defaults to `false`. Whether to run the
        before unload
        page handlers.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.close(runBeforeUnload=runBeforeUnload))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.content"><code class="name flex">
<span>def <span class="ident">content</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Page.content</p>
<p>Gets the full HTML contents of the page, including the doctype.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def content(self) -&gt; str:
    &#34;&#34;&#34;Page.content

    Gets the full HTML contents of the page, including the doctype.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.content()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.dblclick"><code class="name flex">
<span>def <span class="ident">dblclick</span></span>(<span>self, selector: str, modifiers: List[Literal['Alt', 'Control', 'Meta', 'Shift']] = None, position: playwright.helper.MousePosition = None, delay: int = None, button: Literal['left', 'middle', 'right'] = None, timeout: int = None, force: bool = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.dblclick</p>
<p>This method double clicks an element matching <code>selector</code> by performing the following steps:</p>
<p>Find an element match matching <code>selector</code>. If there is none, wait until a matching element is attached to the DOM.
Wait for actionability checks on the matched element, unless <code>force</code> option is set. If the element is detached during the checks, the whole action is retried.
Scroll the element into view if needed.
Use page.mouse to double click in the center of the element, or the specified <code>position</code>.
Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set. Note that if the first click of the <code>dblclick()</code> triggers a navigation event, this method will reject.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a TimeoutError. Passing zero timeout disables this.</p>
<p><strong>NOTE</strong> <code>page.dblclick()</code> dispatches two <code>click</code> events and a single <code>dblclick</code> event.</p>
<p>Shortcut for page.mainFrame().dblclick(selector[, options]).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element to double click. If there are multiple elements satisfying the selector, the first will be double clicked. See working with selectors for more details.</dd>
<dt><strong><code>modifiers</code></strong> :&ensp;<code>Optional[List[Literal['Alt', 'Control', 'Meta', 'Shift']]]</code></dt>
<dd>Modifier keys to press. Ensures that only these modifiers are pressed during the double click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>Optional[{"x": float, "y": float}]</code></dt>
<dd>A point to double click relative to the top-left corner of element padding box. If not specified, double clicks to some visible point of the element.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Time to wait between <code>mousedown</code> and <code>mouseup</code> in milliseconds. Defaults to 0.</dd>
<dt><strong><code>button</code></strong> :&ensp;<code>Optional[Literal['left', 'middle', 'right']]</code></dt>
<dd>Defaults to <code>left</code>.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to bypass the actionability checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dblclick(
    self,
    selector: str,
    modifiers: typing.Union[
        typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
    ] = None,
    position: MousePosition = None,
    delay: int = None,
    button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
    timeout: int = None,
    force: bool = None,
    noWaitAfter: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.dblclick

    This method double clicks an element matching `selector` by performing the following steps:

    Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
    Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
    Scroll the element into view if needed.
    Use page.mouse to double click in the center of the element, or the specified `position`.
    Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set. Note that if the first click of the `dblclick()` triggers a navigation event, this method will reject.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

    **NOTE** `page.dblclick()` dispatches two `click` events and a single `dblclick` event.

    Shortcut for page.mainFrame().dblclick(selector[, options]).

    Parameters
    ----------
    selector : str
        A selector to search for element to double click. If there are multiple elements satisfying the selector, the first will be double clicked. See working with selectors for more details.
    modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
        Modifier keys to press. Ensures that only these modifiers are pressed during the double click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
    position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
        A point to double click relative to the top-left corner of element padding box. If not specified, double clicks to some visible point of the element.
    delay : Optional[int]
        Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
    button : Optional[Literal[&#39;left&#39;, &#39;middle&#39;, &#39;right&#39;]]
        Defaults to `left`.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    force : Optional[bool]
        Whether to bypass the actionability checks. Defaults to `false`.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.dblclick(
                selector=selector,
                modifiers=modifiers,
                position=position,
                delay=delay,
                button=button,
                timeout=timeout,
                force=force,
                noWaitAfter=noWaitAfter,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.dispatchEvent"><code class="name flex">
<span>def <span class="ident">dispatchEvent</span></span>(<span>self, selector: str, type: str, eventInit: Dict = None, timeout: int = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.dispatchEvent</p>
<p>The snippet below dispatches the <code>click</code> event on the element. Regardless of the visibility state of the elment, <code>click</code> is dispatched. This is equivalend to calling <code>element.click()</code>.
Under the hood, it creates an instance of an event based on the given <code>type</code>, initializes it with <code>eventInit</code> properties and dispatches it on the element. Events are <code>composed</code>, <code>cancelable</code> and bubble by default.
Since <code>eventInit</code> is event-specific, please refer to the events documentation for the lists of initial properties:</p>
<p>DragEvent
FocusEvent
KeyboardEvent
MouseEvent
PointerEvent
TouchEvent
Event</p>
<p>You can also specify <code><a title="playwright.sync_api.JSHandle" href="#playwright.sync_api.JSHandle">JSHandle</a></code> as the property value if you want live objects to be passed into the event:</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element to use. If there are multiple elements satisfying the selector, the first will be used. See working with selectors for more details.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code></dt>
<dd>DOM event type: <code>"click"</code>, <code>"dragstart"</code>, etc.</dd>
<dt><strong><code>eventInit</code></strong> :&ensp;<code>Optional[Dict]</code></dt>
<dd>event-specific initialization properties.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dispatchEvent(
    self,
    selector: str,
    type: str,
    eventInit: typing.Dict = None,
    timeout: int = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.dispatchEvent

    The snippet below dispatches the `click` event on the element. Regardless of the visibility state of the elment, `click` is dispatched. This is equivalend to calling `element.click()`.
    Under the hood, it creates an instance of an event based on the given `type`, initializes it with `eventInit` properties and dispatches it on the element. Events are `composed`, `cancelable` and bubble by default.
    Since `eventInit` is event-specific, please refer to the events documentation for the lists of initial properties:

    DragEvent
    FocusEvent
    KeyboardEvent
    MouseEvent
    PointerEvent
    TouchEvent
    Event

    You can also specify `JSHandle` as the property value if you want live objects to be passed into the event:

    Parameters
    ----------
    selector : str
        A selector to search for element to use. If there are multiple elements satisfying the selector, the first will be used. See working with selectors for more details.
    type : str
        DOM event type: `&#34;click&#34;`, `&#34;dragstart&#34;`, etc.
    eventInit : Optional[Dict]
        event-specific initialization properties.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.dispatchEvent(
                selector=selector,
                type=type,
                eventInit=mapping.to_impl(eventInit),
                timeout=timeout,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.emulateMedia"><code class="name flex">
<span>def <span class="ident">emulateMedia</span></span>(<span>self, media: Literal['print', 'screen'] = None, colorScheme: Literal['dark', 'light', 'no-preference'] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.emulateMedia</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>media</code></strong> :&ensp;<code>Optional[Literal['print', 'screen']]</code></dt>
<dd>Changes the CSS media type of the page. The only allowed values are <code>'screen'</code>, <code>'print'</code> and <code>null</code>. Passing <code>null</code> disables CSS media emulation. Omitting <code>media</code> or passing <code>undefined</code> does not change the emulated value.</dd>
<dt><strong><code>colorScheme</code></strong> :&ensp;<code>Optional[Literal['dark', 'light', 'no-preference']]</code></dt>
<dd>Emulates <code>'prefers-colors-scheme'</code> media feature, supported values are <code>'light'</code>, <code>'dark'</code>, <code>'no-preference'</code>. Passing <code>null</code> disables color scheme emulation. Omitting <code>colorScheme</code> or passing <code>undefined</code> does not change the emulated value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def emulateMedia(
    self,
    media: Literal[&#34;print&#34;, &#34;screen&#34;] = None,
    colorScheme: Literal[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;] = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.emulateMedia


    Parameters
    ----------
    media : Optional[Literal[&#39;print&#39;, &#39;screen&#39;]]
        Changes the CSS media type of the page. The only allowed values are `&#39;screen&#39;`, `&#39;print&#39;` and `null`. Passing `null` disables CSS media emulation. Omitting `media` or passing `undefined` does not change the emulated value.
    colorScheme : Optional[Literal[&#39;dark&#39;, &#39;light&#39;, &#39;no-preference&#39;]]
        Emulates `&#39;prefers-colors-scheme&#39;` media feature, supported values are `&#39;light&#39;`, `&#39;dark&#39;`, `&#39;no-preference&#39;`. Passing `null` disables color scheme emulation. Omitting `colorScheme` or passing `undefined` does not change the emulated value.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.emulateMedia(media=media, colorScheme=colorScheme)
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.evalOnSelector"><code class="name flex">
<span>def <span class="ident">evalOnSelector</span></span>(<span>self, selector: str, expression: str, arg: Any = None, force_expr: bool = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Page.evalOnSelector</p>
<p>The method finds an element matching the specified selector within the page and passes it as a first argument to <code>pageFunction</code>. If no elements match the selector, the method throws an error.
If <code>pageFunction</code> returns a Promise, then <code>page.$eval</code> would wait for the promise to resolve and return its value.
Examples:
Shortcut for page.mainFrame().$eval(selector, pageFunction).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query page for. See working with selectors for more details.</dd>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>Function to be evaluated in browser context</dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Optional[Any]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>Promise which resolves to the return value of <code>pageFunction</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evalOnSelector(
    self,
    selector: str,
    expression: str,
    arg: typing.Any = None,
    force_expr: bool = None,
) -&gt; typing.Any:
    &#34;&#34;&#34;Page.evalOnSelector

    The method finds an element matching the specified selector within the page and passes it as a first argument to `pageFunction`. If no elements match the selector, the method throws an error.
    If `pageFunction` returns a Promise, then `page.$eval` would wait for the promise to resolve and return its value.
    Examples:
    Shortcut for page.mainFrame().$eval(selector, pageFunction).

    Parameters
    ----------
    selector : str
        A selector to query page for. See working with selectors for more details.
    expression : str
        Function to be evaluated in browser context
    force_expr : bool
        Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
    arg : Optional[Any]
        Optional argument to pass to `pageFunction`

    Returns
    -------
    Any
        Promise which resolves to the return value of `pageFunction`
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.evalOnSelector(
                selector=selector,
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.evalOnSelectorAll"><code class="name flex">
<span>def <span class="ident">evalOnSelectorAll</span></span>(<span>self, selector: str, expression: str, arg: Any = None, force_expr: bool = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Page.evalOnSelectorAll</p>
<p>The method finds all elements matching the specified selector within the page and passes an array of matched elements as a first argument to <code>pageFunction</code>.
If <code>pageFunction</code> returns a Promise, then <code>page.$$eval</code> would wait for the promise to resolve and return its value.
Examples:</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query page for. See working with selectors for more details.</dd>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>Function to be evaluated in browser context</dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Optional[Any]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>Promise which resolves to the return value of <code>pageFunction</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evalOnSelectorAll(
    self,
    selector: str,
    expression: str,
    arg: typing.Any = None,
    force_expr: bool = None,
) -&gt; typing.Any:
    &#34;&#34;&#34;Page.evalOnSelectorAll

    The method finds all elements matching the specified selector within the page and passes an array of matched elements as a first argument to `pageFunction`.
    If `pageFunction` returns a Promise, then `page.$$eval` would wait for the promise to resolve and return its value.
    Examples:

    Parameters
    ----------
    selector : str
        A selector to query page for. See working with selectors for more details.
    expression : str
        Function to be evaluated in browser context
    force_expr : bool
        Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
    arg : Optional[Any]
        Optional argument to pass to `pageFunction`

    Returns
    -------
    Any
        Promise which resolves to the return value of `pageFunction`
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.evalOnSelectorAll(
                selector=selector,
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, expression: str, arg: Any = None, force_expr: bool = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Page.evaluate</p>
<p>If the function passed to the <code>page.evaluate</code> returns a Promise, then <code>page.evaluate</code> would wait for the promise to resolve and return its value.
If the function passed to the <code>page.evaluate</code> returns a non-Serializable value, then <code>page.evaluate</code> resolves to <code>undefined</code>. DevTools Protocol also supports transferring some additional values that are not serializable by <code>JSON</code>: <code>-0</code>, <code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code>, and bigint literals.
Passing argument to <code>pageFunction</code>:
A string can also be passed in instead of a function:
ElementHandle instances can be passed as an argument to the <code>page.evaluate</code>:
Shortcut for page.mainFrame().evaluate(pageFunction[, arg]).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>Function to be evaluated in the page context</dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Optional[Any]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>Promise which resolves to the return value of <code>pageFunction</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(
    self, expression: str, arg: typing.Any = None, force_expr: bool = None
) -&gt; typing.Any:
    &#34;&#34;&#34;Page.evaluate

    If the function passed to the `page.evaluate` returns a Promise, then `page.evaluate` would wait for the promise to resolve and return its value.
    If the function passed to the `page.evaluate` returns a non-Serializable value, then `page.evaluate` resolves to `undefined`. DevTools Protocol also supports transferring some additional values that are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and bigint literals.
    Passing argument to `pageFunction`:
    A string can also be passed in instead of a function:
    ElementHandle instances can be passed as an argument to the `page.evaluate`:
    Shortcut for page.mainFrame().evaluate(pageFunction[, arg]).

    Parameters
    ----------
    expression : str
        Function to be evaluated in the page context
    force_expr : bool
        Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
    arg : Optional[Any]
        Optional argument to pass to `pageFunction`

    Returns
    -------
    Any
        Promise which resolves to the return value of `pageFunction`
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.evaluate(
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.evaluateHandle"><code class="name flex">
<span>def <span class="ident">evaluateHandle</span></span>(<span>self, expression: str, arg: Any = None, force_expr: bool = None) ‑> <a title="playwright.sync_api.JSHandle" href="#playwright.sync_api.JSHandle">JSHandle</a></span>
</code></dt>
<dd>
<div class="desc"><p>Page.evaluateHandle</p>
<p>The only difference between <code>page.evaluate</code> and <code>page.evaluateHandle</code> is that <code>page.evaluateHandle</code> returns in-page object (JSHandle).
If the function passed to the <code>page.evaluateHandle</code> returns a Promise, then <code>page.evaluateHandle</code> would wait for the promise to resolve and return its value.
A string can also be passed in instead of a function:
JSHandle instances can be passed as an argument to the <code>page.evaluateHandle</code>:</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>Function to be evaluated in the page context</dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Optional[Any]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.JSHandle" href="#playwright.sync_api.JSHandle">JSHandle</a></code></dt>
<dd>Promise which resolves to the return value of <code>pageFunction</code> as in-page object (JSHandle)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluateHandle(
    self, expression: str, arg: typing.Any = None, force_expr: bool = None
) -&gt; &#34;JSHandle&#34;:
    &#34;&#34;&#34;Page.evaluateHandle

    The only difference between `page.evaluate` and `page.evaluateHandle` is that `page.evaluateHandle` returns in-page object (JSHandle).
    If the function passed to the `page.evaluateHandle` returns a Promise, then `page.evaluateHandle` would wait for the promise to resolve and return its value.
    A string can also be passed in instead of a function:
    JSHandle instances can be passed as an argument to the `page.evaluateHandle`:

    Parameters
    ----------
    expression : str
        Function to be evaluated in the page context
    force_expr : bool
        Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
    arg : Optional[Any]
        Optional argument to pass to `pageFunction`

    Returns
    -------
    JSHandle
        Promise which resolves to the return value of `pageFunction` as in-page object (JSHandle)
    &#34;&#34;&#34;
    return mapping.from_impl(
        self._sync(
            self._impl_obj.evaluateHandle(
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.expect_console_message"><code class="name flex">
<span>def <span class="ident">expect_console_message</span></span>(<span>self, predicate: Callable[[ForwardRef('<a title="playwright.sync_api.ConsoleMessage" href="#playwright.sync_api.ConsoleMessage">ConsoleMessage</a>')], bool] = None, timeout: int = None) ‑> playwright.sync_base.EventContextManager[<a title="playwright.sync_api.ConsoleMessage" href="#playwright.sync_api.ConsoleMessage">ConsoleMessage</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_console_message(
    self,
    predicate: typing.Union[typing.Callable[[&#34;ConsoleMessage&#34;], bool]] = None,
    timeout: int = None,
) -&gt; EventContextManager[&#34;ConsoleMessage&#34;]:
    event = &#34;console&#34;
    return EventContextManager(
        self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.expect_dialog"><code class="name flex">
<span>def <span class="ident">expect_dialog</span></span>(<span>self, predicate: Callable[[ForwardRef('<a title="playwright.sync_api.Dialog" href="#playwright.sync_api.Dialog">Dialog</a>')], bool] = None, timeout: int = None) ‑> playwright.sync_base.EventContextManager[<a title="playwright.sync_api.Dialog" href="#playwright.sync_api.Dialog">Dialog</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_dialog(
    self,
    predicate: typing.Union[typing.Callable[[&#34;Dialog&#34;], bool]] = None,
    timeout: int = None,
) -&gt; EventContextManager[&#34;Dialog&#34;]:
    event = &#34;dialog&#34;
    return EventContextManager(
        self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.expect_download"><code class="name flex">
<span>def <span class="ident">expect_download</span></span>(<span>self, predicate: Callable[[ForwardRef('<a title="playwright.sync_api.Download" href="#playwright.sync_api.Download">Download</a>')], bool] = None, timeout: int = None) ‑> playwright.sync_base.EventContextManager[<a title="playwright.sync_api.Download" href="#playwright.sync_api.Download">Download</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_download(
    self,
    predicate: typing.Union[typing.Callable[[&#34;Download&#34;], bool]] = None,
    timeout: int = None,
) -&gt; EventContextManager[&#34;Download&#34;]:
    event = &#34;download&#34;
    return EventContextManager(
        self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.expect_event"><code class="name flex">
<span>def <span class="ident">expect_event</span></span>(<span>self, event: str, predicate: Callable[[Any], bool] = None, timeout: int = None) ‑> playwright.sync_base.EventContextManager</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_event(
    self,
    event: str,
    predicate: typing.Union[typing.Callable[[typing.Any], bool]] = None,
    timeout: int = None,
) -&gt; EventContextManager:
    return EventContextManager(
        self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.expect_file_chooser"><code class="name flex">
<span>def <span class="ident">expect_file_chooser</span></span>(<span>self, predicate: Callable[[ForwardRef('<a title="playwright.sync_api.FileChooser" href="#playwright.sync_api.FileChooser">FileChooser</a>')], bool] = None, timeout: int = None) ‑> playwright.sync_base.EventContextManager[<a title="playwright.sync_api.FileChooser" href="#playwright.sync_api.FileChooser">FileChooser</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_file_chooser(
    self,
    predicate: typing.Union[typing.Callable[[&#34;FileChooser&#34;], bool]] = None,
    timeout: int = None,
) -&gt; EventContextManager[&#34;FileChooser&#34;]:
    event = &#34;filechooser&#34;
    return EventContextManager(
        self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.expect_load_state"><code class="name flex">
<span>def <span class="ident">expect_load_state</span></span>(<span>self, state: Literal['domcontentloaded', 'load', 'networkidle'] = None, timeout: int = None) ‑> playwright.sync_base.EventContextManager[typing.Union[<a title="playwright.async_api.Response" href="async_api.html#playwright.async_api.Response">Response</a>, NoneType]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_load_state(
    self,
    state: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    timeout: int = None,
) -&gt; EventContextManager[typing.Union[&#34;Response&#34;, NoneType]]:
    return EventContextManager(
        self._loop, self._impl_obj.waitForLoadState(state, timeout)
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.expect_navigation"><code class="name flex">
<span>def <span class="ident">expect_navigation</span></span>(<span>self, url: Union[str, Pattern, Callable[[str], bool]] = None, waitUntil: Literal['domcontentloaded', 'load', 'networkidle'] = None, timeout: int = None) ‑> playwright.sync_base.EventContextManager[typing.Union[<a title="playwright.async_api.Response" href="async_api.html#playwright.async_api.Response">Response</a>, NoneType]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_navigation(
    self,
    url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
    waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    timeout: int = None,
) -&gt; EventContextManager[typing.Union[&#34;Response&#34;, NoneType]]:
    return EventContextManager(
        self._loop, self._impl_obj.waitForNavigation(url, waitUntil, timeout)
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.expect_popup"><code class="name flex">
<span>def <span class="ident">expect_popup</span></span>(<span>self, predicate: Callable[[ForwardRef('<a title="playwright.sync_api.Page" href="#playwright.sync_api.Page">Page</a>')], bool] = None, timeout: int = None) ‑> playwright.sync_base.EventContextManager[<a title="playwright.sync_api.Page" href="#playwright.sync_api.Page">Page</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_popup(
    self,
    predicate: typing.Union[typing.Callable[[&#34;Page&#34;], bool]] = None,
    timeout: int = None,
) -&gt; EventContextManager[&#34;Page&#34;]:
    event = &#34;popup&#34;
    return EventContextManager(
        self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.expect_request"><code class="name flex">
<span>def <span class="ident">expect_request</span></span>(<span>self, url: Union[str, Pattern, Callable[[str], bool]] = None, predicate: Callable[[ForwardRef('<a title="playwright.sync_api.Request" href="#playwright.sync_api.Request">Request</a>')], bool] = None, timeout: int = None) ‑> playwright.sync_base.EventContextManager[<a title="playwright.sync_api.Request" href="#playwright.sync_api.Request">Request</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_request(
    self,
    url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
    predicate: typing.Union[typing.Callable[[&#34;Request&#34;], bool]] = None,
    timeout: int = None,
) -&gt; EventContextManager[&#34;Request&#34;]:
    return EventContextManager(
        self._loop, self._impl_obj.waitForRequest(url, predicate, timeout)
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.expect_response"><code class="name flex">
<span>def <span class="ident">expect_response</span></span>(<span>self, url: Union[str, Pattern, Callable[[str], bool]] = None, predicate: Callable[[ForwardRef('<a title="playwright.sync_api.Request" href="#playwright.sync_api.Request">Request</a>')], bool] = None, timeout: int = None) ‑> playwright.sync_base.EventContextManager[<a title="playwright.sync_api.Response" href="#playwright.sync_api.Response">Response</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_response(
    self,
    url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
    predicate: typing.Union[typing.Callable[[&#34;Request&#34;], bool]] = None,
    timeout: int = None,
) -&gt; EventContextManager[&#34;Response&#34;]:
    return EventContextManager(
        self._loop, self._impl_obj.waitForResponse(url, predicate, timeout)
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.expect_worker"><code class="name flex">
<span>def <span class="ident">expect_worker</span></span>(<span>self, predicate: Callable[[ForwardRef('<a title="playwright.sync_api.Worker" href="#playwright.sync_api.Worker">Worker</a>')], bool] = None, timeout: int = None) ‑> playwright.sync_base.EventContextManager[<a title="playwright.sync_api.Worker" href="#playwright.sync_api.Worker">Worker</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_worker(
    self,
    predicate: typing.Union[typing.Callable[[&#34;Worker&#34;], bool]] = None,
    timeout: int = None,
) -&gt; EventContextManager[&#34;Worker&#34;]:
    event = &#34;worker&#34;
    return EventContextManager(
        self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.exposeBinding"><code class="name flex">
<span>def <span class="ident">exposeBinding</span></span>(<span>self, name: str, binding: Callable, handle: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.exposeBinding</p>
<p>The method adds a function called <code>name</code> on the <code>window</code> object of every frame in this page.
When called, the function executes <code>playwrightBinding</code> in Node.js and returns a Promise which resolves to the return value of <code>playwrightBinding</code>.
If the <code>playwrightBinding</code> returns a Promise, it will be awaited.
The first argument of the <code>playwrightBinding</code> function contains information about the caller:
<code>{ browserContext: BrowserContext, page: Page, frame: Frame }</code>.
See browserContext.exposeBinding(name, playwrightBinding) for the context-wide version.</p>
<p><strong>NOTE</strong> Functions installed via <code>page.exposeBinding</code> survive navigations.</p>
<p>An example of exposing page URL to all frames in a page:</p>
<p>An example of passing an element handle:</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the function on the window object.</dd>
<dt><strong><code>binding</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Callback function that will be called in the Playwright's context.</dd>
<dt><strong><code>handle</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to pass the argument as a handle, instead of passing by value. When passing a handle, only one argument is supported. When passing by value, multiple arguments are supported.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exposeBinding(
    self, name: str, binding: typing.Callable, handle: bool = None
) -&gt; NoneType:
    &#34;&#34;&#34;Page.exposeBinding

    The method adds a function called `name` on the `window` object of every frame in this page.
    When called, the function executes `playwrightBinding` in Node.js and returns a Promise which resolves to the return value of `playwrightBinding`.
    If the `playwrightBinding` returns a Promise, it will be awaited.
    The first argument of the `playwrightBinding` function contains information about the caller:
    `{ browserContext: BrowserContext, page: Page, frame: Frame }`.
    See browserContext.exposeBinding(name, playwrightBinding) for the context-wide version.

    **NOTE** Functions installed via `page.exposeBinding` survive navigations.

    An example of exposing page URL to all frames in a page:

    An example of passing an element handle:

    Parameters
    ----------
    name : str
        Name of the function on the window object.
    binding : Callable
        Callback function that will be called in the Playwright&#39;s context.
    handle : Optional[bool]
        Whether to pass the argument as a handle, instead of passing by value. When passing a handle, only one argument is supported. When passing by value, multiple arguments are supported.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.exposeBinding(
                name=name, binding=self._wrap_handler(binding), handle=handle
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.exposeFunction"><code class="name flex">
<span>def <span class="ident">exposeFunction</span></span>(<span>self, name: str, binding: Callable) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.exposeFunction</p>
<p>The method adds a function called <code>name</code> on the <code>window</code> object of every frame in the page.
When called, the function executes <code>playwrightFunction</code> in Node.js and returns a Promise which resolves to the return value of <code>playwrightFunction</code>.
If the <code>playwrightFunction</code> returns a Promise, it will be awaited.
See browserContext.exposeFunction(name, playwrightFunction) for context-wide exposed function.</p>
<p><strong>NOTE</strong> Functions installed via <code>page.exposeFunction</code> survive navigations.</p>
<p>An example of adding an <code>md5</code> function to the page:</p>
<p>An example of adding a <code>window.readfile</code> function to the page:</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the function on the window object</dd>
<dt><strong><code>binding</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Callback function which will be called in Playwright's context.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exposeFunction(self, name: str, binding: typing.Callable) -&gt; NoneType:
    &#34;&#34;&#34;Page.exposeFunction

    The method adds a function called `name` on the `window` object of every frame in the page.
    When called, the function executes `playwrightFunction` in Node.js and returns a Promise which resolves to the return value of `playwrightFunction`.
    If the `playwrightFunction` returns a Promise, it will be awaited.
    See browserContext.exposeFunction(name, playwrightFunction) for context-wide exposed function.

    **NOTE** Functions installed via `page.exposeFunction` survive navigations.

    An example of adding an `md5` function to the page:

    An example of adding a `window.readfile` function to the page:

    Parameters
    ----------
    name : str
        Name of the function on the window object
    binding : Callable
        Callback function which will be called in Playwright&#39;s context.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.exposeFunction(
                name=name, binding=self._wrap_handler(binding)
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.fill"><code class="name flex">
<span>def <span class="ident">fill</span></span>(<span>self, selector: str, value: str, timeout: int = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.fill</p>
<p>This method waits for an element matching <code>selector</code>, waits for actionability checks, focuses the element, fills it and triggers an <code>input</code> event after filling.
If the element matching <code>selector</code> is not an <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> or <code>[contenteditable]</code> element, this method throws an error.
Note that you can pass an empty string to clear the input field.
To send fine-grained keyboard events, use <code>page.type</code>.
Shortcut for page.mainFrame().fill()</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query page for. See working with selectors for more details.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>Value to fill for the <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> or <code>[contenteditable]</code> element.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fill(
    self, selector: str, value: str, timeout: int = None, noWaitAfter: bool = None
) -&gt; NoneType:
    &#34;&#34;&#34;Page.fill

    This method waits for an element matching `selector`, waits for actionability checks, focuses the element, fills it and triggers an `input` event after filling.
    If the element matching `selector` is not an `&lt;input&gt;`, `&lt;textarea&gt;` or `[contenteditable]` element, this method throws an error.
    Note that you can pass an empty string to clear the input field.
    To send fine-grained keyboard events, use `page.type`.
    Shortcut for page.mainFrame().fill()

    Parameters
    ----------
    selector : str
        A selector to query page for. See working with selectors for more details.
    value : str
        Value to fill for the `&lt;input&gt;`, `&lt;textarea&gt;` or `[contenteditable]` element.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.fill(
                selector=selector,
                value=value,
                timeout=timeout,
                noWaitAfter=noWaitAfter,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.focus"><code class="name flex">
<span>def <span class="ident">focus</span></span>(<span>self, selector: str, timeout: int = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.focus</p>
<p>This method fetches an element with <code>selector</code> and focuses it.
If there's no element matching <code>selector</code>, the method waits until a matching element appears in the DOM.
Shortcut for page.mainFrame().focus(selector).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector of an element to focus. If there are multiple elements satisfying the selector, the first will be focused. See working with selectors for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def focus(self, selector: str, timeout: int = None) -&gt; NoneType:
    &#34;&#34;&#34;Page.focus

    This method fetches an element with `selector` and focuses it.
    If there&#39;s no element matching `selector`, the method waits until a matching element appears in the DOM.
    Shortcut for page.mainFrame().focus(selector).

    Parameters
    ----------
    selector : str
        A selector of an element to focus. If there are multiple elements satisfying the selector, the first will be focused. See working with selectors for more details.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.focus(selector=selector, timeout=timeout))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.frame"><code class="name flex">
<span>def <span class="ident">frame</span></span>(<span>self, name: str = None, url: Union[str, Pattern, Callable[[str], bool]] = None) ‑> Union[<a title="playwright.async_api.Frame" href="async_api.html#playwright.async_api.Frame">Frame</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.frame</p>
<p>Returns frame matching the specified criteria. Either <code>name</code> or <code>url</code> must be specified.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>frame name specified in the <code>iframe</code>'s <code>name</code> attribute</dd>
<dt><strong><code>url</code></strong> :&ensp;<code>Union[str, Pattern, typing.Callable[[str], bool], NoneType]</code></dt>
<dd>A glob pattern, regex pattern or predicate receiving frame's <code>url</code> as a URL object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[<a title="playwright.sync_api.Frame" href="#playwright.sync_api.Frame">Frame</a>]</code></dt>
<dd>frame matching the criteria. Returns <code>null</code> if no frame matches.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def frame(
    self,
    name: str = None,
    url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
) -&gt; typing.Union[&#34;Frame&#34;, NoneType]:
    &#34;&#34;&#34;Page.frame

    Returns frame matching the specified criteria. Either `name` or `url` must be specified.

    Parameters
    ----------
    name : Optional[str]
        frame name specified in the `iframe`&#39;s `name` attribute
    url : Union[str, Pattern, typing.Callable[[str], bool], NoneType]
        A glob pattern, regex pattern or predicate receiving frame&#39;s `url` as a URL object.

    Returns
    -------
    Optional[Frame]
        frame matching the criteria. Returns `null` if no frame matches.
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(
        self._impl_obj.frame(name=name, url=self._wrap_handler(url))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.getAttribute"><code class="name flex">
<span>def <span class="ident">getAttribute</span></span>(<span>self, selector: str, name: str, timeout: int = None) ‑> Union[str, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.getAttribute</p>
<p>Returns element attribute value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Attribute name to get the value for.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[str]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAttribute(
    self, selector: str, name: str, timeout: int = None
) -&gt; typing.Union[str, NoneType]:
    &#34;&#34;&#34;Page.getAttribute

    Returns element attribute value.

    Parameters
    ----------
    selector : str
        A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.
    name : str
        Attribute name to get the value for.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

    Returns
    -------
    Optional[str]
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.getAttribute(
                selector=selector, name=name, timeout=timeout
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.goBack"><code class="name flex">
<span>def <span class="ident">goBack</span></span>(<span>self, timeout: int = None, waitUntil: Literal['domcontentloaded', 'load', 'networkidle'] = None) ‑> Union[<a title="playwright.async_api.Response" href="async_api.html#playwright.async_api.Response">Response</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.goBack</p>
<p>Navigate to the previous page in history.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum navigation time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>waitUntil</code></strong> :&ensp;<code>Optional[Literal['domcontentloaded', 'load', 'networkidle']]</code></dt>
<dd>When to consider navigation succeeded, defaults to <code>load</code>. Events can be either:
- <code>'domcontentloaded'</code> - consider navigation to be finished when the <code>DOMContentLoaded</code> event is fired.
- <code>'load'</code> - consider navigation to be finished when the <code>load</code> event is fired.
- <code>'networkidle'</code> - consider navigation to be finished when there are no network connections for at least <code>500</code> ms.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[<a title="playwright.sync_api.Response" href="#playwright.sync_api.Response">Response</a>]</code></dt>
<dd>Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect. If
can not go back, resolves to <code>null</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def goBack(
    self,
    timeout: int = None,
    waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
    &#34;&#34;&#34;Page.goBack

    Navigate to the previous page in history.

    Parameters
    ----------
    timeout : Optional[int]
        Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    waitUntil : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
        When to consider navigation succeeded, defaults to `load`. Events can be either:
         - `&#39;domcontentloaded&#39;` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
         - `&#39;load&#39;` - consider navigation to be finished when the `load` event is fired.
         - `&#39;networkidle&#39;` - consider navigation to be finished when there are no network connections for at least `500` ms.

    Returns
    -------
    Optional[Response]
        Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect. If
          can not go back, resolves to `null`.
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(
        self._sync(self._impl_obj.goBack(timeout=timeout, waitUntil=waitUntil))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.goForward"><code class="name flex">
<span>def <span class="ident">goForward</span></span>(<span>self, timeout: int = None, waitUntil: Literal['domcontentloaded', 'load', 'networkidle'] = None) ‑> Union[<a title="playwright.async_api.Response" href="async_api.html#playwright.async_api.Response">Response</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.goForward</p>
<p>Navigate to the next page in history.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum navigation time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>waitUntil</code></strong> :&ensp;<code>Optional[Literal['domcontentloaded', 'load', 'networkidle']]</code></dt>
<dd>When to consider navigation succeeded, defaults to <code>load</code>. Events can be either:
- <code>'domcontentloaded'</code> - consider navigation to be finished when the <code>DOMContentLoaded</code> event is fired.
- <code>'load'</code> - consider navigation to be finished when the <code>load</code> event is fired.
- <code>'networkidle'</code> - consider navigation to be finished when there are no network connections for at least <code>500</code> ms.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[<a title="playwright.sync_api.Response" href="#playwright.sync_api.Response">Response</a>]</code></dt>
<dd>Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect. If
can not go forward, resolves to <code>null</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def goForward(
    self,
    timeout: int = None,
    waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
    &#34;&#34;&#34;Page.goForward

    Navigate to the next page in history.

    Parameters
    ----------
    timeout : Optional[int]
        Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    waitUntil : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
        When to consider navigation succeeded, defaults to `load`. Events can be either:
         - `&#39;domcontentloaded&#39;` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
         - `&#39;load&#39;` - consider navigation to be finished when the `load` event is fired.
         - `&#39;networkidle&#39;` - consider navigation to be finished when there are no network connections for at least `500` ms.

    Returns
    -------
    Optional[Response]
        Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect. If
          can not go forward, resolves to `null`.
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(
        self._sync(self._impl_obj.goForward(timeout=timeout, waitUntil=waitUntil))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.goto"><code class="name flex">
<span>def <span class="ident">goto</span></span>(<span>self, url: str, timeout: int = None, waitUntil: Literal['domcontentloaded', 'load', 'networkidle'] = None, referer: str = None) ‑> Union[<a title="playwright.async_api.Response" href="async_api.html#playwright.async_api.Response">Response</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.goto</p>
<p><code>page.goto</code> will throw an error if:</p>
<p>there's an SSL error (e.g. in case of self-signed certificates).
target URL is invalid.
the <code>timeout</code> is exceeded during navigation.
the remote server does not respond or is unreachable.
the main resource failed to load.</p>
<p><code>page.goto</code> will not throw an error when any valid HTTP status code is returned by the remote server, including 404 "Not Found" and 500 "Internal Server Error".
The status code for such responses can be retrieved by calling response.status().</p>
<p><strong>NOTE</strong> <code>page.goto</code> either throws an error or returns a main resource response. The only exceptions are navigation to <code>about:blank</code> or navigation to the same URL with a different hash, which would succeed and return <code>null</code>.</p>
<p><strong>NOTE</strong> Headless mode doesn't support navigation to a PDF document. See the upstream issue.</p>
<p>Shortcut for page.mainFrame().goto(url[, options])</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>URL to navigate page to. The url should include scheme, e.g. <code>https://</code>.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum navigation time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>waitUntil</code></strong> :&ensp;<code>Optional[Literal['domcontentloaded', 'load', 'networkidle']]</code></dt>
<dd>When to consider navigation succeeded, defaults to <code>load</code>. Events can be either:
- <code>'domcontentloaded'</code> - consider navigation to be finished when the <code>DOMContentLoaded</code> event is fired.
- <code>'load'</code> - consider navigation to be finished when the <code>load</code> event is fired.
- <code>'networkidle'</code> - consider navigation to be finished when there are no network connections for at least <code>500</code> ms.</dd>
<dt><strong><code>referer</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Referer header value. If provided it will take preference over the referer header value set by page.setExtraHTTPHeaders().</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[<a title="playwright.sync_api.Response" href="#playwright.sync_api.Response">Response</a>]</code></dt>
<dd>Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def goto(
    self,
    url: str,
    timeout: int = None,
    waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    referer: str = None,
) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
    &#34;&#34;&#34;Page.goto

    `page.goto` will throw an error if:

    there&#39;s an SSL error (e.g. in case of self-signed certificates).
    target URL is invalid.
    the `timeout` is exceeded during navigation.
    the remote server does not respond or is unreachable.
    the main resource failed to load.

    `page.goto` will not throw an error when any valid HTTP status code is returned by the remote server, including 404 &#34;Not Found&#34; and 500 &#34;Internal Server Error&#34;.  The status code for such responses can be retrieved by calling response.status().

    **NOTE** `page.goto` either throws an error or returns a main resource response. The only exceptions are navigation to `about:blank` or navigation to the same URL with a different hash, which would succeed and return `null`.

    **NOTE** Headless mode doesn&#39;t support navigation to a PDF document. See the upstream issue.

    Shortcut for page.mainFrame().goto(url[, options])

    Parameters
    ----------
    url : str
        URL to navigate page to. The url should include scheme, e.g. `https://`.
    timeout : Optional[int]
        Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    waitUntil : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
        When to consider navigation succeeded, defaults to `load`. Events can be either:
         - `&#39;domcontentloaded&#39;` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
         - `&#39;load&#39;` - consider navigation to be finished when the `load` event is fired.
         - `&#39;networkidle&#39;` - consider navigation to be finished when there are no network connections for at least `500` ms.
    referer : Optional[str]
        Referer header value. If provided it will take preference over the referer header value set by page.setExtraHTTPHeaders().

    Returns
    -------
    Optional[Response]
        Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect.
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(
        self._sync(
            self._impl_obj.goto(
                url=url, timeout=timeout, waitUntil=waitUntil, referer=referer
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.hover"><code class="name flex">
<span>def <span class="ident">hover</span></span>(<span>self, selector: str, modifiers: List[Literal['Alt', 'Control', 'Meta', 'Shift']] = None, position: playwright.helper.MousePosition = None, timeout: int = None, force: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.hover</p>
<p>This method hovers over an element matching <code>selector</code> by performing the following steps:</p>
<p>Find an element match matching <code>selector</code>. If there is none, wait until a matching element is attached to the DOM.
Wait for actionability checks on the matched element, unless <code>force</code> option is set. If the element is detached during the checks, the whole action is retried.
Scroll the element into view if needed.
Use page.mouse to hover over the center of the element, or the specified <code>position</code>.
Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a TimeoutError. Passing zero timeout disables this.
Shortcut for page.mainFrame().hover(selector[, options]).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element to hover. If there are multiple elements satisfying the selector, the first will be hovered. See working with selectors for more details.</dd>
<dt><strong><code>modifiers</code></strong> :&ensp;<code>Optional[List[Literal['Alt', 'Control', 'Meta', 'Shift']]]</code></dt>
<dd>Modifier keys to press. Ensures that only these modifiers are pressed during the hover, and then restores current modifiers back. If not specified, currently pressed modifiers are used.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>Optional[{"x": float, "y": float}]</code></dt>
<dd>A point to hover relative to the top-left corner of element padding box. If not specified, hovers over some visible point of the element.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to bypass the actionability checks. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hover(
    self,
    selector: str,
    modifiers: typing.Union[
        typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
    ] = None,
    position: MousePosition = None,
    timeout: int = None,
    force: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.hover

    This method hovers over an element matching `selector` by performing the following steps:

    Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
    Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
    Scroll the element into view if needed.
    Use page.mouse to hover over the center of the element, or the specified `position`.
    Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.
    Shortcut for page.mainFrame().hover(selector[, options]).

    Parameters
    ----------
    selector : str
        A selector to search for element to hover. If there are multiple elements satisfying the selector, the first will be hovered. See working with selectors for more details.
    modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
        Modifier keys to press. Ensures that only these modifiers are pressed during the hover, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
    position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
        A point to hover relative to the top-left corner of element padding box. If not specified, hovers over some visible point of the element.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    force : Optional[bool]
        Whether to bypass the actionability checks. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.hover(
                selector=selector,
                modifiers=modifiers,
                position=position,
                timeout=timeout,
                force=force,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.innerHTML"><code class="name flex">
<span>def <span class="ident">innerHTML</span></span>(<span>self, selector: str, timeout: int = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Page.innerHTML</p>
<p>Resolves to the <code>element.innerHTML</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def innerHTML(self, selector: str, timeout: int = None) -&gt; str:
    &#34;&#34;&#34;Page.innerHTML

    Resolves to the `element.innerHTML`.

    Parameters
    ----------
    selector : str
        A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.innerHTML(selector=selector, timeout=timeout))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.innerText"><code class="name flex">
<span>def <span class="ident">innerText</span></span>(<span>self, selector: str, timeout: int = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Page.innerText</p>
<p>Resolves to the <code>element.innerText</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def innerText(self, selector: str, timeout: int = None) -&gt; str:
    &#34;&#34;&#34;Page.innerText

    Resolves to the `element.innerText`.

    Parameters
    ----------
    selector : str
        A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.innerText(selector=selector, timeout=timeout))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.isClosed"><code class="name flex">
<span>def <span class="ident">isClosed</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Page.isClosed</p>
<p>Indicates that the page has been closed.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isClosed(self) -&gt; bool:
    &#34;&#34;&#34;Page.isClosed

    Indicates that the page has been closed.

    Returns
    -------
    bool
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.isClosed())</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.opener"><code class="name flex">
<span>def <span class="ident">opener</span></span>(<span>self) ‑> Union[<a title="playwright.async_api.Page" href="async_api.html#playwright.async_api.Page">Page</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.opener</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[<a title="playwright.sync_api.Page" href="#playwright.sync_api.Page">Page</a>]</code></dt>
<dd>Promise which resolves to the opener for popup pages and <code>null</code> for others. If the opener has been closed already the promise may resolve to <code>null</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def opener(self) -&gt; typing.Union[&#34;Page&#34;, NoneType]:
    &#34;&#34;&#34;Page.opener

    Returns
    -------
    Optional[Page]
        Promise which resolves to the opener for popup pages and `null` for others. If the opener has been closed already the promise may resolve to `null`.
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(self._sync(self._impl_obj.opener()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.pdf"><code class="name flex">
<span>def <span class="ident">pdf</span></span>(<span>self, scale: int = None, displayHeaderFooter: bool = None, headerTemplate: str = None, footerTemplate: str = None, printBackground: bool = None, landscape: bool = None, pageRanges: str = None, format: str = None, width: Union[str, float] = None, height: Union[str, float] = None, preferCSSPageSize: bool = None, margin: playwright.helper.PdfMargins = None, path: Union[str, pathlib.Path] = None) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Page.pdf</p>
<p><strong>NOTE</strong> Generating a pdf is currently only supported in Chromium headless.</p>
<p><code>page.pdf()</code> generates a pdf of the page with <code>print</code> css media. To generate a pdf with <code>screen</code> media, call page.emulateMedia({ media: 'screen' }) before calling <code>page.pdf()</code>:</p>
<p><strong>NOTE</strong> By default, <code>page.pdf()</code> generates a pdf with modified colors for printing. Use the <code>-webkit-print-color-adjust</code> property to force rendering of exact colors.</p>
<p>The <code>width</code>, <code>height</code>, and <code>margin</code> options accept values labeled with units. Unlabeled values are treated as pixels.
A few examples:</p>
<p><code>page.pdf({width: 100})</code> - prints with width set to 100 pixels
<code>page.pdf({width: '100px'})</code> - prints with width set to 100 pixels
<code>page.pdf({width: '10cm'})</code> - prints with width set to 10 centimeters.</p>
<p>All possible units are:</p>
<p><code>px</code> - pixel
<code>in</code> - inch
<code>cm</code> - centimeter
<code>mm</code> - millimeter</p>
<p>The <code>format</code> options are:</p>
<p><code>Letter</code>: 8.5in x 11in
<code>Legal</code>: 8.5in x 14in
<code>Tabloid</code>: 11in x 17in
<code>Ledger</code>: 17in x 11in
<code>A0</code>: 33.1in x 46.8in
<code>A1</code>: 23.4in x 33.1in
<code>A2</code>: 16.54in x 23.4in
<code>A3</code>: 11.7in x 16.54in
<code>A4</code>: 8.27in x 11.7in
<code>A5</code>: 5.83in x 8.27in
<code>A6</code>: 4.13in x 5.83in</p>
<p><strong>NOTE</strong> <code>headerTemplate</code> and <code>footerTemplate</code> markup have the following limitations:</p>
<p>Script tags inside templates are not evaluated.
Page styles are not visible inside templates.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>scale</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Scale of the webpage rendering. Defaults to <code>1</code>. Scale amount must be between 0.1 and 2.</dd>
<dt><strong><code>displayHeaderFooter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Display header and footer. Defaults to <code>false</code>.</dd>
<dt><strong><code>headerTemplate</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them:
- <code>'date'</code> formatted print date
- <code>'title'</code> document title
- <code>'url'</code> document location
- <code>'pageNumber'</code> current page number
- <code>'totalPages'</code> total pages in the document</dd>
<dt><strong><code>footerTemplate</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>HTML template for the print footer. Should use the same format as the <code>headerTemplate</code>.</dd>
<dt><strong><code>printBackground</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Print background graphics. Defaults to <code>false</code>.</dd>
<dt><strong><code>landscape</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Paper orientation. Defaults to <code>false</code>.</dd>
<dt><strong><code>pageRanges</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Paper ranges to print, e.g., '1-5, 8, 11-13'. Defaults to the empty string, which means print all pages.</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Paper format. If set, takes priority over <code>width</code> or <code>height</code> options. Defaults to 'Letter'.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>Union[str, float, NoneType]</code></dt>
<dd>Paper width, accepts values labeled with units.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>Union[str, float, NoneType]</code></dt>
<dd>Paper height, accepts values labeled with units.</dd>
<dt><strong><code>preferCSSPageSize</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Give any CSS <code>@page</code> size declared in the page priority over what is declared in <code>width</code> and <code>height</code> or <code>format</code> options. Defaults to <code>false</code>, which will scale the content to fit the paper size.</dd>
<dt><strong><code>margin</code></strong> :&ensp;<code>Optional[{"top": Union[str, int, NoneType], "right": Union[str, int, NoneType], "bottom": Union[str, int, NoneType], "left": Union[str, int, NoneType]}]</code></dt>
<dd>Paper margins, defaults to none.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[str, pathlib.Path, NoneType]</code></dt>
<dd>The file path to save the PDF to. If <code>path</code> is a relative path, then it is resolved relative to current working directory. If no path is provided, the PDF won't be saved to the disk.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>Promise which resolves with PDF buffer.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pdf(
    self,
    scale: int = None,
    displayHeaderFooter: bool = None,
    headerTemplate: str = None,
    footerTemplate: str = None,
    printBackground: bool = None,
    landscape: bool = None,
    pageRanges: str = None,
    format: str = None,
    width: typing.Union[str, float] = None,
    height: typing.Union[str, float] = None,
    preferCSSPageSize: bool = None,
    margin: PdfMargins = None,
    path: typing.Union[str, pathlib.Path] = None,
) -&gt; bytes:
    &#34;&#34;&#34;Page.pdf

    **NOTE** Generating a pdf is currently only supported in Chromium headless.

    `page.pdf()` generates a pdf of the page with `print` css media. To generate a pdf with `screen` media, call page.emulateMedia({ media: &#39;screen&#39; }) before calling `page.pdf()`:

    **NOTE** By default, `page.pdf()` generates a pdf with modified colors for printing. Use the `-webkit-print-color-adjust` property to force rendering of exact colors.

    The `width`, `height`, and `margin` options accept values labeled with units. Unlabeled values are treated as pixels.
    A few examples:

    `page.pdf({width: 100})` - prints with width set to 100 pixels
    `page.pdf({width: &#39;100px&#39;})` - prints with width set to 100 pixels
    `page.pdf({width: &#39;10cm&#39;})` - prints with width set to 10 centimeters.

    All possible units are:

    `px` - pixel
    `in` - inch
    `cm` - centimeter
    `mm` - millimeter

    The `format` options are:

    `Letter`: 8.5in x 11in
    `Legal`: 8.5in x 14in
    `Tabloid`: 11in x 17in
    `Ledger`: 17in x 11in
    `A0`: 33.1in x 46.8in
    `A1`: 23.4in x 33.1in
    `A2`: 16.54in x 23.4in
    `A3`: 11.7in x 16.54in
    `A4`: 8.27in x 11.7in
    `A5`: 5.83in x 8.27in
    `A6`: 4.13in x 5.83in

    **NOTE** `headerTemplate` and `footerTemplate` markup have the following limitations:

    Script tags inside templates are not evaluated.
    Page styles are not visible inside templates.

    Parameters
    ----------
    scale : Optional[int]
        Scale of the webpage rendering. Defaults to `1`. Scale amount must be between 0.1 and 2.
    displayHeaderFooter : Optional[bool]
        Display header and footer. Defaults to `false`.
    headerTemplate : Optional[str]
        HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them:
         - `&#39;date&#39;` formatted print date
         - `&#39;title&#39;` document title
         - `&#39;url&#39;` document location
         - `&#39;pageNumber&#39;` current page number
         - `&#39;totalPages&#39;` total pages in the document
    footerTemplate : Optional[str]
        HTML template for the print footer. Should use the same format as the `headerTemplate`.
    printBackground : Optional[bool]
        Print background graphics. Defaults to `false`.
    landscape : Optional[bool]
        Paper orientation. Defaults to `false`.
    pageRanges : Optional[str]
        Paper ranges to print, e.g., &#39;1-5, 8, 11-13&#39;. Defaults to the empty string, which means print all pages.
    format : Optional[str]
        Paper format. If set, takes priority over `width` or `height` options. Defaults to &#39;Letter&#39;.
    width : Union[str, float, NoneType]
        Paper width, accepts values labeled with units.
    height : Union[str, float, NoneType]
        Paper height, accepts values labeled with units.
    preferCSSPageSize : Optional[bool]
        Give any CSS `@page` size declared in the page priority over what is declared in `width` and `height` or `format` options. Defaults to `false`, which will scale the content to fit the paper size.
    margin : Optional[{&#34;top&#34;: Union[str, int, NoneType], &#34;right&#34;: Union[str, int, NoneType], &#34;bottom&#34;: Union[str, int, NoneType], &#34;left&#34;: Union[str, int, NoneType]}]
        Paper margins, defaults to none.
    path : Union[str, pathlib.Path, NoneType]
        The file path to save the PDF to. If `path` is a relative path, then it is resolved relative to current working directory. If no path is provided, the PDF won&#39;t be saved to the disk.

    Returns
    -------
    bytes
        Promise which resolves with PDF buffer.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.pdf(
                scale=scale,
                displayHeaderFooter=displayHeaderFooter,
                headerTemplate=headerTemplate,
                footerTemplate=footerTemplate,
                printBackground=printBackground,
                landscape=landscape,
                pageRanges=pageRanges,
                format=format,
                width=width,
                height=height,
                preferCSSPageSize=preferCSSPageSize,
                margin=margin,
                path=path,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.press"><code class="name flex">
<span>def <span class="ident">press</span></span>(<span>self, selector: str, key: str, delay: int = None, timeout: int = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.press</p>
<p>Focuses the element, and then uses <code>keyboard.down</code> and <code>keyboard.up</code>.
<code>key</code> can specify the intended keyboardEvent.key value or a single character to generate the text for. A superset of the <code>key</code> values can be found here. Examples of the keys are:
<code>F1</code> - <code>F12</code>, <code>Digit0</code>- <code>Digit9</code>, <code>KeyA</code>- <code>KeyZ</code>, <code>Backquote</code>, <code>Minus</code>, <code>Equal</code>, <code>Backslash</code>, <code>Backspace</code>, <code>Tab</code>, <code>Delete</code>, <code>Escape</code>, <code>ArrowDown</code>, <code>End</code>, <code>Enter</code>, <code>Home</code>, <code>Insert</code>, <code>PageDown</code>, <code>PageUp</code>, <code>ArrowRight</code>, <code>ArrowUp</code>, etc.
Following modification shortcuts are also suported: <code>Shift</code>, <code>Control</code>, <code>Alt</code>, <code>Meta</code>, <code>ShiftLeft</code>.
Holding down <code>Shift</code> will type the text that corresponds to the <code>key</code> in the upper case.
If <code>key</code> is a single character, it is case-sensitive, so the values <code>a</code> and <code>A</code> will generate different respective texts.
Shortcuts such as <code>key: "Control+o"</code> or <code>key: "Control+Shift+T"</code> are supported as well. When speficied with the modifier, modifier is pressed and being held while the subsequent key is being pressed.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector of an element to type into. If there are multiple elements satisfying the selector, the first will be used. See working with selectors for more details.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the key to press or a character to generate, such as <code>ArrowLeft</code> or <code>a</code>.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Time to wait between <code>keydown</code> and <code>keyup</code> in milliseconds. Defaults to 0.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def press(
    self,
    selector: str,
    key: str,
    delay: int = None,
    timeout: int = None,
    noWaitAfter: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.press

    Focuses the element, and then uses `keyboard.down` and `keyboard.up`.
    `key` can specify the intended keyboardEvent.key value or a single character to generate the text for. A superset of the `key` values can be found here. Examples of the keys are:
    `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`, `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.
    Following modification shortcuts are also suported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`.
    Holding down `Shift` will type the text that corresponds to the `key` in the upper case.
    If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective texts.
    Shortcuts such as `key: &#34;Control+o&#34;` or `key: &#34;Control+Shift+T&#34;` are supported as well. When speficied with the modifier, modifier is pressed and being held while the subsequent key is being pressed.

    Parameters
    ----------
    selector : str
        A selector of an element to type into. If there are multiple elements satisfying the selector, the first will be used. See working with selectors for more details.
    key : str
        Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
    delay : Optional[int]
        Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.press(
                selector=selector,
                key=key,
                delay=delay,
                timeout=timeout,
                noWaitAfter=noWaitAfter,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.querySelector"><code class="name flex">
<span>def <span class="ident">querySelector</span></span>(<span>self, selector: str) ‑> Union[<a title="playwright.async_api.ElementHandle" href="async_api.html#playwright.async_api.ElementHandle">ElementHandle</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.querySelector</p>
<p>The method finds an element matching the specified selector within the page. If no elements match the selector, the return value resolves to <code>null</code>.
Shortcut for page.mainFrame().$(selector).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query page for. See working with selectors for more details.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[<a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def querySelector(self, selector: str) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
    &#34;&#34;&#34;Page.querySelector

    The method finds an element matching the specified selector within the page. If no elements match the selector, the return value resolves to `null`.
    Shortcut for page.mainFrame().$(selector).

    Parameters
    ----------
    selector : str
        A selector to query page for. See working with selectors for more details.

    Returns
    -------
    Optional[ElementHandle]
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(
        self._sync(self._impl_obj.querySelector(selector=selector))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.querySelectorAll"><code class="name flex">
<span>def <span class="ident">querySelectorAll</span></span>(<span>self, selector: str) ‑> List[<a title="playwright.async_api.ElementHandle" href="async_api.html#playwright.async_api.ElementHandle">ElementHandle</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.querySelectorAll</p>
<p>The method finds all elements matching the specified selector within the page. If no elements match the selector, the return value resolves to <code>[]</code>.
Shortcut for page.mainFrame().$$(selector).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query page for. See working with selectors for more details.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def querySelectorAll(self, selector: str) -&gt; typing.List[&#34;ElementHandle&#34;]:
    &#34;&#34;&#34;Page.querySelectorAll

    The method finds all elements matching the specified selector within the page. If no elements match the selector, the return value resolves to `[]`.
    Shortcut for page.mainFrame().$$(selector).

    Parameters
    ----------
    selector : str
        A selector to query page for. See working with selectors for more details.

    Returns
    -------
    List[ElementHandle]
    &#34;&#34;&#34;
    return mapping.from_impl_list(
        self._sync(self._impl_obj.querySelectorAll(selector=selector))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.reload"><code class="name flex">
<span>def <span class="ident">reload</span></span>(<span>self, timeout: int = None, waitUntil: Literal['domcontentloaded', 'load', 'networkidle'] = None) ‑> Union[<a title="playwright.async_api.Response" href="async_api.html#playwright.async_api.Response">Response</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.reload</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum navigation time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>waitUntil</code></strong> :&ensp;<code>Optional[Literal['domcontentloaded', 'load', 'networkidle']]</code></dt>
<dd>When to consider navigation succeeded, defaults to <code>load</code>. Events can be either:
- <code>'domcontentloaded'</code> - consider navigation to be finished when the <code>DOMContentLoaded</code> event is fired.
- <code>'load'</code> - consider navigation to be finished when the <code>load</code> event is fired.
- <code>'networkidle'</code> - consider navigation to be finished when there are no network connections for at least <code>500</code> ms.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[<a title="playwright.sync_api.Response" href="#playwright.sync_api.Response">Response</a>]</code></dt>
<dd>Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reload(
    self,
    timeout: int = None,
    waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
    &#34;&#34;&#34;Page.reload

    Parameters
    ----------
    timeout : Optional[int]
        Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    waitUntil : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
        When to consider navigation succeeded, defaults to `load`. Events can be either:
         - `&#39;domcontentloaded&#39;` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
         - `&#39;load&#39;` - consider navigation to be finished when the `load` event is fired.
         - `&#39;networkidle&#39;` - consider navigation to be finished when there are no network connections for at least `500` ms.

    Returns
    -------
    Optional[Response]
        Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect.
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(
        self._sync(self._impl_obj.reload(timeout=timeout, waitUntil=waitUntil))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.route"><code class="name flex">
<span>def <span class="ident">route</span></span>(<span>self, url: Union[str, Pattern, Callable[[str], bool]], handler: Callable[[ForwardRef('<a title="playwright.sync_api.Route" href="#playwright.sync_api.Route">Route</a>'), ForwardRef('<a title="playwright.sync_api.Request" href="#playwright.sync_api.Request">Request</a>')], Any]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.route</p>
<p>Routing provides the capability to modify network requests that are made by a page.
Once routing is enabled, every request matching the url pattern will stall unless it's continued, fulfilled or aborted.</p>
<p><strong>NOTE</strong> The handler will only be called for the first url if the response is a redirect.</p>
<p>An example of a naïve handler that aborts all image requests:
or the same snippet using a regex pattern instead:
Page routes take precedence over browser context routes (set up with browserContext.route(url, handler)) when request matches both handlers.</p>
<p><strong>NOTE</strong> Enabling routing disables http cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>Union[str, Pattern, typing.Callable[[str], bool]]</code></dt>
<dd>A glob pattern, regex pattern or predicate receiving URL to match while routing.</dd>
<dt><strong><code>handler</code></strong> :&ensp;<code>typing.Callable[[playwright.network.Route, playwright.network.Request], typing.Any]</code></dt>
<dd>handler function to route the request.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def route(
    self,
    url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]],
    handler: typing.Callable[[&#34;Route&#34;, &#34;Request&#34;], typing.Any],
) -&gt; NoneType:
    &#34;&#34;&#34;Page.route

    Routing provides the capability to modify network requests that are made by a page.
    Once routing is enabled, every request matching the url pattern will stall unless it&#39;s continued, fulfilled or aborted.

    **NOTE** The handler will only be called for the first url if the response is a redirect.

    An example of a naïve handler that aborts all image requests:
    or the same snippet using a regex pattern instead:
    Page routes take precedence over browser context routes (set up with browserContext.route(url, handler)) when request matches both handlers.

    **NOTE** Enabling routing disables http cache.

    Parameters
    ----------
    url : Union[str, Pattern, typing.Callable[[str], bool]]
        A glob pattern, regex pattern or predicate receiving URL to match while routing.
    handler : typing.Callable[[playwright.network.Route, playwright.network.Request], typing.Any]
        handler function to route the request.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.route(
                url=self._wrap_handler(url), handler=self._wrap_handler(handler)
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.screenshot"><code class="name flex">
<span>def <span class="ident">screenshot</span></span>(<span>self, timeout: int = None, type: Literal['jpeg', 'png'] = None, path: Union[str, pathlib.Path] = None, quality: int = None, omitBackground: bool = None, fullPage: bool = None, clip: playwright.helper.FloatRect = None) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Page.screenshot</p>
<p><strong>NOTE</strong> Screenshots take at least 1/6 second on Chromium OS X and Chromium Windows. See <a href="https://crbug.com/741689">https://crbug.com/741689</a> for discussion.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>Optional[Literal['jpeg', 'png']]</code></dt>
<dd>Specify screenshot type, defaults to <code>png</code>.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[str, pathlib.Path, NoneType]</code></dt>
<dd>The file path to save the image to. The screenshot type will be inferred from file extension. If <code>path</code> is a relative path, then it is resolved relative to current working directory. If no path is provided, the image won't be saved to the disk.</dd>
<dt><strong><code>quality</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>The quality of the image, between 0-100. Not applicable to <code>png</code> images.</dd>
<dt><strong><code>omitBackground</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Hides default white background and allows capturing screenshots with transparency. Not applicable to <code>jpeg</code> images. Defaults to <code>false</code>.</dd>
<dt><strong><code>fullPage</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>When true, takes a screenshot of the full scrollable page, instead of the currently visible viewport. Defaults to <code>false</code>.</dd>
<dt><strong><code>clip</code></strong> :&ensp;<code>Optional[{"x": float, "y": float, "width": float, "height": float}]</code></dt>
<dd>An object which specifies clipping of the resulting image. Should have the following fields:</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>Promise which resolves to buffer with the captured screenshot.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def screenshot(
    self,
    timeout: int = None,
    type: Literal[&#34;jpeg&#34;, &#34;png&#34;] = None,
    path: typing.Union[str, pathlib.Path] = None,
    quality: int = None,
    omitBackground: bool = None,
    fullPage: bool = None,
    clip: FloatRect = None,
) -&gt; bytes:
    &#34;&#34;&#34;Page.screenshot

    **NOTE** Screenshots take at least 1/6 second on Chromium OS X and Chromium Windows. See https://crbug.com/741689 for discussion.

    Parameters
    ----------
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    type : Optional[Literal[&#39;jpeg&#39;, &#39;png&#39;]]
        Specify screenshot type, defaults to `png`.
    path : Union[str, pathlib.Path, NoneType]
        The file path to save the image to. The screenshot type will be inferred from file extension. If `path` is a relative path, then it is resolved relative to current working directory. If no path is provided, the image won&#39;t be saved to the disk.
    quality : Optional[int]
        The quality of the image, between 0-100. Not applicable to `png` images.
    omitBackground : Optional[bool]
        Hides default white background and allows capturing screenshots with transparency. Not applicable to `jpeg` images. Defaults to `false`.
    fullPage : Optional[bool]
        When true, takes a screenshot of the full scrollable page, instead of the currently visible viewport. Defaults to `false`.
    clip : Optional[{&#34;x&#34;: float, &#34;y&#34;: float, &#34;width&#34;: float, &#34;height&#34;: float}]
        An object which specifies clipping of the resulting image. Should have the following fields:

    Returns
    -------
    bytes
        Promise which resolves to buffer with the captured screenshot.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.screenshot(
                timeout=timeout,
                type=type,
                path=path,
                quality=quality,
                omitBackground=omitBackground,
                fullPage=fullPage,
                clip=clip,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.selectOption"><code class="name flex">
<span>def <span class="ident">selectOption</span></span>(<span>self, selector: str, values: Union[str, ForwardRef('<a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a>'), playwright.helper.SelectOption, List[str], List[ForwardRef('<a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a>')], List[playwright.helper.SelectOption]] = None, timeout: int = None, noWaitAfter: bool = None) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.selectOption</p>
<p>Triggers a <code>change</code> and <code>input</code> event once all the provided options have been selected.
If there's no <code>&lt;select&gt;</code> element matching <code>selector</code>, the method throws an error.</p>
<p>Shortcut for page.mainFrame().selectOption()</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query page for. See working with selectors for more details.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>Union[str, ElementHandle, {"value": Optional[str], "label": Optional[str], "index": Optional[str]}, List[str], List[ElementHandle], List[{"value": Optional[str], "label": Optional[str], "index": Optional[str]}], NoneType]</code></dt>
<dd>Options to select. If the <code>&lt;select&gt;</code> has the <code>multiple</code> attribute, all matching options are selected, otherwise only the first option matching one of the passed options is selected. String values are equivalent to <code>{value:'string'}</code>. Option is considered matching if all specified properties match.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[str]</code></dt>
<dd>An array of option values that have been successfully selected.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selectOption(
    self,
    selector: str,
    values: typing.Union[
        str,
        &#34;ElementHandle&#34;,
        SelectOption,
        typing.List[str],
        typing.List[&#34;ElementHandle&#34;],
        typing.List[SelectOption],
    ] = None,
    timeout: int = None,
    noWaitAfter: bool = None,
) -&gt; typing.List[str]:
    &#34;&#34;&#34;Page.selectOption

    Triggers a `change` and `input` event once all the provided options have been selected.
    If there&#39;s no `&lt;select&gt;` element matching `selector`, the method throws an error.

    Shortcut for page.mainFrame().selectOption()

    Parameters
    ----------
    selector : str
        A selector to query page for. See working with selectors for more details.
    values : Union[str, ElementHandle, {&#34;value&#34;: Optional[str], &#34;label&#34;: Optional[str], &#34;index&#34;: Optional[str]}, List[str], List[ElementHandle], List[{&#34;value&#34;: Optional[str], &#34;label&#34;: Optional[str], &#34;index&#34;: Optional[str]}], NoneType]
        Options to select. If the `&lt;select&gt;` has the `multiple` attribute, all matching options are selected, otherwise only the first option matching one of the passed options is selected. String values are equivalent to `{value:&#39;string&#39;}`. Option is considered matching if all specified properties match.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.

    Returns
    -------
    List[str]
        An array of option values that have been successfully selected.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.selectOption(
                selector=selector,
                values=mapping.to_impl(values),
                timeout=timeout,
                noWaitAfter=noWaitAfter,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.setContent"><code class="name flex">
<span>def <span class="ident">setContent</span></span>(<span>self, html: str, timeout: int = None, waitUntil: Literal['domcontentloaded', 'load', 'networkidle'] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.setContent</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>html</code></strong> :&ensp;<code>str</code></dt>
<dd>HTML markup to assign to the page.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds for resources to load, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>waitUntil</code></strong> :&ensp;<code>Optional[Literal['domcontentloaded', 'load', 'networkidle']]</code></dt>
<dd>When to consider setting markup succeeded, defaults to <code>load</code>. Given an array of event strings, setting content is considered to be successful after all events have been fired. Events can be either:
- <code>'load'</code> - consider setting content to be finished when the <code>load</code> event is fired.
- <code>'domcontentloaded'</code> - consider setting content to be finished when the <code>DOMContentLoaded</code> event is fired.
- <code>'networkidle'</code> - consider setting content to be finished when there are no network connections for at least <code>500</code> ms.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setContent(
    self,
    html: str,
    timeout: int = None,
    waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.setContent

    Parameters
    ----------
    html : str
        HTML markup to assign to the page.
    timeout : Optional[int]
        Maximum time in milliseconds for resources to load, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    waitUntil : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
        When to consider setting markup succeeded, defaults to `load`. Given an array of event strings, setting content is considered to be successful after all events have been fired. Events can be either:
         - `&#39;load&#39;` - consider setting content to be finished when the `load` event is fired.
         - `&#39;domcontentloaded&#39;` - consider setting content to be finished when the `DOMContentLoaded` event is fired.
         - `&#39;networkidle&#39;` - consider setting content to be finished when there are no network connections for at least `500` ms.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.setContent(
                html=html, timeout=timeout, waitUntil=waitUntil
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.setDefaultNavigationTimeout"><code class="name flex">
<span>def <span class="ident">setDefaultNavigationTimeout</span></span>(<span>self, timeout: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.setDefaultNavigationTimeout</p>
<p>This setting will change the default maximum navigation time for the following methods and related shortcuts:</p>
<p>page.goBack([options])
page.goForward([options])
page.goto(url[, options])
page.reload([options])
page.setContent(html[, options])
page.waitForNavigation([options])</p>
<p><strong>NOTE</strong> <code>page.setDefaultNavigationTimeout</code> takes priority over <code>page.setDefaultTimeout</code>, <code>browserContext.setDefaultTimeout</code> and <code>browserContext.setDefaultNavigationTimeout</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum navigation time in milliseconds</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setDefaultNavigationTimeout(self, timeout: int) -&gt; NoneType:
    &#34;&#34;&#34;Page.setDefaultNavigationTimeout

    This setting will change the default maximum navigation time for the following methods and related shortcuts:

    page.goBack([options])
    page.goForward([options])
    page.goto(url[, options])
    page.reload([options])
    page.setContent(html[, options])
    page.waitForNavigation([options])

    **NOTE** `page.setDefaultNavigationTimeout` takes priority over `page.setDefaultTimeout`, `browserContext.setDefaultTimeout` and `browserContext.setDefaultNavigationTimeout`.

    Parameters
    ----------
    timeout : int
        Maximum navigation time in milliseconds
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._impl_obj.setDefaultNavigationTimeout(timeout=timeout)
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.setDefaultTimeout"><code class="name flex">
<span>def <span class="ident">setDefaultTimeout</span></span>(<span>self, timeout: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.setDefaultTimeout</p>
<p>This setting will change the default maximum time for all the methods accepting <code>timeout</code> option.</p>
<p><strong>NOTE</strong> <code>page.setDefaultNavigationTimeout</code> takes priority over <code>page.setDefaultTimeout</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum time in milliseconds</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setDefaultTimeout(self, timeout: int) -&gt; NoneType:
    &#34;&#34;&#34;Page.setDefaultTimeout

    This setting will change the default maximum time for all the methods accepting `timeout` option.

    **NOTE** `page.setDefaultNavigationTimeout` takes priority over `page.setDefaultTimeout`.

    Parameters
    ----------
    timeout : int
        Maximum time in milliseconds
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._impl_obj.setDefaultTimeout(timeout=timeout)
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.setExtraHTTPHeaders"><code class="name flex">
<span>def <span class="ident">setExtraHTTPHeaders</span></span>(<span>self, headers: Dict[str, str]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.setExtraHTTPHeaders</p>
<p>The extra HTTP headers will be sent with every request the page initiates.</p>
<p><strong>NOTE</strong> page.setExtraHTTPHeaders does not guarantee the order of headers in the outgoing requests.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>headers</code></strong> :&ensp;<code>Dict[str, str]</code></dt>
<dd>An object containing additional HTTP headers to be sent with every request. All header values must be strings.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setExtraHTTPHeaders(self, headers: typing.Dict[str, str]) -&gt; NoneType:
    &#34;&#34;&#34;Page.setExtraHTTPHeaders

    The extra HTTP headers will be sent with every request the page initiates.

    **NOTE** page.setExtraHTTPHeaders does not guarantee the order of headers in the outgoing requests.

    Parameters
    ----------
    headers : Dict[str, str]
        An object containing additional HTTP headers to be sent with every request. All header values must be strings.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.setExtraHTTPHeaders(headers=mapping.to_impl(headers))
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.setInputFiles"><code class="name flex">
<span>def <span class="ident">setInputFiles</span></span>(<span>self, selector: str, files: Union[str, playwright.helper.FilePayload, List[str], List[playwright.helper.FilePayload]], timeout: int = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.setInputFiles</p>
<p>This method expects <code>selector</code> to point to an input element.
Sets the value of the file input to these file paths or files. If some of the <code>filePaths</code> are relative paths, then they are resolved relative to the current working directory. For empty array, clears the selected files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element to click. If there are multiple elements satisfying the selector, the first will be clicked. See working with selectors for more details.</dd>
<dt><strong><code>files</code></strong> :&ensp;<code>Union[str, {"name": str, "mimeType": str, "buffer": bytes}, List[str], List[{"name": str, "mimeType": str, "buffer": bytes}]]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setInputFiles(
    self,
    selector: str,
    files: typing.Union[
        str, FilePayload, typing.List[str], typing.List[FilePayload]
    ],
    timeout: int = None,
    noWaitAfter: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.setInputFiles

    This method expects `selector` to point to an input element.
    Sets the value of the file input to these file paths or files. If some of the `filePaths` are relative paths, then they are resolved relative to the current working directory. For empty array, clears the selected files.

    Parameters
    ----------
    selector : str
        A selector to search for element to click. If there are multiple elements satisfying the selector, the first will be clicked. See working with selectors for more details.
    files : Union[str, {&#34;name&#34;: str, &#34;mimeType&#34;: str, &#34;buffer&#34;: bytes}, List[str], List[{&#34;name&#34;: str, &#34;mimeType&#34;: str, &#34;buffer&#34;: bytes}]]
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.setInputFiles(
                selector=selector,
                files=files,
                timeout=timeout,
                noWaitAfter=noWaitAfter,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.setViewportSize"><code class="name flex">
<span>def <span class="ident">setViewportSize</span></span>(<span>self, width: int, height: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.setViewportSize</p>
<p>In the case of multiple pages in a single browser, each page can have its own viewport size. However, browser.newContext([options]) allows to set viewport size (and more) for all pages in the context at once.
<code>page.setViewportSize</code> will resize the page. A lot of websites don't expect phones to change size, so you should set the viewport size before navigating to the page.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code></dt>
<dd>page width in pixels. <strong>required</strong></dd>
<dt><strong><code>height</code></strong> :&ensp;<code>int</code></dt>
<dd>page height in pixels. <strong>required</strong></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setViewportSize(self, width: int, height: int) -&gt; NoneType:
    &#34;&#34;&#34;Page.setViewportSize

    In the case of multiple pages in a single browser, each page can have its own viewport size. However, browser.newContext([options]) allows to set viewport size (and more) for all pages in the context at once.
    `page.setViewportSize` will resize the page. A lot of websites don&#39;t expect phones to change size, so you should set the viewport size before navigating to the page.

    Parameters
    ----------
    width : int
        page width in pixels. **required**
    height : int
        page height in pixels. **required**
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.setViewportSize(width=width, height=height))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.tap"><code class="name flex">
<span>def <span class="ident">tap</span></span>(<span>self, selector: str, modifiers: List[Literal['Alt', 'Control', 'Meta', 'Shift']] = None, position: playwright.helper.MousePosition = None, timeout: int = None, force: bool = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.tap</p>
<p>This method taps an element matching <code>selector</code> by performing the following steps:</p>
<p>Find an element match matching <code>selector</code>. If there is none, wait until a matching element is attached to the DOM.
Wait for actionability checks on the matched element, unless <code>force</code> option is set. If the element is detached during the checks, the whole action is retried.
Scroll the element into view if needed.
Use page.touchscreen to tap the center of the element, or the specified <code>position</code>.
Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a TimeoutError. Passing zero timeout disables this.</p>
<p><strong>NOTE</strong> <code>page.tap()</code> requires that the <code>hasTouch</code> option of the browser context be set to true.</p>
<p>Shortcut for page.mainFrame().tap().</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element to tap. If there are multiple elements satisfying the selector, the first will be tapped. See working with selectors for more details.</dd>
<dt><strong><code>modifiers</code></strong> :&ensp;<code>Optional[List[Literal['Alt', 'Control', 'Meta', 'Shift']]]</code></dt>
<dd>Modifier keys to press. Ensures that only these modifiers are pressed during the tap, and then restores current modifiers back. If not specified, currently pressed modifiers are used.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>Optional[{"x": float, "y": float}]</code></dt>
<dd>A point to tap relative to the top-left corner of element padding box. If not specified, taps some visible point of the element.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to bypass the actionability checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tap(
    self,
    selector: str,
    modifiers: typing.Union[
        typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
    ] = None,
    position: MousePosition = None,
    timeout: int = None,
    force: bool = None,
    noWaitAfter: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.tap

    This method taps an element matching `selector` by performing the following steps:

    Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
    Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
    Scroll the element into view if needed.
    Use page.touchscreen to tap the center of the element, or the specified `position`.
    Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.

    **NOTE** `page.tap()` requires that the `hasTouch` option of the browser context be set to true.

    Shortcut for page.mainFrame().tap().

    Parameters
    ----------
    selector : str
        A selector to search for element to tap. If there are multiple elements satisfying the selector, the first will be tapped. See working with selectors for more details.
    modifiers : Optional[List[Literal[&#39;Alt&#39;, &#39;Control&#39;, &#39;Meta&#39;, &#39;Shift&#39;]]]
        Modifier keys to press. Ensures that only these modifiers are pressed during the tap, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
    position : Optional[{&#34;x&#34;: float, &#34;y&#34;: float}]
        A point to tap relative to the top-left corner of element padding box. If not specified, taps some visible point of the element.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    force : Optional[bool]
        Whether to bypass the actionability checks. Defaults to `false`.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.tap(
                selector=selector,
                modifiers=modifiers,
                position=position,
                timeout=timeout,
                force=force,
                noWaitAfter=noWaitAfter,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.textContent"><code class="name flex">
<span>def <span class="ident">textContent</span></span>(<span>self, selector: str, timeout: int = None) ‑> Union[str, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.textContent</p>
<p>Resolves to the <code>element.textContent</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[str]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def textContent(
    self, selector: str, timeout: int = None
) -&gt; typing.Union[str, NoneType]:
    &#34;&#34;&#34;Page.textContent

    Resolves to the `element.textContent`.

    Parameters
    ----------
    selector : str
        A selector to search for an element. If there are multiple elements satisfying the selector, the first will be picked. See working with selectors for more details.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

    Returns
    -------
    Optional[str]
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.textContent(selector=selector, timeout=timeout))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.title"><code class="name flex">
<span>def <span class="ident">title</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Page.title</p>
<p>Shortcut for page.mainFrame().title().</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The page's title.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def title(self) -&gt; str:
    &#34;&#34;&#34;Page.title

    Shortcut for page.mainFrame().title().

    Returns
    -------
    str
        The page&#39;s title.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.title()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.type"><code class="name flex">
<span>def <span class="ident">type</span></span>(<span>self, selector: str, text: str, delay: int = None, timeout: int = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.type</p>
<p>Sends a <code>keydown</code>, <code>keypress</code>/<code>input</code>, and <code>keyup</code> event for each character in the text. <code>page.type</code> can be used to send fine-grained keyboard events. To fill values in form fields, use <code>page.fill</code>.
To press a special key, like <code>Control</code> or <code>ArrowDown</code>, use <code>keyboard.press</code>.
Shortcut for page.mainFrame().type(selector, text[, options]).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector of an element to type into. If there are multiple elements satisfying the selector, the first will be used. See working with selectors for more details.</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>A text to type into a focused element.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Time to wait between key presses in milliseconds. Defaults to 0.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def type(
    self,
    selector: str,
    text: str,
    delay: int = None,
    timeout: int = None,
    noWaitAfter: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.type

    Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text. `page.type` can be used to send fine-grained keyboard events. To fill values in form fields, use `page.fill`.
    To press a special key, like `Control` or `ArrowDown`, use `keyboard.press`.
    Shortcut for page.mainFrame().type(selector, text[, options]).

    Parameters
    ----------
    selector : str
        A selector of an element to type into. If there are multiple elements satisfying the selector, the first will be used. See working with selectors for more details.
    text : str
        A text to type into a focused element.
    delay : Optional[int]
        Time to wait between key presses in milliseconds. Defaults to 0.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.type(
                selector=selector,
                text=text,
                delay=delay,
                timeout=timeout,
                noWaitAfter=noWaitAfter,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.uncheck"><code class="name flex">
<span>def <span class="ident">uncheck</span></span>(<span>self, selector: str, timeout: int = None, force: bool = None, noWaitAfter: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.uncheck</p>
<p>This method unchecks an element matching <code>selector</code> by performing the following steps:</p>
<p>Find an element match matching <code>selector</code>. If there is none, wait until a matching element is attached to the DOM.
Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already unchecked, this method returns immediately.
Wait for actionability checks on the matched element, unless <code>force</code> option is set. If the element is detached during the checks, the whole action is retried.
Scroll the element into view if needed.
Use page.mouse to click in the center of the element.
Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.
Ensure that the element is now unchecked. If not, this method rejects.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a TimeoutError. Passing zero timeout disables this.
Shortcut for page.mainFrame().uncheck(selector[, options]).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for uncheckbox to check. If there are multiple elements satisfying the selector, the first will be checked. See working with selectors for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to bypass the actionability checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>noWaitAfter</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uncheck(
    self,
    selector: str,
    timeout: int = None,
    force: bool = None,
    noWaitAfter: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.uncheck

    This method unchecks an element matching `selector` by performing the following steps:

    Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
    Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already unchecked, this method returns immediately.
    Wait for actionability checks on the matched element, unless `force` option is set. If the element is detached during the checks, the whole action is retried.
    Scroll the element into view if needed.
    Use page.mouse to click in the center of the element.
    Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
    Ensure that the element is now unchecked. If not, this method rejects.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a TimeoutError. Passing zero timeout disables this.
    Shortcut for page.mainFrame().uncheck(selector[, options]).

    Parameters
    ----------
    selector : str
        A selector to search for uncheckbox to check. If there are multiple elements satisfying the selector, the first will be checked. See working with selectors for more details.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    force : Optional[bool]
        Whether to bypass the actionability checks. Defaults to `false`.
    noWaitAfter : Optional[bool]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.uncheck(
                selector=selector,
                timeout=timeout,
                force=force,
                noWaitAfter=noWaitAfter,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.unroute"><code class="name flex">
<span>def <span class="ident">unroute</span></span>(<span>self, url: Union[str, Pattern, Callable[[str], bool]], handler: Callable[[ForwardRef('<a title="playwright.sync_api.Route" href="#playwright.sync_api.Route">Route</a>'), ForwardRef('<a title="playwright.sync_api.Request" href="#playwright.sync_api.Request">Request</a>')], Any] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.unroute</p>
<p>Removes a route created with page.route(url, handler). When <code>handler</code> is not specified, removes all routes for the <code>url</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>Union[str, Pattern, typing.Callable[[str], bool]]</code></dt>
<dd>A glob pattern, regex pattern or predicate receiving URL to match while routing.</dd>
<dt><strong><code>handler</code></strong> :&ensp;<code>Optional[typing.Callable[[playwright.network.Route, playwright.network.Request], typing.Any]]</code></dt>
<dd>Handler function to route the request.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unroute(
    self,
    url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]],
    handler: typing.Union[typing.Callable[[&#34;Route&#34;, &#34;Request&#34;], typing.Any]] = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.unroute

    Removes a route created with page.route(url, handler). When `handler` is not specified, removes all routes for the `url`.

    Parameters
    ----------
    url : Union[str, Pattern, typing.Callable[[str], bool]]
        A glob pattern, regex pattern or predicate receiving URL to match while routing.
    handler : Optional[typing.Callable[[playwright.network.Route, playwright.network.Request], typing.Any]]
        Handler function to route the request.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.unroute(
                url=self._wrap_handler(url), handler=self._wrap_handler(handler)
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.viewportSize"><code class="name flex">
<span>def <span class="ident">viewportSize</span></span>(<span>self) ‑> Union[playwright.helper.Viewport, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.viewportSize</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[{"width": int, "height": int}]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def viewportSize(self) -&gt; typing.Union[Viewport, NoneType]:
    &#34;&#34;&#34;Page.viewportSize

    Returns
    -------
    Optional[{&#34;width&#34;: int, &#34;height&#34;: int}]
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.viewportSize())</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.waitForEvent"><code class="name flex">
<span>def <span class="ident">waitForEvent</span></span>(<span>self, event: str, predicate: Callable[[Any], bool] = None, timeout: int = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Page.waitForEvent</p>
<p>Waits for event to fire and passes its value into the predicate function. Resolves when the predicate returns truthy value. Will throw an error if the page is closed before the event
is fired.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>str</code></dt>
<dd>Event name, same one would pass into <code>page.on(event)</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>Promise which resolves to the event data value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def waitForEvent(
    self,
    event: str,
    predicate: typing.Union[typing.Callable[[typing.Any], bool]] = None,
    timeout: int = None,
) -&gt; typing.Any:
    &#34;&#34;&#34;Page.waitForEvent

    Waits for event to fire and passes its value into the predicate function. Resolves when the predicate returns truthy value. Will throw an error if the page is closed before the event
    is fired.

    Parameters
    ----------
    event : str
        Event name, same one would pass into `page.on(event)`.

    Returns
    -------
    Any
        Promise which resolves to the event data value.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.waitForEvent(
                event=event,
                predicate=self._wrap_handler(predicate),
                timeout=timeout,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.waitForFunction"><code class="name flex">
<span>def <span class="ident">waitForFunction</span></span>(<span>self, expression: str, arg: Any = None, force_expr: bool = None, timeout: int = None, polling: Union[int, Literal['raf']] = None) ‑> <a title="playwright.sync_api.JSHandle" href="#playwright.sync_api.JSHandle">JSHandle</a></span>
</code></dt>
<dd>
<div class="desc"><p>Page.waitForFunction</p>
<p>The <code>waitForFunction</code> can be used to observe viewport size change:</p>
<p>To pass an argument from Node.js to the predicate of <code>page.waitForFunction</code> function:
Shortcut for page.mainFrame().waitForFunction(pageFunction[, arg, options]).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>Function to be evaluated in browser context</dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Optional[Any]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>maximum time to wait for in milliseconds. Defaults to <code>30000</code> (30 seconds). Pass <code>0</code> to disable timeout. The default value can be changed by using the page.setDefaultTimeout(timeout) method.</dd>
<dt><strong><code>polling</code></strong> :&ensp;<code>Union[int, 'raf', NoneType]</code></dt>
<dd>If <code>polling</code> is <code>'raf'</code>, then <code>pageFunction</code> is constantly executed in <code>requestAnimationFrame</code> callback. If <code>polling</code> is a number, then it is treated as an interval in milliseconds at which the function would be executed. Defaults to <code>raf</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.JSHandle" href="#playwright.sync_api.JSHandle">JSHandle</a></code></dt>
<dd>Promise which resolves when the <code>pageFunction</code> returns a truthy value. It resolves to a JSHandle of the truthy value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def waitForFunction(
    self,
    expression: str,
    arg: typing.Any = None,
    force_expr: bool = None,
    timeout: int = None,
    polling: typing.Union[int, Literal[&#34;raf&#34;]] = None,
) -&gt; &#34;JSHandle&#34;:
    &#34;&#34;&#34;Page.waitForFunction

    The `waitForFunction` can be used to observe viewport size change:

    To pass an argument from Node.js to the predicate of `page.waitForFunction` function:
    Shortcut for page.mainFrame().waitForFunction(pageFunction[, arg, options]).

    Parameters
    ----------
    expression : str
        Function to be evaluated in browser context
    force_expr : bool
        Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
    arg : Optional[Any]
        Optional argument to pass to `pageFunction`
    timeout : Optional[int]
        maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can be changed by using the page.setDefaultTimeout(timeout) method.
    polling : Union[int, &#39;raf&#39;, NoneType]
        If `polling` is `&#39;raf&#39;`, then `pageFunction` is constantly executed in `requestAnimationFrame` callback. If `polling` is a number, then it is treated as an interval in milliseconds at which the function would be executed. Defaults to `raf`.

    Returns
    -------
    JSHandle
        Promise which resolves when the `pageFunction` returns a truthy value. It resolves to a JSHandle of the truthy value.
    &#34;&#34;&#34;
    return mapping.from_impl(
        self._sync(
            self._impl_obj.waitForFunction(
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
                timeout=timeout,
                polling=polling,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.waitForLoadState"><code class="name flex">
<span>def <span class="ident">waitForLoadState</span></span>(<span>self, state: Literal['domcontentloaded', 'load', 'networkidle'] = None, timeout: int = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.waitForLoadState</p>
<p>This resolves when the page reaches a required load state, <code>load</code> by default. The navigation must have been committed when this method is called. If current document has already reached the required state, resolves immediately.
Shortcut for page.mainFrame().waitForLoadState([options]).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<code>Optional[Literal['domcontentloaded', 'load', 'networkidle']]</code></dt>
<dd>Load state to wait for, defaults to <code>load</code>. If the state has been already reached while loading current document, the method resolves immediately.
- <code>'load'</code> - wait for the <code>load</code> event to be fired.
- <code>'domcontentloaded'</code> - wait for the <code>DOMContentLoaded</code> event to be fired.
- <code>'networkidle'</code> - wait until there are no network connections for at least <code>500</code> ms.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum waiting time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def waitForLoadState(
    self,
    state: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    timeout: int = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.waitForLoadState

    This resolves when the page reaches a required load state, `load` by default. The navigation must have been committed when this method is called. If current document has already reached the required state, resolves immediately.
    Shortcut for page.mainFrame().waitForLoadState([options]).

    Parameters
    ----------
    state : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
        Load state to wait for, defaults to `load`. If the state has been already reached while loading current document, the method resolves immediately.
         - `&#39;load&#39;` - wait for the `load` event to be fired.
         - `&#39;domcontentloaded&#39;` - wait for the `DOMContentLoaded` event to be fired.
         - `&#39;networkidle&#39;` - wait until there are no network connections for at least `500` ms.
    timeout : Optional[int]
        Maximum waiting time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.waitForLoadState(state=state, timeout=timeout))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.waitForNavigation"><code class="name flex">
<span>def <span class="ident">waitForNavigation</span></span>(<span>self, url: Union[str, Pattern, Callable[[str], bool]] = None, waitUntil: Literal['domcontentloaded', 'load', 'networkidle'] = None, timeout: int = None) ‑> Union[<a title="playwright.async_api.Response" href="async_api.html#playwright.async_api.Response">Response</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.waitForNavigation</p>
<p>This resolves when the page navigates to a new URL or reloads. It is useful for when you run code
which will indirectly cause the page to navigate. e.g. The click target has an <code>onclick</code> handler that triggers navigation from a <code>setTimeout</code>. Consider this example:
<strong>NOTE</strong> Usage of the History API to change the URL is considered a navigation.
Shortcut for page.mainFrame().waitForNavigation(options).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>Union[str, Pattern, typing.Callable[[str], bool], NoneType]</code></dt>
<dd>A glob pattern, regex pattern or predicate receiving URL to match while waiting for the navigation.</dd>
<dt><strong><code>waitUntil</code></strong> :&ensp;<code>Optional[Literal['domcontentloaded', 'load', 'networkidle']]</code></dt>
<dd>When to consider navigation succeeded, defaults to <code>load</code>. Events can be either:
- <code>'domcontentloaded'</code> - consider navigation to be finished when the <code>DOMContentLoaded</code> event is fired.
- <code>'load'</code> - consider navigation to be finished when the <code>load</code> event is fired.
- <code>'networkidle'</code> - consider navigation to be finished when there are no network connections for at least <code>500</code> ms.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum navigation time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[<a title="playwright.sync_api.Response" href="#playwright.sync_api.Response">Response</a>]</code></dt>
<dd>Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect. In case of navigation to a different anchor or navigation due to History API usage, the navigation will resolve with <code>null</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def waitForNavigation(
    self,
    url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
    waitUntil: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    timeout: int = None,
) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
    &#34;&#34;&#34;Page.waitForNavigation

    This resolves when the page navigates to a new URL or reloads. It is useful for when you run code
    which will indirectly cause the page to navigate. e.g. The click target has an `onclick` handler that triggers navigation from a `setTimeout`. Consider this example:
    **NOTE** Usage of the History API to change the URL is considered a navigation.
    Shortcut for page.mainFrame().waitForNavigation(options).

    Parameters
    ----------
    url : Union[str, Pattern, typing.Callable[[str], bool], NoneType]
        A glob pattern, regex pattern or predicate receiving URL to match while waiting for the navigation.
    waitUntil : Optional[Literal[&#39;domcontentloaded&#39;, &#39;load&#39;, &#39;networkidle&#39;]]
        When to consider navigation succeeded, defaults to `load`. Events can be either:
         - `&#39;domcontentloaded&#39;` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
         - `&#39;load&#39;` - consider navigation to be finished when the `load` event is fired.
         - `&#39;networkidle&#39;` - consider navigation to be finished when there are no network connections for at least `500` ms.
    timeout : Optional[int]
        Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

    Returns
    -------
    Optional[Response]
        Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect. In case of navigation to a different anchor or navigation due to History API usage, the navigation will resolve with `null`.
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(
        self._sync(
            self._impl_obj.waitForNavigation(
                url=self._wrap_handler(url), waitUntil=waitUntil, timeout=timeout
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.waitForRequest"><code class="name flex">
<span>def <span class="ident">waitForRequest</span></span>(<span>self, url: Union[str, Pattern, Callable[[str], bool]] = None, predicate: Callable[[ForwardRef('<a title="playwright.sync_api.Request" href="#playwright.sync_api.Request">Request</a>')], bool] = None, timeout: int = None) ‑> <a title="playwright.sync_api.Request" href="#playwright.sync_api.Request">Request</a></span>
</code></dt>
<dd>
<div class="desc"><p>Page.waitForRequest</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>Union[str, Pattern, typing.Callable[[str], bool], NoneType]</code></dt>
<dd>Request URL string, regex or predicate receiving Request object.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum wait time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable the timeout. The default value can be changed by using the page.setDefaultTimeout(timeout) method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.Request" href="#playwright.sync_api.Request">Request</a></code></dt>
<dd>Promise which resolves to the matched request.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def waitForRequest(
    self,
    url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
    predicate: typing.Union[typing.Callable[[&#34;Request&#34;], bool]] = None,
    timeout: int = None,
) -&gt; &#34;Request&#34;:
    &#34;&#34;&#34;Page.waitForRequest


    Parameters
    ----------
    url : Union[str, Pattern, typing.Callable[[str], bool], NoneType]
        Request URL string, regex or predicate receiving Request object.
    timeout : Optional[int]
        Maximum wait time in milliseconds, defaults to 30 seconds, pass `0` to disable the timeout. The default value can be changed by using the page.setDefaultTimeout(timeout) method.

    Returns
    -------
    Request
        Promise which resolves to the matched request.
    &#34;&#34;&#34;
    return mapping.from_impl(
        self._sync(
            self._impl_obj.waitForRequest(
                url=self._wrap_handler(url),
                predicate=self._wrap_handler(predicate),
                timeout=timeout,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.waitForResponse"><code class="name flex">
<span>def <span class="ident">waitForResponse</span></span>(<span>self, url: Union[str, Pattern, Callable[[str], bool]] = None, predicate: Callable[[ForwardRef('<a title="playwright.sync_api.Response" href="#playwright.sync_api.Response">Response</a>')], bool] = None, timeout: int = None) ‑> <a title="playwright.sync_api.Response" href="#playwright.sync_api.Response">Response</a></span>
</code></dt>
<dd>
<div class="desc"><p>Page.waitForResponse</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>Union[str, Pattern, typing.Callable[[str], bool], NoneType]</code></dt>
<dd>Request URL string, regex or predicate receiving Response object.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum wait time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable the timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.Response" href="#playwright.sync_api.Response">Response</a></code></dt>
<dd>Promise which resolves to the matched response.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def waitForResponse(
    self,
    url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
    predicate: typing.Union[typing.Callable[[&#34;Response&#34;], bool]] = None,
    timeout: int = None,
) -&gt; &#34;Response&#34;:
    &#34;&#34;&#34;Page.waitForResponse


    Parameters
    ----------
    url : Union[str, Pattern, typing.Callable[[str], bool], NoneType]
        Request URL string, regex or predicate receiving Response object.
    timeout : Optional[int]
        Maximum wait time in milliseconds, defaults to 30 seconds, pass `0` to disable the timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.

    Returns
    -------
    Response
        Promise which resolves to the matched response.
    &#34;&#34;&#34;
    return mapping.from_impl(
        self._sync(
            self._impl_obj.waitForResponse(
                url=self._wrap_handler(url),
                predicate=self._wrap_handler(predicate),
                timeout=timeout,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.waitForSelector"><code class="name flex">
<span>def <span class="ident">waitForSelector</span></span>(<span>self, selector: str, timeout: int = None, state: Literal['attached', 'detached', 'hidden', 'visible'] = None) ‑> Union[<a title="playwright.async_api.ElementHandle" href="async_api.html#playwright.async_api.ElementHandle">ElementHandle</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.waitForSelector</p>
<p>Wait for the <code>selector</code> to satisfy <code>state</code> option (either appear/disappear from dom, or become visible/hidden). If at the moment of calling the method <code>selector</code> already satisfies the condition, the method will return immediately. If the selector doesn't satisfy the condition for the <code>timeout</code> milliseconds, the function will throw.
This method works across navigations:</p>
<p>Shortcut for page.mainFrame().waitForSelector(selector[, options]).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector of an element to wait for. See working with selectors for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>Optional[Literal['attached', 'detached', 'hidden', 'visible']]</code></dt>
<dd>Defaults to <code>'visible'</code>. Can be either:
- <code>'attached'</code> - wait for element to be present in DOM.
- <code>'detached'</code> - wait for element to not be present in DOM.
- <code>'visible'</code> - wait for element to have non-empty bounding box and no <code>visibility:hidden</code>. Note that element without any content or with <code>display:none</code> has an empty bounding box and is not considered visible.
- <code>'hidden'</code> - wait for element to be either detached from DOM, or have an empty bounding box or <code>visibility:hidden</code>. This is opposite to the <code>'visible'</code> option.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[<a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a>]</code></dt>
<dd>Promise which resolves when element specified by selector satisfies <code>state</code> option. Resolves to <code>null</code> if waiting for <code>hidden</code> or <code>detached</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def waitForSelector(
    self,
    selector: str,
    timeout: int = None,
    state: Literal[&#34;attached&#34;, &#34;detached&#34;, &#34;hidden&#34;, &#34;visible&#34;] = None,
) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
    &#34;&#34;&#34;Page.waitForSelector

    Wait for the `selector` to satisfy `state` option (either appear/disappear from dom, or become visible/hidden). If at the moment of calling the method `selector` already satisfies the condition, the method will return immediately. If the selector doesn&#39;t satisfy the condition for the `timeout` milliseconds, the function will throw.
    This method works across navigations:

    Shortcut for page.mainFrame().waitForSelector(selector[, options]).

    Parameters
    ----------
    selector : str
        A selector of an element to wait for. See working with selectors for more details.
    timeout : Optional[int]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
    state : Optional[Literal[&#39;attached&#39;, &#39;detached&#39;, &#39;hidden&#39;, &#39;visible&#39;]]
        Defaults to `&#39;visible&#39;`. Can be either:
         - `&#39;attached&#39;` - wait for element to be present in DOM.
         - `&#39;detached&#39;` - wait for element to not be present in DOM.
         - `&#39;visible&#39;` - wait for element to have non-empty bounding box and no `visibility:hidden`. Note that element without any content or with `display:none` has an empty bounding box and is not considered visible.
         - `&#39;hidden&#39;` - wait for element to be either detached from DOM, or have an empty bounding box or `visibility:hidden`. This is opposite to the `&#39;visible&#39;` option.

    Returns
    -------
    Optional[ElementHandle]
        Promise which resolves when element specified by selector satisfies `state` option. Resolves to `null` if waiting for `hidden` or `detached`.
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(
        self._sync(
            self._impl_obj.waitForSelector(
                selector=selector, timeout=timeout, state=state
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Page.waitForTimeout"><code class="name flex">
<span>def <span class="ident">waitForTimeout</span></span>(<span>self, timeout: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.waitForTimeout</p>
<p>Returns a promise that resolves after the timeout.
Note that <code>page.waitForTimeout()</code> should only be used for debugging. Tests using the timer in production are going to be flaky. Use signals such as network events, selectors becoming visible and others instead.
Shortcut for page.mainFrame().waitForTimeout(timeout).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>A timeout to wait for</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def waitForTimeout(self, timeout: int) -&gt; NoneType:
    &#34;&#34;&#34;Page.waitForTimeout

    Returns a promise that resolves after the timeout.
    Note that `page.waitForTimeout()` should only be used for debugging. Tests using the timer in production are going to be flaky. Use signals such as network events, selectors becoming visible and others instead.
    Shortcut for page.mainFrame().waitForTimeout(timeout).

    Parameters
    ----------
    timeout : int
        A timeout to wait for
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.waitForTimeout(timeout=timeout))
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.sync_api.Playwright"><code class="flex name class">
<span>class <span class="ident">Playwright</span></span>
<span>(</span><span>obj: playwright.playwright.Playwright)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Playwright(SyncBase):
    def __init__(self, obj: PlaywrightImpl):
        super().__init__(obj)

    @property
    def chromium(self) -&gt; &#34;BrowserType&#34;:
        return mapping.from_impl(self._impl_obj.chromium)

    @property
    def firefox(self) -&gt; &#34;BrowserType&#34;:
        return mapping.from_impl(self._impl_obj.firefox)

    @property
    def webkit(self) -&gt; &#34;BrowserType&#34;:
        return mapping.from_impl(self._impl_obj.webkit)

    @property
    def selectors(self) -&gt; &#34;Selectors&#34;:
        return mapping.from_impl(self._impl_obj.selectors)

    @property
    def devices(self) -&gt; typing.Dict[str, DeviceDescriptor]:
        return mapping.from_maybe_impl(self._impl_obj.devices)

    def stop(self) -&gt; NoneType:
        return mapping.from_maybe_impl(self._impl_obj.stop())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright.sync_base.SyncBase</li>
<li>playwright.impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.sync_api.Playwright.chromium"><code class="name">var <span class="ident">chromium</span> : <a title="playwright.sync_api.BrowserType" href="#playwright.sync_api.BrowserType">BrowserType</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def chromium(self) -&gt; &#34;BrowserType&#34;:
    return mapping.from_impl(self._impl_obj.chromium)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Playwright.devices"><code class="name">var <span class="ident">devices</span> : Dict[str, playwright.helper.DeviceDescriptor]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def devices(self) -&gt; typing.Dict[str, DeviceDescriptor]:
    return mapping.from_maybe_impl(self._impl_obj.devices)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Playwright.firefox"><code class="name">var <span class="ident">firefox</span> : <a title="playwright.sync_api.BrowserType" href="#playwright.sync_api.BrowserType">BrowserType</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def firefox(self) -&gt; &#34;BrowserType&#34;:
    return mapping.from_impl(self._impl_obj.firefox)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Playwright.selectors"><code class="name">var <span class="ident">selectors</span> : <a title="playwright.sync_api.Selectors" href="#playwright.sync_api.Selectors">Selectors</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def selectors(self) -&gt; &#34;Selectors&#34;:
    return mapping.from_impl(self._impl_obj.selectors)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Playwright.webkit"><code class="name">var <span class="ident">webkit</span> : <a title="playwright.sync_api.BrowserType" href="#playwright.sync_api.BrowserType">BrowserType</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def webkit(self) -&gt; &#34;BrowserType&#34;:
    return mapping.from_impl(self._impl_obj.webkit)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.sync_api.Playwright.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self) -&gt; NoneType:
    return mapping.from_maybe_impl(self._impl_obj.stop())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.sync_api.Request"><code class="flex name class">
<span>class <span class="ident">Request</span></span>
<span>(</span><span>obj: playwright.network.Request)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Request(SyncBase):
    def __init__(self, obj: RequestImpl):
        super().__init__(obj)

    @property
    def url(self) -&gt; str:
        &#34;&#34;&#34;Request.url

        Returns
        -------
        str
            URL of the request.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.url)

    @property
    def resourceType(self) -&gt; str:
        &#34;&#34;&#34;Request.resourceType

        Contains the request&#39;s resource type as it was perceived by the rendering engine.
        ResourceType will be one of the following: `document`, `stylesheet`, `image`, `media`, `font`, `script`, `texttrack`, `xhr`, `fetch`, `eventsource`, `websocket`, `manifest`, `other`.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.resourceType)

    @property
    def method(self) -&gt; str:
        &#34;&#34;&#34;Request.method

        Returns
        -------
        str
            Request&#39;s method (GET, POST, etc.)
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.method)

    @property
    def postData(self) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;Request.postData

        Returns
        -------
        Optional[str]
            Request&#39;s post body, if any.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.postData)

    @property
    def postDataJSON(self) -&gt; typing.Union[typing.Dict, NoneType]:
        &#34;&#34;&#34;Request.postDataJSON

        When the response is `application/x-www-form-urlencoded` then a key/value object of the values will be returned. Otherwise it will be parsed as JSON.

        Returns
        -------
        Optional[Dict]
            Parsed request&#39;s body for `form-urlencoded` and JSON as a fallback if any.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.postDataJSON)

    @property
    def postDataBuffer(self) -&gt; typing.Union[bytes, NoneType]:
        &#34;&#34;&#34;Request.postDataBuffer

        Returns
        -------
        Optional[bytes]
            Request&#39;s post body in a binary form, if any.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.postDataBuffer)

    @property
    def headers(self) -&gt; typing.Dict[str, str]:
        &#34;&#34;&#34;Request.headers

        Returns
        -------
        Dict[str, str]
            An object with HTTP headers associated with the request. All header names are lower-case.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.headers)

    @property
    def frame(self) -&gt; &#34;Frame&#34;:
        &#34;&#34;&#34;Request.frame

        Returns
        -------
        Frame
            A Frame that initiated this request.
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.frame)

    @property
    def redirectedFrom(self) -&gt; typing.Union[&#34;Request&#34;, NoneType]:
        &#34;&#34;&#34;Request.redirectedFrom

        When the server responds with a redirect, Playwright creates a new Request object. The two requests are connected by `redirectedFrom()` and `redirectedTo()` methods. When multiple server redirects has happened, it is possible to construct the whole redirect chain by repeatedly calling `redirectedFrom()`.
        For example, if the website `http://example.com` redirects to `https://example.com`:
        If the website `https://google.com` has no redirects:

        Returns
        -------
        Optional[Request]
            Request that was redirected by the server to this one, if any.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._impl_obj.redirectedFrom)

    @property
    def redirectedTo(self) -&gt; typing.Union[&#34;Request&#34;, NoneType]:
        &#34;&#34;&#34;Request.redirectedTo

        This method is the opposite of request.redirectedFrom():

        Returns
        -------
        Optional[Request]
            New request issued by the browser if the server responded with redirect.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._impl_obj.redirectedTo)

    @property
    def failure(self) -&gt; typing.Union[RequestFailure, NoneType]:
        &#34;&#34;&#34;Request.failure

        The method returns `null` unless this request has failed, as reported by
        `requestfailed` event.
        Example of logging of all the failed requests:

        Returns
        -------
        Optional[{&#34;errorText&#34;: str}]
            Object describing request failure, if any
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.failure)

    @property
    def timing(self) -&gt; ResourceTiming:
        &#34;&#34;&#34;Request.timing

        Returns resource timing information for given request. Most of the timing values become available upon the response, `responseEnd` becomes available when request finishes. Find more information at Resource Timing API.

        Returns
        -------
        {&#34;startTime&#34;: float, &#34;domainLookupStart&#34;: float, &#34;domainLookupEnd&#34;: float, &#34;connectStart&#34;: float, &#34;secureConnectionStart&#34;: float, &#34;connectEnd&#34;: float, &#34;requestStart&#34;: float, &#34;responseStart&#34;: float, &#34;responseEnd&#34;: float}
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.timing)

    def response(self) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
        &#34;&#34;&#34;Request.response

        Returns
        -------
        Optional[Response]
            A matching Response object, or `null` if the response was not received due to error.
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._sync(self._impl_obj.response()))

    def isNavigationRequest(self) -&gt; bool:
        &#34;&#34;&#34;Request.isNavigationRequest

        Whether this request is driving frame&#39;s navigation.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.isNavigationRequest())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright.sync_base.SyncBase</li>
<li>playwright.impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.sync_api.Request.failure"><code class="name">var <span class="ident">failure</span> : Union[playwright.helper.RequestFailure, NoneType]</code></dt>
<dd>
<div class="desc"><p>Request.failure</p>
<p>The method returns <code>null</code> unless this request has failed, as reported by
<code>requestfailed</code> event.
Example of logging of all the failed requests:</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[{"errorText": str}]</code></dt>
<dd>Object describing request failure, if any</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def failure(self) -&gt; typing.Union[RequestFailure, NoneType]:
    &#34;&#34;&#34;Request.failure

    The method returns `null` unless this request has failed, as reported by
    `requestfailed` event.
    Example of logging of all the failed requests:

    Returns
    -------
    Optional[{&#34;errorText&#34;: str}]
        Object describing request failure, if any
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.failure)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Request.frame"><code class="name">var <span class="ident">frame</span> : <a title="playwright.sync_api.Frame" href="#playwright.sync_api.Frame">Frame</a></code></dt>
<dd>
<div class="desc"><p>Request.frame</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.Frame" href="#playwright.sync_api.Frame">Frame</a></code></dt>
<dd>A Frame that initiated this request.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frame(self) -&gt; &#34;Frame&#34;:
    &#34;&#34;&#34;Request.frame

    Returns
    -------
    Frame
        A Frame that initiated this request.
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.frame)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Request.headers"><code class="name">var <span class="ident">headers</span> : Dict[str, str]</code></dt>
<dd>
<div class="desc"><p>Request.headers</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, str]</code></dt>
<dd>An object with HTTP headers associated with the request. All header names are lower-case.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def headers(self) -&gt; typing.Dict[str, str]:
    &#34;&#34;&#34;Request.headers

    Returns
    -------
    Dict[str, str]
        An object with HTTP headers associated with the request. All header names are lower-case.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.headers)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Request.method"><code class="name">var <span class="ident">method</span> : str</code></dt>
<dd>
<div class="desc"><p>Request.method</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Request's method (GET, POST, etc.)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def method(self) -&gt; str:
    &#34;&#34;&#34;Request.method

    Returns
    -------
    str
        Request&#39;s method (GET, POST, etc.)
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.method)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Request.postData"><code class="name">var <span class="ident">postData</span> : Union[str, NoneType]</code></dt>
<dd>
<div class="desc"><p>Request.postData</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[str]</code></dt>
<dd>Request's post body, if any.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def postData(self) -&gt; typing.Union[str, NoneType]:
    &#34;&#34;&#34;Request.postData

    Returns
    -------
    Optional[str]
        Request&#39;s post body, if any.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.postData)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Request.postDataBuffer"><code class="name">var <span class="ident">postDataBuffer</span> : Union[bytes, NoneType]</code></dt>
<dd>
<div class="desc"><p>Request.postDataBuffer</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[bytes]</code></dt>
<dd>Request's post body in a binary form, if any.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def postDataBuffer(self) -&gt; typing.Union[bytes, NoneType]:
    &#34;&#34;&#34;Request.postDataBuffer

    Returns
    -------
    Optional[bytes]
        Request&#39;s post body in a binary form, if any.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.postDataBuffer)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Request.postDataJSON"><code class="name">var <span class="ident">postDataJSON</span> : Union[Dict, NoneType]</code></dt>
<dd>
<div class="desc"><p>Request.postDataJSON</p>
<p>When the response is <code>application/x-www-form-urlencoded</code> then a key/value object of the values will be returned. Otherwise it will be parsed as JSON.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[Dict]</code></dt>
<dd>Parsed request's body for <code>form-urlencoded</code> and JSON as a fallback if any.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def postDataJSON(self) -&gt; typing.Union[typing.Dict, NoneType]:
    &#34;&#34;&#34;Request.postDataJSON

    When the response is `application/x-www-form-urlencoded` then a key/value object of the values will be returned. Otherwise it will be parsed as JSON.

    Returns
    -------
    Optional[Dict]
        Parsed request&#39;s body for `form-urlencoded` and JSON as a fallback if any.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.postDataJSON)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Request.redirectedFrom"><code class="name">var <span class="ident">redirectedFrom</span> : Union[<a title="playwright.async_api.Request" href="async_api.html#playwright.async_api.Request">Request</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Request.redirectedFrom</p>
<p>When the server responds with a redirect, Playwright creates a new Request object. The two requests are connected by <code>redirectedFrom()</code> and <code>redirectedTo()</code> methods. When multiple server redirects has happened, it is possible to construct the whole redirect chain by repeatedly calling <code>redirectedFrom()</code>.
For example, if the website <code>http://example.com</code> redirects to <code>https://example.com</code>:
If the website <code>https://google.com</code> has no redirects:</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[<a title="playwright.sync_api.Request" href="#playwright.sync_api.Request">Request</a>]</code></dt>
<dd>Request that was redirected by the server to this one, if any.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def redirectedFrom(self) -&gt; typing.Union[&#34;Request&#34;, NoneType]:
    &#34;&#34;&#34;Request.redirectedFrom

    When the server responds with a redirect, Playwright creates a new Request object. The two requests are connected by `redirectedFrom()` and `redirectedTo()` methods. When multiple server redirects has happened, it is possible to construct the whole redirect chain by repeatedly calling `redirectedFrom()`.
    For example, if the website `http://example.com` redirects to `https://example.com`:
    If the website `https://google.com` has no redirects:

    Returns
    -------
    Optional[Request]
        Request that was redirected by the server to this one, if any.
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(self._impl_obj.redirectedFrom)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Request.redirectedTo"><code class="name">var <span class="ident">redirectedTo</span> : Union[<a title="playwright.async_api.Request" href="async_api.html#playwright.async_api.Request">Request</a>, NoneType]</code></dt>
<dd>
<div class="desc"><p>Request.redirectedTo</p>
<p>This method is the opposite of request.redirectedFrom():</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[<a title="playwright.sync_api.Request" href="#playwright.sync_api.Request">Request</a>]</code></dt>
<dd>New request issued by the browser if the server responded with redirect.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def redirectedTo(self) -&gt; typing.Union[&#34;Request&#34;, NoneType]:
    &#34;&#34;&#34;Request.redirectedTo

    This method is the opposite of request.redirectedFrom():

    Returns
    -------
    Optional[Request]
        New request issued by the browser if the server responded with redirect.
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(self._impl_obj.redirectedTo)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Request.resourceType"><code class="name">var <span class="ident">resourceType</span> : str</code></dt>
<dd>
<div class="desc"><p>Request.resourceType</p>
<p>Contains the request's resource type as it was perceived by the rendering engine.
ResourceType will be one of the following: <code>document</code>, <code>stylesheet</code>, <code>image</code>, <code>media</code>, <code>font</code>, <code>script</code>, <code>texttrack</code>, <code>xhr</code>, <code>fetch</code>, <code>eventsource</code>, <code>websocket</code>, <code>manifest</code>, <code>other</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def resourceType(self) -&gt; str:
    &#34;&#34;&#34;Request.resourceType

    Contains the request&#39;s resource type as it was perceived by the rendering engine.
    ResourceType will be one of the following: `document`, `stylesheet`, `image`, `media`, `font`, `script`, `texttrack`, `xhr`, `fetch`, `eventsource`, `websocket`, `manifest`, `other`.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.resourceType)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Request.timing"><code class="name">var <span class="ident">timing</span> : playwright.helper.ResourceTiming</code></dt>
<dd>
<div class="desc"><p>Request.timing</p>
<p>Returns resource timing information for given request. Most of the timing values become available upon the response, <code>responseEnd</code> becomes available when request finishes. Find more information at Resource Timing API.</p>
<h2 id="returns">Returns</h2>
<p>{"startTime": float, "domainLookupStart": float, "domainLookupEnd": float, "connectStart": float, "secureConnectionStart": float, "connectEnd": float, "requestStart": float, "responseStart": float, "responseEnd": float}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def timing(self) -&gt; ResourceTiming:
    &#34;&#34;&#34;Request.timing

    Returns resource timing information for given request. Most of the timing values become available upon the response, `responseEnd` becomes available when request finishes. Find more information at Resource Timing API.

    Returns
    -------
    {&#34;startTime&#34;: float, &#34;domainLookupStart&#34;: float, &#34;domainLookupEnd&#34;: float, &#34;connectStart&#34;: float, &#34;secureConnectionStart&#34;: float, &#34;connectEnd&#34;: float, &#34;requestStart&#34;: float, &#34;responseStart&#34;: float, &#34;responseEnd&#34;: float}
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.timing)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Request.url"><code class="name">var <span class="ident">url</span> : str</code></dt>
<dd>
<div class="desc"><p>Request.url</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>URL of the request.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def url(self) -&gt; str:
    &#34;&#34;&#34;Request.url

    Returns
    -------
    str
        URL of the request.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.url)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.sync_api.Request.isNavigationRequest"><code class="name flex">
<span>def <span class="ident">isNavigationRequest</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Request.isNavigationRequest</p>
<p>Whether this request is driving frame's navigation.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isNavigationRequest(self) -&gt; bool:
    &#34;&#34;&#34;Request.isNavigationRequest

    Whether this request is driving frame&#39;s navigation.

    Returns
    -------
    bool
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.isNavigationRequest())</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Request.response"><code class="name flex">
<span>def <span class="ident">response</span></span>(<span>self) ‑> Union[<a title="playwright.async_api.Response" href="async_api.html#playwright.async_api.Response">Response</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Request.response</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[<a title="playwright.sync_api.Response" href="#playwright.sync_api.Response">Response</a>]</code></dt>
<dd>A matching Response object, or <code>null</code> if the response was not received due to error.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def response(self) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
    &#34;&#34;&#34;Request.response

    Returns
    -------
    Optional[Response]
        A matching Response object, or `null` if the response was not received due to error.
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(self._sync(self._impl_obj.response()))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.sync_api.Response"><code class="flex name class">
<span>class <span class="ident">Response</span></span>
<span>(</span><span>obj: playwright.network.Response)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Response(SyncBase):
    def __init__(self, obj: ResponseImpl):
        super().__init__(obj)

    @property
    def url(self) -&gt; str:
        &#34;&#34;&#34;Response.url

        Contains the URL of the response.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.url)

    @property
    def ok(self) -&gt; bool:
        &#34;&#34;&#34;Response.ok

        Contains a boolean stating whether the response was successful (status in the range 200-299) or not.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.ok)

    @property
    def status(self) -&gt; int:
        &#34;&#34;&#34;Response.status

        Contains the status code of the response (e.g., 200 for a success).

        Returns
        -------
        int
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.status)

    @property
    def statusText(self) -&gt; str:
        &#34;&#34;&#34;Response.statusText

        Contains the status text of the response (e.g. usually an &#34;OK&#34; for a success).

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.statusText)

    @property
    def headers(self) -&gt; typing.Dict[str, str]:
        &#34;&#34;&#34;Response.headers

        Returns
        -------
        Dict[str, str]
            An object with HTTP headers associated with the response. All header names are lower-case.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.headers)

    @property
    def request(self) -&gt; &#34;Request&#34;:
        &#34;&#34;&#34;Response.request

        Returns
        -------
        Request
            A matching Request object.
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.request)

    @property
    def frame(self) -&gt; &#34;Frame&#34;:
        &#34;&#34;&#34;Response.frame

        Returns
        -------
        Frame
            A Frame that initiated this response.
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.frame)

    def finished(self) -&gt; typing.Union[Error, NoneType]:
        &#34;&#34;&#34;Response.finished

        Returns
        -------
        Optional[Error]
            Waits for this response to finish, returns failure error if request failed.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.finished()))

    def body(self) -&gt; bytes:
        &#34;&#34;&#34;Response.body

        Returns
        -------
        bytes
            Promise which resolves to a buffer with response body.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.body()))

    def text(self) -&gt; str:
        &#34;&#34;&#34;Response.text

        Returns
        -------
        str
            Promise which resolves to a text representation of response body.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.text()))

    def json(self) -&gt; typing.Union[typing.Dict, typing.List]:
        &#34;&#34;&#34;Response.json

        This method will throw if the response body is not parsable via `JSON.parse`.

        Returns
        -------
        Union[Dict, List]
            Promise which resolves to a JSON representation of response body.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.json()))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright.sync_base.SyncBase</li>
<li>playwright.impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.sync_api.Response.frame"><code class="name">var <span class="ident">frame</span> : <a title="playwright.sync_api.Frame" href="#playwright.sync_api.Frame">Frame</a></code></dt>
<dd>
<div class="desc"><p>Response.frame</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.Frame" href="#playwright.sync_api.Frame">Frame</a></code></dt>
<dd>A Frame that initiated this response.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frame(self) -&gt; &#34;Frame&#34;:
    &#34;&#34;&#34;Response.frame

    Returns
    -------
    Frame
        A Frame that initiated this response.
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.frame)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Response.headers"><code class="name">var <span class="ident">headers</span> : Dict[str, str]</code></dt>
<dd>
<div class="desc"><p>Response.headers</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, str]</code></dt>
<dd>An object with HTTP headers associated with the response. All header names are lower-case.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def headers(self) -&gt; typing.Dict[str, str]:
    &#34;&#34;&#34;Response.headers

    Returns
    -------
    Dict[str, str]
        An object with HTTP headers associated with the response. All header names are lower-case.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.headers)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Response.ok"><code class="name">var <span class="ident">ok</span> : bool</code></dt>
<dd>
<div class="desc"><p>Response.ok</p>
<p>Contains a boolean stating whether the response was successful (status in the range 200-299) or not.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ok(self) -&gt; bool:
    &#34;&#34;&#34;Response.ok

    Contains a boolean stating whether the response was successful (status in the range 200-299) or not.

    Returns
    -------
    bool
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.ok)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Response.request"><code class="name">var <span class="ident">request</span> : <a title="playwright.sync_api.Request" href="#playwright.sync_api.Request">Request</a></code></dt>
<dd>
<div class="desc"><p>Response.request</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.Request" href="#playwright.sync_api.Request">Request</a></code></dt>
<dd>A matching Request object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def request(self) -&gt; &#34;Request&#34;:
    &#34;&#34;&#34;Response.request

    Returns
    -------
    Request
        A matching Request object.
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.request)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Response.status"><code class="name">var <span class="ident">status</span> : int</code></dt>
<dd>
<div class="desc"><p>Response.status</p>
<p>Contains the status code of the response (e.g., 200 for a success).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def status(self) -&gt; int:
    &#34;&#34;&#34;Response.status

    Contains the status code of the response (e.g., 200 for a success).

    Returns
    -------
    int
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.status)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Response.statusText"><code class="name">var <span class="ident">statusText</span> : str</code></dt>
<dd>
<div class="desc"><p>Response.statusText</p>
<p>Contains the status text of the response (e.g. usually an "OK" for a success).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def statusText(self) -&gt; str:
    &#34;&#34;&#34;Response.statusText

    Contains the status text of the response (e.g. usually an &#34;OK&#34; for a success).

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.statusText)</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Response.url"><code class="name">var <span class="ident">url</span> : str</code></dt>
<dd>
<div class="desc"><p>Response.url</p>
<p>Contains the URL of the response.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def url(self) -&gt; str:
    &#34;&#34;&#34;Response.url

    Contains the URL of the response.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.url)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.sync_api.Response.body"><code class="name flex">
<span>def <span class="ident">body</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Response.body</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>Promise which resolves to a buffer with response body.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def body(self) -&gt; bytes:
    &#34;&#34;&#34;Response.body

    Returns
    -------
    bytes
        Promise which resolves to a buffer with response body.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.body()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Response.finished"><code class="name flex">
<span>def <span class="ident">finished</span></span>(<span>self) ‑> Union[playwright.helper.Error, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Response.finished</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[Error]</code></dt>
<dd>Waits for this response to finish, returns failure error if request failed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finished(self) -&gt; typing.Union[Error, NoneType]:
    &#34;&#34;&#34;Response.finished

    Returns
    -------
    Optional[Error]
        Waits for this response to finish, returns failure error if request failed.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.finished()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Response.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self) ‑> Union[Dict, List]</span>
</code></dt>
<dd>
<div class="desc"><p>Response.json</p>
<p>This method will throw if the response body is not parsable via <code>JSON.parse</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[Dict, List]</code></dt>
<dd>Promise which resolves to a JSON representation of response body.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json(self) -&gt; typing.Union[typing.Dict, typing.List]:
    &#34;&#34;&#34;Response.json

    This method will throw if the response body is not parsable via `JSON.parse`.

    Returns
    -------
    Union[Dict, List]
        Promise which resolves to a JSON representation of response body.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.json()))</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Response.text"><code class="name flex">
<span>def <span class="ident">text</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Response.text</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Promise which resolves to a text representation of response body.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def text(self) -&gt; str:
    &#34;&#34;&#34;Response.text

    Returns
    -------
    str
        Promise which resolves to a text representation of response body.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.text()))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.sync_api.Route"><code class="flex name class">
<span>class <span class="ident">Route</span></span>
<span>(</span><span>obj: playwright.network.Route)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Route(SyncBase):
    def __init__(self, obj: RouteImpl):
        super().__init__(obj)

    @property
    def request(self) -&gt; &#34;Request&#34;:
        &#34;&#34;&#34;Route.request

        Returns
        -------
        Request
            A request to be routed.
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.request)

    def abort(self, errorCode: str = None) -&gt; NoneType:
        &#34;&#34;&#34;Route.abort

        Aborts the route&#39;s request.

        Parameters
        ----------
        errorCode : Optional[str]
            Optional error code. Defaults to `failed`, could be
            one of the following:
             - `&#39;aborted&#39;` - An operation was aborted (due to user action)
             - `&#39;accessdenied&#39;` - Permission to access a resource, other than the network, was denied
             - `&#39;addressunreachable&#39;` - The IP address is unreachable. This usually means
             - that there is no route to the specified host or network.
             - `&#39;blockedbyclient&#39;` - The client chose to block the request.
             - `&#39;blockedbyresponse&#39;` - The request failed because the response was delivered along with requirements which are not met (&#39;X-Frame-Options&#39; and &#39;Content-Security-Policy&#39; ancestor checks, for instance).
             - `&#39;connectionaborted&#39;` - A connection timed out as a result of not receiving an ACK for data sent.
             - `&#39;connectionclosed&#39;` - A connection was closed (corresponding to a TCP FIN).
             - `&#39;connectionfailed&#39;` - A connection attempt failed.
             - `&#39;connectionrefused&#39;` - A connection attempt was refused.
             - `&#39;connectionreset&#39;` - A connection was reset (corresponding to a TCP RST).
             - `&#39;internetdisconnected&#39;` - The Internet connection has been lost.
             - `&#39;namenotresolved&#39;` - The host name could not be resolved.
             - `&#39;timedout&#39;` - An operation timed out.
             - `&#39;failed&#39;` - A generic failure occurred.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(self._impl_obj.abort(errorCode=errorCode))
        )

    def fulfill(
        self,
        status: int = None,
        headers: typing.Union[typing.Dict[str, str]] = None,
        body: typing.Union[str, bytes] = None,
        path: typing.Union[str, pathlib.Path] = None,
        contentType: str = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Route.fulfill

        Fulfills route&#39;s request with given response.
        An example of fulfilling all requests with 404 responses:
        An example of serving static file:

        Parameters
        ----------
        status : Optional[int]
            Response status code, defaults to `200`.
        headers : Optional[Dict[str, str]]
            Optional response headers. Header values will be converted to a string.
        body : Union[str, bytes, NoneType]
            Optional response body.
        path : Union[str, pathlib.Path, NoneType]
            Optional file path to respond with. The content type will be inferred from file extension. If `path` is a relative path, then it is resolved relative to current working directory.
        contentType : Optional[str]
            If set, equals to setting `Content-Type` response header.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.fulfill(
                    status=status,
                    headers=mapping.to_impl(headers),
                    body=body,
                    path=path,
                    contentType=contentType,
                )
            )
        )

    def continue_(
        self,
        url: str = None,
        method: str = None,
        headers: typing.Union[typing.Dict[str, str]] = None,
        postData: typing.Union[str, bytes] = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Route.continue_

        Continues route&#39;s request with optional overrides.

        Parameters
        ----------
        url : Optional[str]
            If set changes the request URL. New URL must have same protocol as original one.
        method : Optional[str]
            If set changes the request method (e.g. GET or POST)
        headers : Optional[Dict[str, str]]
            If set changes the request HTTP headers. Header values will be converted to a string.
        postData : Union[str, bytes, NoneType]
            If set changes the post data of request
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.continue_(
                    url=url,
                    method=method,
                    headers=mapping.to_impl(headers),
                    postData=postData,
                )
            )
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright.sync_base.SyncBase</li>
<li>playwright.impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.sync_api.Route.request"><code class="name">var <span class="ident">request</span> : <a title="playwright.sync_api.Request" href="#playwright.sync_api.Request">Request</a></code></dt>
<dd>
<div class="desc"><p>Route.request</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.Request" href="#playwright.sync_api.Request">Request</a></code></dt>
<dd>A request to be routed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def request(self) -&gt; &#34;Request&#34;:
    &#34;&#34;&#34;Route.request

    Returns
    -------
    Request
        A request to be routed.
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.request)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.sync_api.Route.abort"><code class="name flex">
<span>def <span class="ident">abort</span></span>(<span>self, errorCode: str = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Route.abort</p>
<p>Aborts the route's request.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>errorCode</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Optional error code. Defaults to <code>failed</code>, could be
one of the following:
- <code>'aborted'</code> - An operation was aborted (due to user action)
- <code>'accessdenied'</code> - Permission to access a resource, other than the network, was denied
- <code>'addressunreachable'</code> - The IP address is unreachable. This usually means
- that there is no route to the specified host or network.
- <code>'blockedbyclient'</code> - The client chose to block the request.
- <code>'blockedbyresponse'</code> - The request failed because the response was delivered along with requirements which are not met ('X-Frame-Options' and 'Content-Security-Policy' ancestor checks, for instance).
- <code>'connectionaborted'</code> - A connection timed out as a result of not receiving an ACK for data sent.
- <code>'connectionclosed'</code> - A connection was closed (corresponding to a TCP FIN).
- <code>'connectionfailed'</code> - A connection attempt failed.
- <code>'connectionrefused'</code> - A connection attempt was refused.
- <code>'connectionreset'</code> - A connection was reset (corresponding to a TCP RST).
- <code>'internetdisconnected'</code> - The Internet connection has been lost.
- <code>'namenotresolved'</code> - The host name could not be resolved.
- <code>'timedout'</code> - An operation timed out.
- <code>'failed'</code> - A generic failure occurred.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def abort(self, errorCode: str = None) -&gt; NoneType:
    &#34;&#34;&#34;Route.abort

    Aborts the route&#39;s request.

    Parameters
    ----------
    errorCode : Optional[str]
        Optional error code. Defaults to `failed`, could be
        one of the following:
         - `&#39;aborted&#39;` - An operation was aborted (due to user action)
         - `&#39;accessdenied&#39;` - Permission to access a resource, other than the network, was denied
         - `&#39;addressunreachable&#39;` - The IP address is unreachable. This usually means
         - that there is no route to the specified host or network.
         - `&#39;blockedbyclient&#39;` - The client chose to block the request.
         - `&#39;blockedbyresponse&#39;` - The request failed because the response was delivered along with requirements which are not met (&#39;X-Frame-Options&#39; and &#39;Content-Security-Policy&#39; ancestor checks, for instance).
         - `&#39;connectionaborted&#39;` - A connection timed out as a result of not receiving an ACK for data sent.
         - `&#39;connectionclosed&#39;` - A connection was closed (corresponding to a TCP FIN).
         - `&#39;connectionfailed&#39;` - A connection attempt failed.
         - `&#39;connectionrefused&#39;` - A connection attempt was refused.
         - `&#39;connectionreset&#39;` - A connection was reset (corresponding to a TCP RST).
         - `&#39;internetdisconnected&#39;` - The Internet connection has been lost.
         - `&#39;namenotresolved&#39;` - The host name could not be resolved.
         - `&#39;timedout&#39;` - An operation timed out.
         - `&#39;failed&#39;` - A generic failure occurred.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(self._impl_obj.abort(errorCode=errorCode))
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Route.continue_"><code class="name flex">
<span>def <span class="ident">continue_</span></span>(<span>self, url: str = None, method: str = None, headers: Dict[str, str] = None, postData: Union[str, bytes] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Route.continue_</p>
<p>Continues route's request with optional overrides.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>If set changes the request URL. New URL must have same protocol as original one.</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>If set changes the request method (e.g. GET or POST)</dd>
<dt><strong><code>headers</code></strong> :&ensp;<code>Optional[Dict[str, str]]</code></dt>
<dd>If set changes the request HTTP headers. Header values will be converted to a string.</dd>
<dt><strong><code>postData</code></strong> :&ensp;<code>Union[str, bytes, NoneType]</code></dt>
<dd>If set changes the post data of request</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def continue_(
    self,
    url: str = None,
    method: str = None,
    headers: typing.Union[typing.Dict[str, str]] = None,
    postData: typing.Union[str, bytes] = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Route.continue_

    Continues route&#39;s request with optional overrides.

    Parameters
    ----------
    url : Optional[str]
        If set changes the request URL. New URL must have same protocol as original one.
    method : Optional[str]
        If set changes the request method (e.g. GET or POST)
    headers : Optional[Dict[str, str]]
        If set changes the request HTTP headers. Header values will be converted to a string.
    postData : Union[str, bytes, NoneType]
        If set changes the post data of request
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.continue_(
                url=url,
                method=method,
                headers=mapping.to_impl(headers),
                postData=postData,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Route.fulfill"><code class="name flex">
<span>def <span class="ident">fulfill</span></span>(<span>self, status: int = None, headers: Dict[str, str] = None, body: Union[str, bytes] = None, path: Union[str, pathlib.Path] = None, contentType: str = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Route.fulfill</p>
<p>Fulfills route's request with given response.
An example of fulfilling all requests with 404 responses:
An example of serving static file:</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Response status code, defaults to <code>200</code>.</dd>
<dt><strong><code>headers</code></strong> :&ensp;<code>Optional[Dict[str, str]]</code></dt>
<dd>Optional response headers. Header values will be converted to a string.</dd>
<dt><strong><code>body</code></strong> :&ensp;<code>Union[str, bytes, NoneType]</code></dt>
<dd>Optional response body.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[str, pathlib.Path, NoneType]</code></dt>
<dd>Optional file path to respond with. The content type will be inferred from file extension. If <code>path</code> is a relative path, then it is resolved relative to current working directory.</dd>
<dt><strong><code>contentType</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>If set, equals to setting <code>Content-Type</code> response header.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fulfill(
    self,
    status: int = None,
    headers: typing.Union[typing.Dict[str, str]] = None,
    body: typing.Union[str, bytes] = None,
    path: typing.Union[str, pathlib.Path] = None,
    contentType: str = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Route.fulfill

    Fulfills route&#39;s request with given response.
    An example of fulfilling all requests with 404 responses:
    An example of serving static file:

    Parameters
    ----------
    status : Optional[int]
        Response status code, defaults to `200`.
    headers : Optional[Dict[str, str]]
        Optional response headers. Header values will be converted to a string.
    body : Union[str, bytes, NoneType]
        Optional response body.
    path : Union[str, pathlib.Path, NoneType]
        Optional file path to respond with. The content type will be inferred from file extension. If `path` is a relative path, then it is resolved relative to current working directory.
    contentType : Optional[str]
        If set, equals to setting `Content-Type` response header.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.fulfill(
                status=status,
                headers=mapping.to_impl(headers),
                body=body,
                path=path,
                contentType=contentType,
            )
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.sync_api.Selectors"><code class="flex name class">
<span>class <span class="ident">Selectors</span></span>
<span>(</span><span>obj: playwright.selectors.Selectors)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Selectors(SyncBase):
    def __init__(self, obj: SelectorsImpl):
        super().__init__(obj)

    def register(
        self,
        name: str,
        source: str = None,
        path: typing.Union[str, pathlib.Path] = None,
        contentScript: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Selectors.register

        An example of registering selector engine that queries elements based on a tag name:

        Parameters
        ----------
        name : str
            Name that is used in selectors as a prefix, e.g. `{name: &#39;foo&#39;}` enables `foo=myselectorbody` selectors. May only contain `[a-zA-Z0-9_]` characters.
        source : Optional[str]
            Script that evaluates to a selector engine instance.
        contentScript : Optional[bool]
            Whether to run this selector engine in isolated JavaScript environment. This environment has access to the same DOM, but not any JavaScript objects from the frame&#39;s scripts. Defaults to `false`. Note that running as a content script is not guaranteed when this engine is used together with other registered engines.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.register(
                    name=name, source=source, path=path, contentScript=contentScript
                )
            )
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright.sync_base.SyncBase</li>
<li>playwright.impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="playwright.sync_api.Selectors.register"><code class="name flex">
<span>def <span class="ident">register</span></span>(<span>self, name: str, source: str = None, path: Union[str, pathlib.Path] = None, contentScript: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Selectors.register</p>
<p>An example of registering selector engine that queries elements based on a tag name:</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name that is used in selectors as a prefix, e.g. <code>{name: 'foo'}</code> enables <code>foo=myselectorbody</code> selectors. May only contain <code>[a-zA-Z0-9_]</code> characters.</dd>
<dt><strong><code>source</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Script that evaluates to a selector engine instance.</dd>
<dt><strong><code>contentScript</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether to run this selector engine in isolated JavaScript environment. This environment has access to the same DOM, but not any JavaScript objects from the frame's scripts. Defaults to <code>false</code>. Note that running as a content script is not guaranteed when this engine is used together with other registered engines.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register(
    self,
    name: str,
    source: str = None,
    path: typing.Union[str, pathlib.Path] = None,
    contentScript: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Selectors.register

    An example of registering selector engine that queries elements based on a tag name:

    Parameters
    ----------
    name : str
        Name that is used in selectors as a prefix, e.g. `{name: &#39;foo&#39;}` enables `foo=myselectorbody` selectors. May only contain `[a-zA-Z0-9_]` characters.
    source : Optional[str]
        Script that evaluates to a selector engine instance.
    contentScript : Optional[bool]
        Whether to run this selector engine in isolated JavaScript environment. This environment has access to the same DOM, but not any JavaScript objects from the frame&#39;s scripts. Defaults to `false`. Note that running as a content script is not guaranteed when this engine is used together with other registered engines.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.register(
                name=name, source=source, path=path, contentScript=contentScript
            )
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.sync_api.Touchscreen"><code class="flex name class">
<span>class <span class="ident">Touchscreen</span></span>
<span>(</span><span>obj: playwright.input.Touchscreen)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Touchscreen(SyncBase):
    def __init__(self, obj: TouchscreenImpl):
        super().__init__(obj)

    def tap(self, x: float, y: float) -&gt; NoneType:
        &#34;&#34;&#34;Touchscreen.tap

        Dispatches a `touchstart` and `touchend` event with a single touch at the position (`x`,`y`).

        Parameters
        ----------
        x : float
        y : float
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.tap(x=x, y=y)))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright.sync_base.SyncBase</li>
<li>playwright.impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="playwright.sync_api.Touchscreen.tap"><code class="name flex">
<span>def <span class="ident">tap</span></span>(<span>self, x: float, y: float) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Touchscreen.tap</p>
<p>Dispatches a <code>touchstart</code> and <code>touchend</code> event with a single touch at the position (<code>x</code>,<code>y</code>).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tap(self, x: float, y: float) -&gt; NoneType:
    &#34;&#34;&#34;Touchscreen.tap

    Dispatches a `touchstart` and `touchend` event with a single touch at the position (`x`,`y`).

    Parameters
    ----------
    x : float
    y : float
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.tap(x=x, y=y)))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.sync_api.Video"><code class="flex name class">
<span>class <span class="ident">Video</span></span>
<span>(</span><span>obj: <a title="playwright.video.Video" href="video.html#playwright.video.Video">Video</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Video(SyncBase):
    def __init__(self, obj: VideoImpl):
        super().__init__(obj)

    def path(self) -&gt; str:
        &#34;&#34;&#34;Video.path

        Returns the file system path this video will be recorded to. The video is guaranteed to be written to the filesystem upon closing the browser context.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._sync(self._impl_obj.path()))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright.sync_base.SyncBase</li>
<li>playwright.impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="playwright.sync_api.Video.path"><code class="name flex">
<span>def <span class="ident">path</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Video.path</p>
<p>Returns the file system path this video will be recorded to. The video is guaranteed to be written to the filesystem upon closing the browser context.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def path(self) -&gt; str:
    &#34;&#34;&#34;Video.path

    Returns the file system path this video will be recorded to. The video is guaranteed to be written to the filesystem upon closing the browser context.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._sync(self._impl_obj.path()))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.sync_api.WebSocket"><code class="flex name class">
<span>class <span class="ident">WebSocket</span></span>
<span>(</span><span>obj: playwright.network.WebSocket)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WebSocket(SyncBase):
    def __init__(self, obj: WebSocketImpl):
        super().__init__(obj)

    @property
    def url(self) -&gt; str:
        &#34;&#34;&#34;WebSocket.url

        Contains the URL of the WebSocket.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.url)

    def waitForEvent(
        self,
        event: str,
        predicate: typing.Union[typing.Callable[[typing.Any], bool]] = None,
        timeout: int = None,
    ) -&gt; typing.Any:
        &#34;&#34;&#34;WebSocket.waitForEvent

        Waits for event to fire and passes its value into the predicate function. Resolves when the predicate returns truthy value. Will throw an error if the webSocket is closed before the event
        is fired.

        Parameters
        ----------
        event : str
            Event name, same one would pass into `webSocket.on(event)`.

        Returns
        -------
        Any
            Promise which resolves to the event data value.
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.waitForEvent(
                    event=event,
                    predicate=self._wrap_handler(predicate),
                    timeout=timeout,
                )
            )
        )

    def expect_event(
        self,
        event: str,
        predicate: typing.Union[typing.Callable[[typing.Any], bool]] = None,
        timeout: int = None,
    ) -&gt; EventContextManager:
        return EventContextManager(
            self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
        )

    def isClosed(self) -&gt; bool:
        &#34;&#34;&#34;WebSocket.isClosed

        Indicates that the web socket has been closed.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.isClosed())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright.sync_base.SyncBase</li>
<li>playwright.impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.sync_api.WebSocket.url"><code class="name">var <span class="ident">url</span> : str</code></dt>
<dd>
<div class="desc"><p>WebSocket.url</p>
<p>Contains the URL of the WebSocket.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def url(self) -&gt; str:
    &#34;&#34;&#34;WebSocket.url

    Contains the URL of the WebSocket.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.url)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.sync_api.WebSocket.expect_event"><code class="name flex">
<span>def <span class="ident">expect_event</span></span>(<span>self, event: str, predicate: Callable[[Any], bool] = None, timeout: int = None) ‑> playwright.sync_base.EventContextManager</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_event(
    self,
    event: str,
    predicate: typing.Union[typing.Callable[[typing.Any], bool]] = None,
    timeout: int = None,
) -&gt; EventContextManager:
    return EventContextManager(
        self._loop, self._impl_obj.waitForEvent(event, predicate, timeout)
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.WebSocket.isClosed"><code class="name flex">
<span>def <span class="ident">isClosed</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>WebSocket.isClosed</p>
<p>Indicates that the web socket has been closed.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isClosed(self) -&gt; bool:
    &#34;&#34;&#34;WebSocket.isClosed

    Indicates that the web socket has been closed.

    Returns
    -------
    bool
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.isClosed())</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.WebSocket.waitForEvent"><code class="name flex">
<span>def <span class="ident">waitForEvent</span></span>(<span>self, event: str, predicate: Callable[[Any], bool] = None, timeout: int = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>WebSocket.waitForEvent</p>
<p>Waits for event to fire and passes its value into the predicate function. Resolves when the predicate returns truthy value. Will throw an error if the webSocket is closed before the event
is fired.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>str</code></dt>
<dd>Event name, same one would pass into <code>webSocket.on(event)</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>Promise which resolves to the event data value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def waitForEvent(
    self,
    event: str,
    predicate: typing.Union[typing.Callable[[typing.Any], bool]] = None,
    timeout: int = None,
) -&gt; typing.Any:
    &#34;&#34;&#34;WebSocket.waitForEvent

    Waits for event to fire and passes its value into the predicate function. Resolves when the predicate returns truthy value. Will throw an error if the webSocket is closed before the event
    is fired.

    Parameters
    ----------
    event : str
        Event name, same one would pass into `webSocket.on(event)`.

    Returns
    -------
    Any
        Promise which resolves to the event data value.
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.waitForEvent(
                event=event,
                predicate=self._wrap_handler(predicate),
                timeout=timeout,
            )
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.sync_api.Worker"><code class="flex name class">
<span>class <span class="ident">Worker</span></span>
<span>(</span><span>obj: playwright.page.Worker)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Worker(SyncBase):
    def __init__(self, obj: WorkerImpl):
        super().__init__(obj)

    @property
    def url(self) -&gt; str:
        &#34;&#34;&#34;Worker.url

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.url)

    def evaluate(
        self, expression: str, arg: typing.Any = None, force_expr: bool = None
    ) -&gt; typing.Any:
        &#34;&#34;&#34;Worker.evaluate

        If the function passed to the `worker.evaluate` returns a Promise, then `worker.evaluate` would wait for the promise to resolve and return its value.
        If the function passed to the `worker.evaluate` returns a non-Serializable value, then `worker.evaluate` resolves to `undefined`. DevTools Protocol also supports transferring some additional values that are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and bigint literals.

        Parameters
        ----------
        expression : str
            Function to be evaluated in the worker context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        Any
            Promise which resolves to the return value of `pageFunction`
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(
            self._sync(
                self._impl_obj.evaluate(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )

    def evaluateHandle(
        self, expression: str, arg: typing.Any = None, force_expr: bool = None
    ) -&gt; &#34;JSHandle&#34;:
        &#34;&#34;&#34;Worker.evaluateHandle

        The only difference between `worker.evaluate` and `worker.evaluateHandle` is that `worker.evaluateHandle` returns in-page object (JSHandle).
        If the function passed to the `worker.evaluateHandle` returns a Promise, then `worker.evaluateHandle` would wait for the promise to resolve and return its value.

        Parameters
        ----------
        expression : str
            Function to be evaluated in the page context
        force_expr : bool
            Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
        arg : Optional[Any]
            Optional argument to pass to `pageFunction`

        Returns
        -------
        JSHandle
            Promise which resolves to the return value of `pageFunction` as in-page object (JSHandle)
        &#34;&#34;&#34;
        return mapping.from_impl(
            self._sync(
                self._impl_obj.evaluateHandle(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright.sync_base.SyncBase</li>
<li>playwright.impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.sync_api.Worker.url"><code class="name">var <span class="ident">url</span> : str</code></dt>
<dd>
<div class="desc"><p>Worker.url</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def url(self) -&gt; str:
    &#34;&#34;&#34;Worker.url

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.url)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.sync_api.Worker.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, expression: str, arg: Any = None, force_expr: bool = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Worker.evaluate</p>
<p>If the function passed to the <code>worker.evaluate</code> returns a Promise, then <code>worker.evaluate</code> would wait for the promise to resolve and return its value.
If the function passed to the <code>worker.evaluate</code> returns a non-Serializable value, then <code>worker.evaluate</code> resolves to <code>undefined</code>. DevTools Protocol also supports transferring some additional values that are not serializable by <code>JSON</code>: <code>-0</code>, <code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code>, and bigint literals.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>Function to be evaluated in the worker context</dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Optional[Any]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>Promise which resolves to the return value of <code>pageFunction</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(
    self, expression: str, arg: typing.Any = None, force_expr: bool = None
) -&gt; typing.Any:
    &#34;&#34;&#34;Worker.evaluate

    If the function passed to the `worker.evaluate` returns a Promise, then `worker.evaluate` would wait for the promise to resolve and return its value.
    If the function passed to the `worker.evaluate` returns a non-Serializable value, then `worker.evaluate` resolves to `undefined`. DevTools Protocol also supports transferring some additional values that are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and bigint literals.

    Parameters
    ----------
    expression : str
        Function to be evaluated in the worker context
    force_expr : bool
        Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
    arg : Optional[Any]
        Optional argument to pass to `pageFunction`

    Returns
    -------
    Any
        Promise which resolves to the return value of `pageFunction`
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(
        self._sync(
            self._impl_obj.evaluate(
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="playwright.sync_api.Worker.evaluateHandle"><code class="name flex">
<span>def <span class="ident">evaluateHandle</span></span>(<span>self, expression: str, arg: Any = None, force_expr: bool = None) ‑> <a title="playwright.sync_api.JSHandle" href="#playwright.sync_api.JSHandle">JSHandle</a></span>
</code></dt>
<dd>
<div class="desc"><p>Worker.evaluateHandle</p>
<p>The only difference between <code>worker.evaluate</code> and <code>worker.evaluateHandle</code> is that <code>worker.evaluateHandle</code> returns in-page object (JSHandle).
If the function passed to the <code>worker.evaluateHandle</code> returns a Promise, then <code>worker.evaluateHandle</code> would wait for the promise to resolve and return its value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>Function to be evaluated in the page context</dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Optional[Any]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.sync_api.JSHandle" href="#playwright.sync_api.JSHandle">JSHandle</a></code></dt>
<dd>Promise which resolves to the return value of <code>pageFunction</code> as in-page object (JSHandle)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluateHandle(
    self, expression: str, arg: typing.Any = None, force_expr: bool = None
) -&gt; &#34;JSHandle&#34;:
    &#34;&#34;&#34;Worker.evaluateHandle

    The only difference between `worker.evaluate` and `worker.evaluateHandle` is that `worker.evaluateHandle` returns in-page object (JSHandle).
    If the function passed to the `worker.evaluateHandle` returns a Promise, then `worker.evaluateHandle` would wait for the promise to resolve and return its value.

    Parameters
    ----------
    expression : str
        Function to be evaluated in the page context
    force_expr : bool
        Whether to treat given expression as JavaScript evaluate expression, even though it looks like an arrow function
    arg : Optional[Any]
        Optional argument to pass to `pageFunction`

    Returns
    -------
    JSHandle
        Promise which resolves to the return value of `pageFunction` as in-page object (JSHandle)
    &#34;&#34;&#34;
    return mapping.from_impl(
        self._sync(
            self._impl_obj.evaluateHandle(
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="playwright" href="index.html">playwright</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="playwright.sync_api.Accessibility" href="#playwright.sync_api.Accessibility">Accessibility</a></code></h4>
<ul class="">
<li><code><a title="playwright.sync_api.Accessibility.snapshot" href="#playwright.sync_api.Accessibility.snapshot">snapshot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.sync_api.BindingCall" href="#playwright.sync_api.BindingCall">BindingCall</a></code></h4>
<ul class="">
<li><code><a title="playwright.sync_api.BindingCall.call" href="#playwright.sync_api.BindingCall.call">call</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.sync_api.Browser" href="#playwright.sync_api.Browser">Browser</a></code></h4>
<ul class="two-column">
<li><code><a title="playwright.sync_api.Browser.close" href="#playwright.sync_api.Browser.close">close</a></code></li>
<li><code><a title="playwright.sync_api.Browser.contexts" href="#playwright.sync_api.Browser.contexts">contexts</a></code></li>
<li><code><a title="playwright.sync_api.Browser.isConnected" href="#playwright.sync_api.Browser.isConnected">isConnected</a></code></li>
<li><code><a title="playwright.sync_api.Browser.newContext" href="#playwright.sync_api.Browser.newContext">newContext</a></code></li>
<li><code><a title="playwright.sync_api.Browser.newPage" href="#playwright.sync_api.Browser.newPage">newPage</a></code></li>
<li><code><a title="playwright.sync_api.Browser.version" href="#playwright.sync_api.Browser.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.sync_api.BrowserContext" href="#playwright.sync_api.BrowserContext">BrowserContext</a></code></h4>
<ul class="">
<li><code><a title="playwright.sync_api.BrowserContext.addCookies" href="#playwright.sync_api.BrowserContext.addCookies">addCookies</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.addInitScript" href="#playwright.sync_api.BrowserContext.addInitScript">addInitScript</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.browser" href="#playwright.sync_api.BrowserContext.browser">browser</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.clearCookies" href="#playwright.sync_api.BrowserContext.clearCookies">clearCookies</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.clearPermissions" href="#playwright.sync_api.BrowserContext.clearPermissions">clearPermissions</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.close" href="#playwright.sync_api.BrowserContext.close">close</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.cookies" href="#playwright.sync_api.BrowserContext.cookies">cookies</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.expect_event" href="#playwright.sync_api.BrowserContext.expect_event">expect_event</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.expect_page" href="#playwright.sync_api.BrowserContext.expect_page">expect_page</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.exposeBinding" href="#playwright.sync_api.BrowserContext.exposeBinding">exposeBinding</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.exposeFunction" href="#playwright.sync_api.BrowserContext.exposeFunction">exposeFunction</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.grantPermissions" href="#playwright.sync_api.BrowserContext.grantPermissions">grantPermissions</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.newPage" href="#playwright.sync_api.BrowserContext.newPage">newPage</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.pages" href="#playwright.sync_api.BrowserContext.pages">pages</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.route" href="#playwright.sync_api.BrowserContext.route">route</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.setDefaultNavigationTimeout" href="#playwright.sync_api.BrowserContext.setDefaultNavigationTimeout">setDefaultNavigationTimeout</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.setDefaultTimeout" href="#playwright.sync_api.BrowserContext.setDefaultTimeout">setDefaultTimeout</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.setExtraHTTPHeaders" href="#playwright.sync_api.BrowserContext.setExtraHTTPHeaders">setExtraHTTPHeaders</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.setGeolocation" href="#playwright.sync_api.BrowserContext.setGeolocation">setGeolocation</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.setOffline" href="#playwright.sync_api.BrowserContext.setOffline">setOffline</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.storageState" href="#playwright.sync_api.BrowserContext.storageState">storageState</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.unroute" href="#playwright.sync_api.BrowserContext.unroute">unroute</a></code></li>
<li><code><a title="playwright.sync_api.BrowserContext.waitForEvent" href="#playwright.sync_api.BrowserContext.waitForEvent">waitForEvent</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.sync_api.BrowserType" href="#playwright.sync_api.BrowserType">BrowserType</a></code></h4>
<ul class="">
<li><code><a title="playwright.sync_api.BrowserType.executablePath" href="#playwright.sync_api.BrowserType.executablePath">executablePath</a></code></li>
<li><code><a title="playwright.sync_api.BrowserType.launch" href="#playwright.sync_api.BrowserType.launch">launch</a></code></li>
<li><code><a title="playwright.sync_api.BrowserType.launchPersistentContext" href="#playwright.sync_api.BrowserType.launchPersistentContext">launchPersistentContext</a></code></li>
<li><code><a title="playwright.sync_api.BrowserType.name" href="#playwright.sync_api.BrowserType.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.sync_api.CDPSession" href="#playwright.sync_api.CDPSession">CDPSession</a></code></h4>
<ul class="">
<li><code><a title="playwright.sync_api.CDPSession.detach" href="#playwright.sync_api.CDPSession.detach">detach</a></code></li>
<li><code><a title="playwright.sync_api.CDPSession.send" href="#playwright.sync_api.CDPSession.send">send</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.sync_api.ChromiumBrowserContext" href="#playwright.sync_api.ChromiumBrowserContext">ChromiumBrowserContext</a></code></h4>
<ul class="">
<li><code><a title="playwright.sync_api.ChromiumBrowserContext.backgroundPages" href="#playwright.sync_api.ChromiumBrowserContext.backgroundPages">backgroundPages</a></code></li>
<li><code><a title="playwright.sync_api.ChromiumBrowserContext.newCDPSession" href="#playwright.sync_api.ChromiumBrowserContext.newCDPSession">newCDPSession</a></code></li>
<li><code><a title="playwright.sync_api.ChromiumBrowserContext.serviceWorkers" href="#playwright.sync_api.ChromiumBrowserContext.serviceWorkers">serviceWorkers</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.sync_api.ConsoleMessage" href="#playwright.sync_api.ConsoleMessage">ConsoleMessage</a></code></h4>
<ul class="">
<li><code><a title="playwright.sync_api.ConsoleMessage.args" href="#playwright.sync_api.ConsoleMessage.args">args</a></code></li>
<li><code><a title="playwright.sync_api.ConsoleMessage.location" href="#playwright.sync_api.ConsoleMessage.location">location</a></code></li>
<li><code><a title="playwright.sync_api.ConsoleMessage.text" href="#playwright.sync_api.ConsoleMessage.text">text</a></code></li>
<li><code><a title="playwright.sync_api.ConsoleMessage.type" href="#playwright.sync_api.ConsoleMessage.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.sync_api.Dialog" href="#playwright.sync_api.Dialog">Dialog</a></code></h4>
<ul class="">
<li><code><a title="playwright.sync_api.Dialog.accept" href="#playwright.sync_api.Dialog.accept">accept</a></code></li>
<li><code><a title="playwright.sync_api.Dialog.defaultValue" href="#playwright.sync_api.Dialog.defaultValue">defaultValue</a></code></li>
<li><code><a title="playwright.sync_api.Dialog.dismiss" href="#playwright.sync_api.Dialog.dismiss">dismiss</a></code></li>
<li><code><a title="playwright.sync_api.Dialog.message" href="#playwright.sync_api.Dialog.message">message</a></code></li>
<li><code><a title="playwright.sync_api.Dialog.type" href="#playwright.sync_api.Dialog.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.sync_api.Download" href="#playwright.sync_api.Download">Download</a></code></h4>
<ul class="two-column">
<li><code><a title="playwright.sync_api.Download.delete" href="#playwright.sync_api.Download.delete">delete</a></code></li>
<li><code><a title="playwright.sync_api.Download.failure" href="#playwright.sync_api.Download.failure">failure</a></code></li>
<li><code><a title="playwright.sync_api.Download.path" href="#playwright.sync_api.Download.path">path</a></code></li>
<li><code><a title="playwright.sync_api.Download.saveAs" href="#playwright.sync_api.Download.saveAs">saveAs</a></code></li>
<li><code><a title="playwright.sync_api.Download.suggestedFilename" href="#playwright.sync_api.Download.suggestedFilename">suggestedFilename</a></code></li>
<li><code><a title="playwright.sync_api.Download.url" href="#playwright.sync_api.Download.url">url</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.sync_api.ElementHandle" href="#playwright.sync_api.ElementHandle">ElementHandle</a></code></h4>
<ul class="">
<li><code><a title="playwright.sync_api.ElementHandle.asElement" href="#playwright.sync_api.ElementHandle.asElement">asElement</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.boundingBox" href="#playwright.sync_api.ElementHandle.boundingBox">boundingBox</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.check" href="#playwright.sync_api.ElementHandle.check">check</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.click" href="#playwright.sync_api.ElementHandle.click">click</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.contentFrame" href="#playwright.sync_api.ElementHandle.contentFrame">contentFrame</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.dblclick" href="#playwright.sync_api.ElementHandle.dblclick">dblclick</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.dispatchEvent" href="#playwright.sync_api.ElementHandle.dispatchEvent">dispatchEvent</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.evalOnSelector" href="#playwright.sync_api.ElementHandle.evalOnSelector">evalOnSelector</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.evalOnSelectorAll" href="#playwright.sync_api.ElementHandle.evalOnSelectorAll">evalOnSelectorAll</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.fill" href="#playwright.sync_api.ElementHandle.fill">fill</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.focus" href="#playwright.sync_api.ElementHandle.focus">focus</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.getAttribute" href="#playwright.sync_api.ElementHandle.getAttribute">getAttribute</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.hover" href="#playwright.sync_api.ElementHandle.hover">hover</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.innerHTML" href="#playwright.sync_api.ElementHandle.innerHTML">innerHTML</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.innerText" href="#playwright.sync_api.ElementHandle.innerText">innerText</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.ownerFrame" href="#playwright.sync_api.ElementHandle.ownerFrame">ownerFrame</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.press" href="#playwright.sync_api.ElementHandle.press">press</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.querySelector" href="#playwright.sync_api.ElementHandle.querySelector">querySelector</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.querySelectorAll" href="#playwright.sync_api.ElementHandle.querySelectorAll">querySelectorAll</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.screenshot" href="#playwright.sync_api.ElementHandle.screenshot">screenshot</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.scrollIntoViewIfNeeded" href="#playwright.sync_api.ElementHandle.scrollIntoViewIfNeeded">scrollIntoViewIfNeeded</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.selectOption" href="#playwright.sync_api.ElementHandle.selectOption">selectOption</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.selectText" href="#playwright.sync_api.ElementHandle.selectText">selectText</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.setInputFiles" href="#playwright.sync_api.ElementHandle.setInputFiles">setInputFiles</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.tap" href="#playwright.sync_api.ElementHandle.tap">tap</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.textContent" href="#playwright.sync_api.ElementHandle.textContent">textContent</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.toString" href="#playwright.sync_api.ElementHandle.toString">toString</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.type" href="#playwright.sync_api.ElementHandle.type">type</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.uncheck" href="#playwright.sync_api.ElementHandle.uncheck">uncheck</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.waitForElementState" href="#playwright.sync_api.ElementHandle.waitForElementState">waitForElementState</a></code></li>
<li><code><a title="playwright.sync_api.ElementHandle.waitForSelector" href="#playwright.sync_api.ElementHandle.waitForSelector">waitForSelector</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.sync_api.FileChooser" href="#playwright.sync_api.FileChooser">FileChooser</a></code></h4>
<ul class="">
<li><code><a title="playwright.sync_api.FileChooser.element" href="#playwright.sync_api.FileChooser.element">element</a></code></li>
<li><code><a title="playwright.sync_api.FileChooser.isMultiple" href="#playwright.sync_api.FileChooser.isMultiple">isMultiple</a></code></li>
<li><code><a title="playwright.sync_api.FileChooser.page" href="#playwright.sync_api.FileChooser.page">page</a></code></li>
<li><code><a title="playwright.sync_api.FileChooser.setFiles" href="#playwright.sync_api.FileChooser.setFiles">setFiles</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.sync_api.Frame" href="#playwright.sync_api.Frame">Frame</a></code></h4>
<ul class="two-column">
<li><code><a title="playwright.sync_api.Frame.addScriptTag" href="#playwright.sync_api.Frame.addScriptTag">addScriptTag</a></code></li>
<li><code><a title="playwright.sync_api.Frame.addStyleTag" href="#playwright.sync_api.Frame.addStyleTag">addStyleTag</a></code></li>
<li><code><a title="playwright.sync_api.Frame.check" href="#playwright.sync_api.Frame.check">check</a></code></li>
<li><code><a title="playwright.sync_api.Frame.childFrames" href="#playwright.sync_api.Frame.childFrames">childFrames</a></code></li>
<li><code><a title="playwright.sync_api.Frame.click" href="#playwright.sync_api.Frame.click">click</a></code></li>
<li><code><a title="playwright.sync_api.Frame.content" href="#playwright.sync_api.Frame.content">content</a></code></li>
<li><code><a title="playwright.sync_api.Frame.dblclick" href="#playwright.sync_api.Frame.dblclick">dblclick</a></code></li>
<li><code><a title="playwright.sync_api.Frame.dispatchEvent" href="#playwright.sync_api.Frame.dispatchEvent">dispatchEvent</a></code></li>
<li><code><a title="playwright.sync_api.Frame.evalOnSelector" href="#playwright.sync_api.Frame.evalOnSelector">evalOnSelector</a></code></li>
<li><code><a title="playwright.sync_api.Frame.evalOnSelectorAll" href="#playwright.sync_api.Frame.evalOnSelectorAll">evalOnSelectorAll</a></code></li>
<li><code><a title="playwright.sync_api.Frame.evaluate" href="#playwright.sync_api.Frame.evaluate">evaluate</a></code></li>
<li><code><a title="playwright.sync_api.Frame.evaluateHandle" href="#playwright.sync_api.Frame.evaluateHandle">evaluateHandle</a></code></li>
<li><code><a title="playwright.sync_api.Frame.expect_load_state" href="#playwright.sync_api.Frame.expect_load_state">expect_load_state</a></code></li>
<li><code><a title="playwright.sync_api.Frame.expect_navigation" href="#playwright.sync_api.Frame.expect_navigation">expect_navigation</a></code></li>
<li><code><a title="playwright.sync_api.Frame.fill" href="#playwright.sync_api.Frame.fill">fill</a></code></li>
<li><code><a title="playwright.sync_api.Frame.focus" href="#playwright.sync_api.Frame.focus">focus</a></code></li>
<li><code><a title="playwright.sync_api.Frame.frameElement" href="#playwright.sync_api.Frame.frameElement">frameElement</a></code></li>
<li><code><a title="playwright.sync_api.Frame.getAttribute" href="#playwright.sync_api.Frame.getAttribute">getAttribute</a></code></li>
<li><code><a title="playwright.sync_api.Frame.goto" href="#playwright.sync_api.Frame.goto">goto</a></code></li>
<li><code><a title="playwright.sync_api.Frame.hover" href="#playwright.sync_api.Frame.hover">hover</a></code></li>
<li><code><a title="playwright.sync_api.Frame.innerHTML" href="#playwright.sync_api.Frame.innerHTML">innerHTML</a></code></li>
<li><code><a title="playwright.sync_api.Frame.innerText" href="#playwright.sync_api.Frame.innerText">innerText</a></code></li>
<li><code><a title="playwright.sync_api.Frame.isDetached" href="#playwright.sync_api.Frame.isDetached">isDetached</a></code></li>
<li><code><a title="playwright.sync_api.Frame.name" href="#playwright.sync_api.Frame.name">name</a></code></li>
<li><code><a title="playwright.sync_api.Frame.page" href="#playwright.sync_api.Frame.page">page</a></code></li>
<li><code><a title="playwright.sync_api.Frame.parentFrame" href="#playwright.sync_api.Frame.parentFrame">parentFrame</a></code></li>
<li><code><a title="playwright.sync_api.Frame.press" href="#playwright.sync_api.Frame.press">press</a></code></li>
<li><code><a title="playwright.sync_api.Frame.querySelector" href="#playwright.sync_api.Frame.querySelector">querySelector</a></code></li>
<li><code><a title="playwright.sync_api.Frame.querySelectorAll" href="#playwright.sync_api.Frame.querySelectorAll">querySelectorAll</a></code></li>
<li><code><a title="playwright.sync_api.Frame.selectOption" href="#playwright.sync_api.Frame.selectOption">selectOption</a></code></li>
<li><code><a title="playwright.sync_api.Frame.setContent" href="#playwright.sync_api.Frame.setContent">setContent</a></code></li>
<li><code><a title="playwright.sync_api.Frame.setInputFiles" href="#playwright.sync_api.Frame.setInputFiles">setInputFiles</a></code></li>
<li><code><a title="playwright.sync_api.Frame.tap" href="#playwright.sync_api.Frame.tap">tap</a></code></li>
<li><code><a title="playwright.sync_api.Frame.textContent" href="#playwright.sync_api.Frame.textContent">textContent</a></code></li>
<li><code><a title="playwright.sync_api.Frame.title" href="#playwright.sync_api.Frame.title">title</a></code></li>
<li><code><a title="playwright.sync_api.Frame.type" href="#playwright.sync_api.Frame.type">type</a></code></li>
<li><code><a title="playwright.sync_api.Frame.uncheck" href="#playwright.sync_api.Frame.uncheck">uncheck</a></code></li>
<li><code><a title="playwright.sync_api.Frame.url" href="#playwright.sync_api.Frame.url">url</a></code></li>
<li><code><a title="playwright.sync_api.Frame.waitForFunction" href="#playwright.sync_api.Frame.waitForFunction">waitForFunction</a></code></li>
<li><code><a title="playwright.sync_api.Frame.waitForLoadState" href="#playwright.sync_api.Frame.waitForLoadState">waitForLoadState</a></code></li>
<li><code><a title="playwright.sync_api.Frame.waitForNavigation" href="#playwright.sync_api.Frame.waitForNavigation">waitForNavigation</a></code></li>
<li><code><a title="playwright.sync_api.Frame.waitForSelector" href="#playwright.sync_api.Frame.waitForSelector">waitForSelector</a></code></li>
<li><code><a title="playwright.sync_api.Frame.waitForTimeout" href="#playwright.sync_api.Frame.waitForTimeout">waitForTimeout</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.sync_api.JSHandle" href="#playwright.sync_api.JSHandle">JSHandle</a></code></h4>
<ul class="two-column">
<li><code><a title="playwright.sync_api.JSHandle.asElement" href="#playwright.sync_api.JSHandle.asElement">asElement</a></code></li>
<li><code><a title="playwright.sync_api.JSHandle.dispose" href="#playwright.sync_api.JSHandle.dispose">dispose</a></code></li>
<li><code><a title="playwright.sync_api.JSHandle.evaluate" href="#playwright.sync_api.JSHandle.evaluate">evaluate</a></code></li>
<li><code><a title="playwright.sync_api.JSHandle.evaluateHandle" href="#playwright.sync_api.JSHandle.evaluateHandle">evaluateHandle</a></code></li>
<li><code><a title="playwright.sync_api.JSHandle.getProperties" href="#playwright.sync_api.JSHandle.getProperties">getProperties</a></code></li>
<li><code><a title="playwright.sync_api.JSHandle.getProperty" href="#playwright.sync_api.JSHandle.getProperty">getProperty</a></code></li>
<li><code><a title="playwright.sync_api.JSHandle.jsonValue" href="#playwright.sync_api.JSHandle.jsonValue">jsonValue</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.sync_api.Keyboard" href="#playwright.sync_api.Keyboard">Keyboard</a></code></h4>
<ul class="">
<li><code><a title="playwright.sync_api.Keyboard.down" href="#playwright.sync_api.Keyboard.down">down</a></code></li>
<li><code><a title="playwright.sync_api.Keyboard.insertText" href="#playwright.sync_api.Keyboard.insertText">insertText</a></code></li>
<li><code><a title="playwright.sync_api.Keyboard.press" href="#playwright.sync_api.Keyboard.press">press</a></code></li>
<li><code><a title="playwright.sync_api.Keyboard.type" href="#playwright.sync_api.Keyboard.type">type</a></code></li>
<li><code><a title="playwright.sync_api.Keyboard.up" href="#playwright.sync_api.Keyboard.up">up</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.sync_api.Mouse" href="#playwright.sync_api.Mouse">Mouse</a></code></h4>
<ul class="">
<li><code><a title="playwright.sync_api.Mouse.click" href="#playwright.sync_api.Mouse.click">click</a></code></li>
<li><code><a title="playwright.sync_api.Mouse.dblclick" href="#playwright.sync_api.Mouse.dblclick">dblclick</a></code></li>
<li><code><a title="playwright.sync_api.Mouse.down" href="#playwright.sync_api.Mouse.down">down</a></code></li>
<li><code><a title="playwright.sync_api.Mouse.move" href="#playwright.sync_api.Mouse.move">move</a></code></li>
<li><code><a title="playwright.sync_api.Mouse.up" href="#playwright.sync_api.Mouse.up">up</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.sync_api.Page" href="#playwright.sync_api.Page">Page</a></code></h4>
<ul class="">
<li><code><a title="playwright.sync_api.Page.accessibility" href="#playwright.sync_api.Page.accessibility">accessibility</a></code></li>
<li><code><a title="playwright.sync_api.Page.addInitScript" href="#playwright.sync_api.Page.addInitScript">addInitScript</a></code></li>
<li><code><a title="playwright.sync_api.Page.addScriptTag" href="#playwright.sync_api.Page.addScriptTag">addScriptTag</a></code></li>
<li><code><a title="playwright.sync_api.Page.addStyleTag" href="#playwright.sync_api.Page.addStyleTag">addStyleTag</a></code></li>
<li><code><a title="playwright.sync_api.Page.bringToFront" href="#playwright.sync_api.Page.bringToFront">bringToFront</a></code></li>
<li><code><a title="playwright.sync_api.Page.check" href="#playwright.sync_api.Page.check">check</a></code></li>
<li><code><a title="playwright.sync_api.Page.click" href="#playwright.sync_api.Page.click">click</a></code></li>
<li><code><a title="playwright.sync_api.Page.close" href="#playwright.sync_api.Page.close">close</a></code></li>
<li><code><a title="playwright.sync_api.Page.content" href="#playwright.sync_api.Page.content">content</a></code></li>
<li><code><a title="playwright.sync_api.Page.context" href="#playwright.sync_api.Page.context">context</a></code></li>
<li><code><a title="playwright.sync_api.Page.dblclick" href="#playwright.sync_api.Page.dblclick">dblclick</a></code></li>
<li><code><a title="playwright.sync_api.Page.dispatchEvent" href="#playwright.sync_api.Page.dispatchEvent">dispatchEvent</a></code></li>
<li><code><a title="playwright.sync_api.Page.emulateMedia" href="#playwright.sync_api.Page.emulateMedia">emulateMedia</a></code></li>
<li><code><a title="playwright.sync_api.Page.evalOnSelector" href="#playwright.sync_api.Page.evalOnSelector">evalOnSelector</a></code></li>
<li><code><a title="playwright.sync_api.Page.evalOnSelectorAll" href="#playwright.sync_api.Page.evalOnSelectorAll">evalOnSelectorAll</a></code></li>
<li><code><a title="playwright.sync_api.Page.evaluate" href="#playwright.sync_api.Page.evaluate">evaluate</a></code></li>
<li><code><a title="playwright.sync_api.Page.evaluateHandle" href="#playwright.sync_api.Page.evaluateHandle">evaluateHandle</a></code></li>
<li><code><a title="playwright.sync_api.Page.expect_console_message" href="#playwright.sync_api.Page.expect_console_message">expect_console_message</a></code></li>
<li><code><a title="playwright.sync_api.Page.expect_dialog" href="#playwright.sync_api.Page.expect_dialog">expect_dialog</a></code></li>
<li><code><a title="playwright.sync_api.Page.expect_download" href="#playwright.sync_api.Page.expect_download">expect_download</a></code></li>
<li><code><a title="playwright.sync_api.Page.expect_event" href="#playwright.sync_api.Page.expect_event">expect_event</a></code></li>
<li><code><a title="playwright.sync_api.Page.expect_file_chooser" href="#playwright.sync_api.Page.expect_file_chooser">expect_file_chooser</a></code></li>
<li><code><a title="playwright.sync_api.Page.expect_load_state" href="#playwright.sync_api.Page.expect_load_state">expect_load_state</a></code></li>
<li><code><a title="playwright.sync_api.Page.expect_navigation" href="#playwright.sync_api.Page.expect_navigation">expect_navigation</a></code></li>
<li><code><a title="playwright.sync_api.Page.expect_popup" href="#playwright.sync_api.Page.expect_popup">expect_popup</a></code></li>
<li><code><a title="playwright.sync_api.Page.expect_request" href="#playwright.sync_api.Page.expect_request">expect_request</a></code></li>
<li><code><a title="playwright.sync_api.Page.expect_response" href="#playwright.sync_api.Page.expect_response">expect_response</a></code></li>
<li><code><a title="playwright.sync_api.Page.expect_worker" href="#playwright.sync_api.Page.expect_worker">expect_worker</a></code></li>
<li><code><a title="playwright.sync_api.Page.exposeBinding" href="#playwright.sync_api.Page.exposeBinding">exposeBinding</a></code></li>
<li><code><a title="playwright.sync_api.Page.exposeFunction" href="#playwright.sync_api.Page.exposeFunction">exposeFunction</a></code></li>
<li><code><a title="playwright.sync_api.Page.fill" href="#playwright.sync_api.Page.fill">fill</a></code></li>
<li><code><a title="playwright.sync_api.Page.focus" href="#playwright.sync_api.Page.focus">focus</a></code></li>
<li><code><a title="playwright.sync_api.Page.frame" href="#playwright.sync_api.Page.frame">frame</a></code></li>
<li><code><a title="playwright.sync_api.Page.frames" href="#playwright.sync_api.Page.frames">frames</a></code></li>
<li><code><a title="playwright.sync_api.Page.getAttribute" href="#playwright.sync_api.Page.getAttribute">getAttribute</a></code></li>
<li><code><a title="playwright.sync_api.Page.goBack" href="#playwright.sync_api.Page.goBack">goBack</a></code></li>
<li><code><a title="playwright.sync_api.Page.goForward" href="#playwright.sync_api.Page.goForward">goForward</a></code></li>
<li><code><a title="playwright.sync_api.Page.goto" href="#playwright.sync_api.Page.goto">goto</a></code></li>
<li><code><a title="playwright.sync_api.Page.hover" href="#playwright.sync_api.Page.hover">hover</a></code></li>
<li><code><a title="playwright.sync_api.Page.innerHTML" href="#playwright.sync_api.Page.innerHTML">innerHTML</a></code></li>
<li><code><a title="playwright.sync_api.Page.innerText" href="#playwright.sync_api.Page.innerText">innerText</a></code></li>
<li><code><a title="playwright.sync_api.Page.isClosed" href="#playwright.sync_api.Page.isClosed">isClosed</a></code></li>
<li><code><a title="playwright.sync_api.Page.keyboard" href="#playwright.sync_api.Page.keyboard">keyboard</a></code></li>
<li><code><a title="playwright.sync_api.Page.mainFrame" href="#playwright.sync_api.Page.mainFrame">mainFrame</a></code></li>
<li><code><a title="playwright.sync_api.Page.mouse" href="#playwright.sync_api.Page.mouse">mouse</a></code></li>
<li><code><a title="playwright.sync_api.Page.opener" href="#playwright.sync_api.Page.opener">opener</a></code></li>
<li><code><a title="playwright.sync_api.Page.pdf" href="#playwright.sync_api.Page.pdf">pdf</a></code></li>
<li><code><a title="playwright.sync_api.Page.press" href="#playwright.sync_api.Page.press">press</a></code></li>
<li><code><a title="playwright.sync_api.Page.querySelector" href="#playwright.sync_api.Page.querySelector">querySelector</a></code></li>
<li><code><a title="playwright.sync_api.Page.querySelectorAll" href="#playwright.sync_api.Page.querySelectorAll">querySelectorAll</a></code></li>
<li><code><a title="playwright.sync_api.Page.reload" href="#playwright.sync_api.Page.reload">reload</a></code></li>
<li><code><a title="playwright.sync_api.Page.route" href="#playwright.sync_api.Page.route">route</a></code></li>
<li><code><a title="playwright.sync_api.Page.screenshot" href="#playwright.sync_api.Page.screenshot">screenshot</a></code></li>
<li><code><a title="playwright.sync_api.Page.selectOption" href="#playwright.sync_api.Page.selectOption">selectOption</a></code></li>
<li><code><a title="playwright.sync_api.Page.setContent" href="#playwright.sync_api.Page.setContent">setContent</a></code></li>
<li><code><a title="playwright.sync_api.Page.setDefaultNavigationTimeout" href="#playwright.sync_api.Page.setDefaultNavigationTimeout">setDefaultNavigationTimeout</a></code></li>
<li><code><a title="playwright.sync_api.Page.setDefaultTimeout" href="#playwright.sync_api.Page.setDefaultTimeout">setDefaultTimeout</a></code></li>
<li><code><a title="playwright.sync_api.Page.setExtraHTTPHeaders" href="#playwright.sync_api.Page.setExtraHTTPHeaders">setExtraHTTPHeaders</a></code></li>
<li><code><a title="playwright.sync_api.Page.setInputFiles" href="#playwright.sync_api.Page.setInputFiles">setInputFiles</a></code></li>
<li><code><a title="playwright.sync_api.Page.setViewportSize" href="#playwright.sync_api.Page.setViewportSize">setViewportSize</a></code></li>
<li><code><a title="playwright.sync_api.Page.tap" href="#playwright.sync_api.Page.tap">tap</a></code></li>
<li><code><a title="playwright.sync_api.Page.textContent" href="#playwright.sync_api.Page.textContent">textContent</a></code></li>
<li><code><a title="playwright.sync_api.Page.title" href="#playwright.sync_api.Page.title">title</a></code></li>
<li><code><a title="playwright.sync_api.Page.touchscreen" href="#playwright.sync_api.Page.touchscreen">touchscreen</a></code></li>
<li><code><a title="playwright.sync_api.Page.type" href="#playwright.sync_api.Page.type">type</a></code></li>
<li><code><a title="playwright.sync_api.Page.uncheck" href="#playwright.sync_api.Page.uncheck">uncheck</a></code></li>
<li><code><a title="playwright.sync_api.Page.unroute" href="#playwright.sync_api.Page.unroute">unroute</a></code></li>
<li><code><a title="playwright.sync_api.Page.url" href="#playwright.sync_api.Page.url">url</a></code></li>
<li><code><a title="playwright.sync_api.Page.video" href="#playwright.sync_api.Page.video">video</a></code></li>
<li><code><a title="playwright.sync_api.Page.viewportSize" href="#playwright.sync_api.Page.viewportSize">viewportSize</a></code></li>
<li><code><a title="playwright.sync_api.Page.waitForEvent" href="#playwright.sync_api.Page.waitForEvent">waitForEvent</a></code></li>
<li><code><a title="playwright.sync_api.Page.waitForFunction" href="#playwright.sync_api.Page.waitForFunction">waitForFunction</a></code></li>
<li><code><a title="playwright.sync_api.Page.waitForLoadState" href="#playwright.sync_api.Page.waitForLoadState">waitForLoadState</a></code></li>
<li><code><a title="playwright.sync_api.Page.waitForNavigation" href="#playwright.sync_api.Page.waitForNavigation">waitForNavigation</a></code></li>
<li><code><a title="playwright.sync_api.Page.waitForRequest" href="#playwright.sync_api.Page.waitForRequest">waitForRequest</a></code></li>
<li><code><a title="playwright.sync_api.Page.waitForResponse" href="#playwright.sync_api.Page.waitForResponse">waitForResponse</a></code></li>
<li><code><a title="playwright.sync_api.Page.waitForSelector" href="#playwright.sync_api.Page.waitForSelector">waitForSelector</a></code></li>
<li><code><a title="playwright.sync_api.Page.waitForTimeout" href="#playwright.sync_api.Page.waitForTimeout">waitForTimeout</a></code></li>
<li><code><a title="playwright.sync_api.Page.workers" href="#playwright.sync_api.Page.workers">workers</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.sync_api.Playwright" href="#playwright.sync_api.Playwright">Playwright</a></code></h4>
<ul class="two-column">
<li><code><a title="playwright.sync_api.Playwright.chromium" href="#playwright.sync_api.Playwright.chromium">chromium</a></code></li>
<li><code><a title="playwright.sync_api.Playwright.devices" href="#playwright.sync_api.Playwright.devices">devices</a></code></li>
<li><code><a title="playwright.sync_api.Playwright.firefox" href="#playwright.sync_api.Playwright.firefox">firefox</a></code></li>
<li><code><a title="playwright.sync_api.Playwright.selectors" href="#playwright.sync_api.Playwright.selectors">selectors</a></code></li>
<li><code><a title="playwright.sync_api.Playwright.stop" href="#playwright.sync_api.Playwright.stop">stop</a></code></li>
<li><code><a title="playwright.sync_api.Playwright.webkit" href="#playwright.sync_api.Playwright.webkit">webkit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.sync_api.Request" href="#playwright.sync_api.Request">Request</a></code></h4>
<ul class="two-column">
<li><code><a title="playwright.sync_api.Request.failure" href="#playwright.sync_api.Request.failure">failure</a></code></li>
<li><code><a title="playwright.sync_api.Request.frame" href="#playwright.sync_api.Request.frame">frame</a></code></li>
<li><code><a title="playwright.sync_api.Request.headers" href="#playwright.sync_api.Request.headers">headers</a></code></li>
<li><code><a title="playwright.sync_api.Request.isNavigationRequest" href="#playwright.sync_api.Request.isNavigationRequest">isNavigationRequest</a></code></li>
<li><code><a title="playwright.sync_api.Request.method" href="#playwright.sync_api.Request.method">method</a></code></li>
<li><code><a title="playwright.sync_api.Request.postData" href="#playwright.sync_api.Request.postData">postData</a></code></li>
<li><code><a title="playwright.sync_api.Request.postDataBuffer" href="#playwright.sync_api.Request.postDataBuffer">postDataBuffer</a></code></li>
<li><code><a title="playwright.sync_api.Request.postDataJSON" href="#playwright.sync_api.Request.postDataJSON">postDataJSON</a></code></li>
<li><code><a title="playwright.sync_api.Request.redirectedFrom" href="#playwright.sync_api.Request.redirectedFrom">redirectedFrom</a></code></li>
<li><code><a title="playwright.sync_api.Request.redirectedTo" href="#playwright.sync_api.Request.redirectedTo">redirectedTo</a></code></li>
<li><code><a title="playwright.sync_api.Request.resourceType" href="#playwright.sync_api.Request.resourceType">resourceType</a></code></li>
<li><code><a title="playwright.sync_api.Request.response" href="#playwright.sync_api.Request.response">response</a></code></li>
<li><code><a title="playwright.sync_api.Request.timing" href="#playwright.sync_api.Request.timing">timing</a></code></li>
<li><code><a title="playwright.sync_api.Request.url" href="#playwright.sync_api.Request.url">url</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.sync_api.Response" href="#playwright.sync_api.Response">Response</a></code></h4>
<ul class="two-column">
<li><code><a title="playwright.sync_api.Response.body" href="#playwright.sync_api.Response.body">body</a></code></li>
<li><code><a title="playwright.sync_api.Response.finished" href="#playwright.sync_api.Response.finished">finished</a></code></li>
<li><code><a title="playwright.sync_api.Response.frame" href="#playwright.sync_api.Response.frame">frame</a></code></li>
<li><code><a title="playwright.sync_api.Response.headers" href="#playwright.sync_api.Response.headers">headers</a></code></li>
<li><code><a title="playwright.sync_api.Response.json" href="#playwright.sync_api.Response.json">json</a></code></li>
<li><code><a title="playwright.sync_api.Response.ok" href="#playwright.sync_api.Response.ok">ok</a></code></li>
<li><code><a title="playwright.sync_api.Response.request" href="#playwright.sync_api.Response.request">request</a></code></li>
<li><code><a title="playwright.sync_api.Response.status" href="#playwright.sync_api.Response.status">status</a></code></li>
<li><code><a title="playwright.sync_api.Response.statusText" href="#playwright.sync_api.Response.statusText">statusText</a></code></li>
<li><code><a title="playwright.sync_api.Response.text" href="#playwright.sync_api.Response.text">text</a></code></li>
<li><code><a title="playwright.sync_api.Response.url" href="#playwright.sync_api.Response.url">url</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.sync_api.Route" href="#playwright.sync_api.Route">Route</a></code></h4>
<ul class="">
<li><code><a title="playwright.sync_api.Route.abort" href="#playwright.sync_api.Route.abort">abort</a></code></li>
<li><code><a title="playwright.sync_api.Route.continue_" href="#playwright.sync_api.Route.continue_">continue_</a></code></li>
<li><code><a title="playwright.sync_api.Route.fulfill" href="#playwright.sync_api.Route.fulfill">fulfill</a></code></li>
<li><code><a title="playwright.sync_api.Route.request" href="#playwright.sync_api.Route.request">request</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.sync_api.Selectors" href="#playwright.sync_api.Selectors">Selectors</a></code></h4>
<ul class="">
<li><code><a title="playwright.sync_api.Selectors.register" href="#playwright.sync_api.Selectors.register">register</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.sync_api.Touchscreen" href="#playwright.sync_api.Touchscreen">Touchscreen</a></code></h4>
<ul class="">
<li><code><a title="playwright.sync_api.Touchscreen.tap" href="#playwright.sync_api.Touchscreen.tap">tap</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.sync_api.Video" href="#playwright.sync_api.Video">Video</a></code></h4>
<ul class="">
<li><code><a title="playwright.sync_api.Video.path" href="#playwright.sync_api.Video.path">path</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.sync_api.WebSocket" href="#playwright.sync_api.WebSocket">WebSocket</a></code></h4>
<ul class="">
<li><code><a title="playwright.sync_api.WebSocket.expect_event" href="#playwright.sync_api.WebSocket.expect_event">expect_event</a></code></li>
<li><code><a title="playwright.sync_api.WebSocket.isClosed" href="#playwright.sync_api.WebSocket.isClosed">isClosed</a></code></li>
<li><code><a title="playwright.sync_api.WebSocket.url" href="#playwright.sync_api.WebSocket.url">url</a></code></li>
<li><code><a title="playwright.sync_api.WebSocket.waitForEvent" href="#playwright.sync_api.WebSocket.waitForEvent">waitForEvent</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.sync_api.Worker" href="#playwright.sync_api.Worker">Worker</a></code></h4>
<ul class="">
<li><code><a title="playwright.sync_api.Worker.evaluate" href="#playwright.sync_api.Worker.evaluate">evaluate</a></code></li>
<li><code><a title="playwright.sync_api.Worker.evaluateHandle" href="#playwright.sync_api.Worker.evaluateHandle">evaluateHandle</a></code></li>
<li><code><a title="playwright.sync_api.Worker.url" href="#playwright.sync_api.Worker.url">url</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>